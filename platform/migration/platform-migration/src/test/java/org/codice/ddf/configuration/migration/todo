
    @Test
    public void testConstructorWithUnixName() throws Exception {
        final ExportMigrationEntryImpl ENTRY = new ExportMigrationEntryImpl(CONTEXT, UNIX_NAME);

        Assert.assertThat(ENTRY.getContext(), Matchers.sameInstance(CONTEXT));
        Assert.assertThat(ENTRY.getPath(), Matchers.equalTo(FILE_PATH));
    }
    //
    //    @Test
    //    public void testConstructorWithWindowsName() throws Exception {
    //        final MigrationEntryImpl ENTRY = Mockito.mock(MigrationEntryImpl.class,
    //                Mockito.withSettings()
    //                        .useConstructor(CONTEXT, WINDOWS_NAME)
    //                        .defaultAnswer(Mockito.CALLS_REAL_METHODS));
    //
    //        Assert.assertThat(ENTRY.getContext(), Matchers.sameInstance(CONTEXT));
    //        Assert.assertThat(ENTRY.getPath(), Matchers.equalTo(FILE_PATH));
    //    }
    //
    //    @Test
    //    public void testConstructorWithMixedName() throws Exception {
    //        final MigrationEntryImpl ENTRY = Mockito.mock(MigrationEntryImpl.class,
    //                Mockito.withSettings()
    //                        .useConstructor(CONTEXT, MIXED_NAME)
    //                        .defaultAnswer(Mockito.CALLS_REAL_METHODS));
    //
    //        Assert.assertThat(ENTRY.getContext(), Matchers.sameInstance(CONTEXT));
    //        Assert.assertThat(ENTRY.getPath(), Matchers.equalTo(FILE_PATH));
    //    }
    //
    //    @Test
    //    public void testConstructorWithProviderAndMigratableFQN() throws Exception {
    //        final Function<String, MigrationContextImpl> PROVIDER = Mockito.mock(Function.class);
    //
    //        Mockito.when(PROVIDER.apply(Mockito.anyString()))
    //                .thenReturn(CONTEXT);
    //
    //        final MigrationEntryImpl ENTRY = Mockito.mock(MigrationEntryImpl.class,
    //                Mockito.withSettings()
    //                        .useConstructor(PROVIDER, MIGRATABLE_FQN)
    //                        .defaultAnswer(Mockito.CALLS_REAL_METHODS));
    //
    //        Assert.assertThat(ENTRY.getContext(), Matchers.sameInstance(CONTEXT));
    //        Assert.assertThat(ENTRY.getPath(), Matchers.equalTo(FILE_PATH));
    //
    //        Mockito.verify(PROVIDER, Mockito.only())
    //                .apply(MIGRATABLE_ID);
    //    }
    //
    //    @Test
    //    public void testConstructorWithProviderAndSystemFQN() throws Exception {
    //        final Function<String, MigrationContextImpl> PROVIDER = Mockito.mock(Function.class);
    //
    //        Mockito.when(PROVIDER.apply(Mockito.nullable(String.class)))
    //                .thenReturn(CONTEXT);
    //
    //        final MigrationEntryImpl ENTRY = Mockito.mock(MigrationEntryImpl.class,
    //                Mockito.withSettings()
    //                        .useConstructor(PROVIDER, SYSTEM_FQN)
    //                        .defaultAnswer(Mockito.CALLS_REAL_METHODS));
    //
    //        Assert.assertThat(ENTRY.getContext(), Matchers.sameInstance(CONTEXT));
    //        Assert.assertThat(ENTRY.getPath(), Matchers.equalTo(Paths.get(SYSTEM_FQN)));
    //
    //        Mockito.verify(PROVIDER, Mockito.only())
    //                .apply(null);
    //    }
    //
    //    @Test
    //    public void testConstructorWithNullProvider() throws Exception {
    //        thrown.expect(ThrowableMatchers.hasInitialCauseMatching(Matchers.instanceOf(
    //                IllegalArgumentException.class)));
    //        // unfortunately, right now Mockito has no way to control which of the 2 ctors is called
    //        // thrown.expect(ThrowableMatchers.hasInitialCauseMessageMatching(Matchers.containsString(
    //        //        "null context provider")));
    //
    //        Mockito.mock(MigrationEntryImpl.class,
    //                Mockito.withSettings()
    //                        .useConstructor(null, MIGRATABLE_FQN)
    //                        .defaultAnswer(Mockito.CALLS_REAL_METHODS));
    //    }
    //
    //    @Test
    //    public void testConstructorWithProviderAndNullFQN() throws Exception {
    //        final Function<String, MigrationContextImpl> PROVIDER = Mockito.mock(Function.class);
    //
    //        thrown.expect(ThrowableMatchers.hasInitialCauseMatching(Matchers.instanceOf(
    //                IllegalArgumentException.class)));
    //        thrown.expect(ThrowableMatchers.hasInitialCauseMessageMatching(Matchers.containsString(
    //                "null fully qualified name")));
    //
    //        Mockito.mock(MigrationEntryImpl.class,
    //                Mockito.withSettings()
    //                        .useConstructor(PROVIDER, null)
    //                        .defaultAnswer(Mockito.CALLS_REAL_METHODS));
    //    }

