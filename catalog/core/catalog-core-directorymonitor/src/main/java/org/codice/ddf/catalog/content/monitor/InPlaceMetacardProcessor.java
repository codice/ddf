/**
 * Copyright (c) Codice Foundation
 *
 * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU
 * Lesser General Public License as published by the Free Software Foundation, either version 3 of
 * the License, or any later version.
 *
 * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public
 * License is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 */
package org.codice.ddf.catalog.content.monitor;

import ddf.catalog.Constants;
import ddf.catalog.data.Attribute;
import ddf.catalog.data.AttributeDescriptor;
import ddf.catalog.data.AttributeRegistry;
import ddf.catalog.data.Metacard;
import ddf.catalog.data.impl.AttributeImpl;
import ddf.catalog.data.types.Core;
import java.io.Serializable;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.xml.bind.DatatypeConverter;
import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.commons.collections.MapUtils;
import org.apache.commons.lang.StringUtils;

/**
 * Camel processor for metacards generated by a CDM in-place configuration. Sets select attributes
 * on the metacard in an exchange.
 */
public class InPlaceMetacardProcessor implements Processor {

  private final AttributeRegistry attributeRegistry;

  public InPlaceMetacardProcessor(AttributeRegistry attributeRegistry) {
    this.attributeRegistry = attributeRegistry;
  }

  @Override
  public void process(Exchange exchange) {
    Object body = exchange.getIn().getBody();
    if (!(body instanceof Metacard)) {
      return;
    }

    Metacard metacard = (Metacard) body;
    writeMetacardAttribute(metacard, Core.TITLE, getHeaderAsString(exchange, Exchange.FILE_NAME));
    writeMetacardAttribute(
        metacard, Core.RESOURCE_SIZE, getHeaderAsString(exchange, Exchange.FILE_LENGTH));
    writeMetacardAttribute(
        metacard, Core.RESOURCE_URI, getHeaderAsString(exchange, Core.RESOURCE_URI));

    Map overrides = exchange.getIn().getHeader(Constants.ATTRIBUTE_OVERRIDES_KEY, Map.class);
    overrideAttributes(metacard, overrides);
  }

  /**
   * Sets the attribute on a metacard. If attributeValue is empty or null, then nothing will be set
   * on the metacard. Does not override existing attributes.
   *
   * @param metacard metacard to add attribute to
   * @param attributeName attribute name to add
   * @param attributeValue attribute value to add
   */
  private void writeMetacardAttribute(
      Metacard metacard, String attributeName, String attributeValue) {
    if (StringUtils.isEmpty(attributeValue)) {
      return;
    }

    Attribute attribute = metacard.getAttribute(attributeName);
    if (attribute != null) {
      return;
    }
    metacard.setAttribute(new AttributeImpl(attributeName, attributeValue));
  }

  /**
   * @param exchange exchange to get header from
   * @param headerKey header key
   * @return value as string, or null if the header key doesn't exist or is not of type string
   */
  private String getHeaderAsString(Exchange exchange, String headerKey) {
    Object fileName = exchange.getIn().getHeaders().get(headerKey);
    if (fileName instanceof String) {
      return (String) fileName;
    }
    return null;
  }

  private void overrideAttributes(Metacard metacard, Map<String, Serializable> attributeOverrides) {
    if (MapUtils.isEmpty(attributeOverrides)) {
      return;
    }

    attributeOverrides
        .keySet()
        .stream()
        .map(attributeRegistry::lookup)
        .filter(Optional::isPresent)
        .map(Optional::get)
        .map(ad -> overrideAttributeValue(ad, attributeOverrides.get(ad.getName())))
        .filter(Objects::nonNull)
        .forEach(metacard::setAttribute);
  }

  private AttributeImpl overrideAttributeValue(
      AttributeDescriptor attributeDescriptor, Serializable overrideValue) {
    List<Serializable> newValue = new ArrayList<>();
    for (Object o :
        overrideValue instanceof List
            ? (List) overrideValue
            : Collections.singletonList(overrideValue)) {
      try {
        String override = String.valueOf(o);
        switch (attributeDescriptor.getType().getAttributeFormat()) {
          case INTEGER:
            newValue.add(Integer.parseInt(override));
            break;
          case FLOAT:
            newValue.add(Float.parseFloat(override));
            break;
          case DOUBLE:
            newValue.add(Double.parseDouble(override));
            break;
          case SHORT:
            newValue.add(Short.parseShort(override));
            break;
          case LONG:
            newValue.add(Long.parseLong(override));
            break;
          case DATE:
            Calendar calendar = DatatypeConverter.parseDateTime(override);
            newValue.add(calendar.getTime());
            break;
          case BOOLEAN:
            newValue.add(Boolean.parseBoolean(override));
            break;
          case BINARY:
            newValue.add(override.getBytes(Charset.forName("UTF-8")));
            break;
          case OBJECT:
          case STRING:
          case GEOMETRY:
          case XML:
            newValue.add(override);
            break;
        }
      } catch (IllegalArgumentException e) {
        return null;
      }
    }
    return new AttributeImpl(attributeDescriptor.getName(), newValue);
  }
}
