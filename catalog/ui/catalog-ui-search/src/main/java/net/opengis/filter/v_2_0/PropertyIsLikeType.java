/**
 * Copyright (c) Codice Foundation
 *
 * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU
 * Lesser General Public License as published by the Free Software Foundation, either version 3 of
 * the License, or any later version.
 *
 * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public
 * License is distributed along with this program and can be found at
 * <http://www.gnu.org/licenses/lgpl.html>.
 */
//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
// Implementation, v2.2.11
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2016.02.26 at 04:47:12 PM AST
//

package net.opengis.filter.v_2_0;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy2;
import org.jvnet.jaxb2_commons.lang.CopyTo2;
import org.jvnet.jaxb2_commons.lang.Equals2;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy2;
import org.jvnet.jaxb2_commons.lang.HashCode2;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy2;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBMergeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.MergeFrom2;
import org.jvnet.jaxb2_commons.lang.MergeStrategy2;
import org.jvnet.jaxb2_commons.lang.ToString2;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy2;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;

/**
 * Java class for PropertyIsLikeType complex type.
 *
 * <p>The following schema fragment specifies the expected content contained within this class.
 *
 * <pre>
 * &lt;complexType name="PropertyIsLikeType"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://www.opengis.net/fes/2.0}ComparisonOpsType"&gt;
 *       &lt;sequence&gt;
 *         &lt;element ref="{http://www.opengis.net/fes/2.0}expression" maxOccurs="2" minOccurs="2"/&gt;
 *       &lt;/sequence&gt;
 *       &lt;attribute name="wildCard" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *       &lt;attribute name="singleChar" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *       &lt;attribute name="escapeChar" use="required" type="{http://www.w3.org/2001/XMLSchema}string" /&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(
  name = "PropertyIsLikeType",
  propOrder = {"expression"}
)
public class PropertyIsLikeType extends ComparisonOpsType
    implements Cloneable, CopyTo2, Equals2, HashCode2, MergeFrom2, ToString2 {

  @XmlElementRef(
    name = "expression",
    namespace = "http://www.opengis.net/fes/2.0",
    type = JAXBElement.class
  )
  protected List<JAXBElement<?>> expression;

  @XmlAttribute(name = "wildCard", required = true)
  protected String wildCard;

  @XmlAttribute(name = "singleChar", required = true)
  protected String singleChar;

  @XmlAttribute(name = "escapeChar", required = true)
  protected String escapeChar;

  @XmlAttribute(name = "matchCase")
  protected Boolean matchCase;

  /**
   * Gets the value of the expression property.
   *
   * <p>This accessor method returns a reference to the live list, not a snapshot. Therefore any
   * modification you make to the returned list will be present inside the JAXB object. This is why
   * there is not a <CODE>set</CODE> method for the expression property.
   *
   * <p>For example, to add a new item, do as follows:
   *
   * <pre>
   *    getExpression().add(newItem);
   * </pre>
   *
   * <p>Objects of the following type(s) are allowed in the list {@link JAXBElement }{@code <}{@link
   * String }{@code >} {@link JAXBElement }{@code <}{@link Object }{@code >} {@link JAXBElement
   * }{@code <}{@link FunctionType }{@code >} {@link JAXBElement }{@code <}{@link LiteralType
   * }{@code >}
   */
  public List<JAXBElement<?>> getExpression() {
    if (expression == null) {
      expression = new ArrayList<JAXBElement<?>>();
    }
    return this.expression;
  }

  public boolean isSetExpression() {
    return ((this.expression != null) && (!this.expression.isEmpty()));
  }

  public void unsetExpression() {
    this.expression = null;
  }

  /**
   * Gets the value of the wildCard property.
   *
   * @return possible object is {@link String }
   */
  public String getWildCard() {
    return wildCard;
  }

  /**
   * Sets the value of the wildCard property.
   *
   * @param value allowed object is {@link String }
   */
  public void setWildCard(String value) {
    this.wildCard = value;
  }

  public boolean isSetWildCard() {
    return (this.wildCard != null);
  }

  /**
   * Gets the value of the singleChar property.
   *
   * @return possible object is {@link String }
   */
  public String getSingleChar() {
    return singleChar;
  }

  /**
   * Sets the value of the singleChar property.
   *
   * @param value allowed object is {@link String }
   */
  public void setSingleChar(String value) {
    this.singleChar = value;
  }

  public boolean isSetSingleChar() {
    return (this.singleChar != null);
  }

  /**
   * Gets the value of the matchCase property.
   *
   * @return possible object is {@link Boolean}
   */
  public Boolean getMatchCase() {
    return matchCase;
  }

  /**
   * Sets the value of the matchCase property.
   *
   * @param value allowed object is {@link Boolean}
   */
  public void setMatchCase(Boolean value) {
    matchCase = value;
  }

  public boolean isSetMatchCase() {
    return this.matchCase != null;
  }

  /**
   * Gets the value of the escapeChar property.
   *
   * @return possible object is {@link String }
   */
  public String getEscapeChar() {
    return escapeChar;
  }

  /**
   * Sets the value of the escapeChar property.
   *
   * @param value allowed object is {@link String }
   */
  public void setEscapeChar(String value) {
    this.escapeChar = value;
  }

  public boolean isSetEscapeChar() {
    return (this.escapeChar != null);
  }

  public String toString() {
    final ToStringStrategy2 strategy = JAXBToStringStrategy.INSTANCE;
    final StringBuilder buffer = new StringBuilder();
    append(null, buffer, strategy);
    return buffer.toString();
  }

  public StringBuilder append(
      ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
    strategy.appendStart(locator, this, buffer);
    appendFields(locator, buffer, strategy);
    strategy.appendEnd(locator, this, buffer);
    return buffer;
  }

  public StringBuilder appendFields(
      ObjectLocator locator, StringBuilder buffer, ToStringStrategy2 strategy) {
    super.appendFields(locator, buffer, strategy);
    {
      List<JAXBElement<?>> theExpression;
      theExpression = (this.isSetExpression() ? this.getExpression() : null);
      strategy.appendField(
          locator, this, "expression", buffer, theExpression, this.isSetExpression());
    }
    {
      String theWildCard;
      theWildCard = this.getWildCard();
      strategy.appendField(locator, this, "wildCard", buffer, theWildCard, this.isSetWildCard());
    }
    {
      String theSingleChar;
      theSingleChar = this.getSingleChar();
      strategy.appendField(
          locator, this, "singleChar", buffer, theSingleChar, this.isSetSingleChar());
    }
    {
      String theEscapeChar;
      theEscapeChar = this.getEscapeChar();
      strategy.appendField(
          locator, this, "escapeChar", buffer, theEscapeChar, this.isSetEscapeChar());
    }
    {
      Boolean theMatchCase;
      theMatchCase = this.getMatchCase();
      strategy.appendField(locator, this, "matchCase", buffer, theMatchCase, this.isSetMatchCase());
    }
    return buffer;
  }

  public boolean equals(
      ObjectLocator thisLocator,
      ObjectLocator thatLocator,
      Object object,
      EqualsStrategy2 strategy) {
    if ((object == null) || (this.getClass() != object.getClass())) {
      return false;
    }
    if (this == object) {
      return true;
    }
    if (!super.equals(thisLocator, thatLocator, object, strategy)) {
      return false;
    }
    final PropertyIsLikeType that = ((PropertyIsLikeType) object);
    {
      List<JAXBElement<?>> lhsExpression;
      lhsExpression = (this.isSetExpression() ? this.getExpression() : null);
      List<JAXBElement<?>> rhsExpression;
      rhsExpression = (that.isSetExpression() ? that.getExpression() : null);
      if (!strategy.equals(
          LocatorUtils.property(thisLocator, "expression", lhsExpression),
          LocatorUtils.property(thatLocator, "expression", rhsExpression),
          lhsExpression,
          rhsExpression,
          this.isSetExpression(),
          that.isSetExpression())) {
        return false;
      }
    }
    {
      String lhsWildCard;
      lhsWildCard = this.getWildCard();
      String rhsWildCard;
      rhsWildCard = that.getWildCard();
      if (!strategy.equals(
          LocatorUtils.property(thisLocator, "wildCard", lhsWildCard),
          LocatorUtils.property(thatLocator, "wildCard", rhsWildCard),
          lhsWildCard,
          rhsWildCard,
          this.isSetWildCard(),
          that.isSetWildCard())) {
        return false;
      }
    }
    {
      String lhsSingleChar;
      lhsSingleChar = this.getSingleChar();
      String rhsSingleChar;
      rhsSingleChar = that.getSingleChar();
      if (!strategy.equals(
          LocatorUtils.property(thisLocator, "singleChar", lhsSingleChar),
          LocatorUtils.property(thatLocator, "singleChar", rhsSingleChar),
          lhsSingleChar,
          rhsSingleChar,
          this.isSetSingleChar(),
          that.isSetSingleChar())) {
        return false;
      }
    }
    {
      String lhsEscapeChar;
      lhsEscapeChar = this.getEscapeChar();
      String rhsEscapeChar;
      rhsEscapeChar = that.getEscapeChar();
      if (!strategy.equals(
          LocatorUtils.property(thisLocator, "escapeChar", lhsEscapeChar),
          LocatorUtils.property(thatLocator, "escapeChar", rhsEscapeChar),
          lhsEscapeChar,
          rhsEscapeChar,
          this.isSetEscapeChar(),
          that.isSetEscapeChar())) {
        return false;
      }
    }
    {
      Boolean lhsMatchCase = this.getMatchCase();
      Boolean rhsMatchCase = that.getMatchCase();
      if (!strategy.equals(
          LocatorUtils.property(thisLocator, "matchCase", lhsMatchCase),
          LocatorUtils.property(thatLocator, "matchCase", rhsMatchCase),
          lhsMatchCase,
          rhsMatchCase,
          this.isSetMatchCase(),
          that.isSetMatchCase())) {
        return false;
      }
    }
    return true;
  }

  public boolean equals(Object object) {
    final EqualsStrategy2 strategy = JAXBEqualsStrategy.INSTANCE;
    return equals(null, null, object, strategy);
  }

  public int hashCode(ObjectLocator locator, HashCodeStrategy2 strategy) {
    int currentHashCode = super.hashCode(locator, strategy);
    {
      List<JAXBElement<?>> theExpression;
      theExpression = (this.isSetExpression() ? this.getExpression() : null);
      currentHashCode =
          strategy.hashCode(
              LocatorUtils.property(locator, "expression", theExpression),
              currentHashCode,
              theExpression,
              this.isSetExpression());
    }
    {
      String theWildCard;
      theWildCard = this.getWildCard();
      currentHashCode =
          strategy.hashCode(
              LocatorUtils.property(locator, "wildCard", theWildCard),
              currentHashCode,
              theWildCard,
              this.isSetWildCard());
    }
    {
      String theSingleChar;
      theSingleChar = this.getSingleChar();
      currentHashCode =
          strategy.hashCode(
              LocatorUtils.property(locator, "singleChar", theSingleChar),
              currentHashCode,
              theSingleChar,
              this.isSetSingleChar());
    }
    {
      String theEscapeChar;
      theEscapeChar = this.getEscapeChar();
      currentHashCode =
          strategy.hashCode(
              LocatorUtils.property(locator, "escapeChar", theEscapeChar),
              currentHashCode,
              theEscapeChar,
              this.isSetEscapeChar());
    }
    {
      Boolean theMatchCase;
      theMatchCase = this.getMatchCase();
      currentHashCode =
          strategy.hashCode(
              LocatorUtils.property(locator, "matchCase", theMatchCase),
              currentHashCode,
              theMatchCase,
              this.isSetMatchCase());
    }
    return currentHashCode;
  }

  public int hashCode() {
    final HashCodeStrategy2 strategy = JAXBHashCodeStrategy.INSTANCE;
    return this.hashCode(null, strategy);
  }

  public Object clone() {
    return copyTo(createNewInstance());
  }

  public Object copyTo(Object target) {
    final CopyStrategy2 strategy = JAXBCopyStrategy.INSTANCE;
    return copyTo(null, target, strategy);
  }

  public Object copyTo(ObjectLocator locator, Object target, CopyStrategy2 strategy) {
    final Object draftCopy = ((target == null) ? createNewInstance() : target);
    super.copyTo(locator, draftCopy, strategy);
    if (draftCopy instanceof PropertyIsLikeType) {
      final PropertyIsLikeType copy = ((PropertyIsLikeType) draftCopy);
      {
        Boolean expressionShouldBeCopiedAndSet =
            strategy.shouldBeCopiedAndSet(locator, this.isSetExpression());
        if (expressionShouldBeCopiedAndSet == Boolean.TRUE) {
          List<JAXBElement<?>> sourceExpression;
          sourceExpression = (this.isSetExpression() ? this.getExpression() : null);
          @SuppressWarnings("unchecked")
          List<JAXBElement<?>> copyExpression =
              ((List<JAXBElement<?>>)
                  strategy.copy(
                      LocatorUtils.property(locator, "expression", sourceExpression),
                      sourceExpression,
                      this.isSetExpression()));
          copy.unsetExpression();
          if (copyExpression != null) {
            List<JAXBElement<?>> uniqueExpressionl = copy.getExpression();
            uniqueExpressionl.addAll(copyExpression);
          }
        } else {
          if (expressionShouldBeCopiedAndSet == Boolean.FALSE) {
            copy.unsetExpression();
          }
        }
      }
      {
        Boolean wildCardShouldBeCopiedAndSet =
            strategy.shouldBeCopiedAndSet(locator, this.isSetWildCard());
        if (wildCardShouldBeCopiedAndSet == Boolean.TRUE) {
          String sourceWildCard;
          sourceWildCard = this.getWildCard();
          String copyWildCard =
              ((String)
                  strategy.copy(
                      LocatorUtils.property(locator, "wildCard", sourceWildCard),
                      sourceWildCard,
                      this.isSetWildCard()));
          copy.setWildCard(copyWildCard);
        } else {
          if (wildCardShouldBeCopiedAndSet == Boolean.FALSE) {
            copy.wildCard = null;
          }
        }
      }
      {
        Boolean singleCharShouldBeCopiedAndSet =
            strategy.shouldBeCopiedAndSet(locator, this.isSetSingleChar());
        if (singleCharShouldBeCopiedAndSet == Boolean.TRUE) {
          String sourceSingleChar;
          sourceSingleChar = this.getSingleChar();
          String copySingleChar =
              ((String)
                  strategy.copy(
                      LocatorUtils.property(locator, "singleChar", sourceSingleChar),
                      sourceSingleChar,
                      this.isSetSingleChar()));
          copy.setSingleChar(copySingleChar);
        } else {
          if (singleCharShouldBeCopiedAndSet == Boolean.FALSE) {
            copy.singleChar = null;
          }
        }
      }
      {
        Boolean escapeCharShouldBeCopiedAndSet =
            strategy.shouldBeCopiedAndSet(locator, this.isSetEscapeChar());
        if (escapeCharShouldBeCopiedAndSet == Boolean.TRUE) {
          String sourceEscapeChar;
          sourceEscapeChar = this.getEscapeChar();
          String copyEscapeChar =
              ((String)
                  strategy.copy(
                      LocatorUtils.property(locator, "escapeChar", sourceEscapeChar),
                      sourceEscapeChar,
                      this.isSetEscapeChar()));
          copy.setEscapeChar(copyEscapeChar);
        } else {
          if (escapeCharShouldBeCopiedAndSet == Boolean.FALSE) {
            copy.escapeChar = null;
          }
        }
      }
      {
        Boolean matchCaseShouldBeCopiedAndSet =
            strategy.shouldBeCopiedAndSet(locator, this.isSetMatchCase());
        if (matchCaseShouldBeCopiedAndSet == Boolean.TRUE) {
          Boolean sourceMatchCase;
          sourceMatchCase = this.getMatchCase();
          Boolean copyMatchCase =
              ((Boolean)
                  strategy.copy(
                      LocatorUtils.property(locator, "matchCase", sourceMatchCase),
                      sourceMatchCase,
                      this.isSetMatchCase()));
          copy.setMatchCase(copyMatchCase);
        } else {
          if (matchCaseShouldBeCopiedAndSet == Boolean.FALSE) {
            copy.matchCase = null;
          }
        }
      }
    }
    return draftCopy;
  }

  public Object createNewInstance() {
    return new PropertyIsLikeType();
  }

  public void mergeFrom(Object left, Object right) {
    final MergeStrategy2 strategy = JAXBMergeStrategy.INSTANCE;
    mergeFrom(null, null, left, right, strategy);
  }

  public void mergeFrom(
      ObjectLocator leftLocator,
      ObjectLocator rightLocator,
      Object left,
      Object right,
      MergeStrategy2 strategy) {
    super.mergeFrom(leftLocator, rightLocator, left, right, strategy);
    if (right instanceof PropertyIsLikeType) {
      final PropertyIsLikeType target = this;
      final PropertyIsLikeType leftObject = ((PropertyIsLikeType) left);
      final PropertyIsLikeType rightObject = ((PropertyIsLikeType) right);
      {
        Boolean expressionShouldBeMergedAndSet =
            strategy.shouldBeMergedAndSet(
                leftLocator,
                rightLocator,
                leftObject.isSetExpression(),
                rightObject.isSetExpression());
        if (expressionShouldBeMergedAndSet == Boolean.TRUE) {
          List<JAXBElement<?>> lhsExpression;
          lhsExpression = (leftObject.isSetExpression() ? leftObject.getExpression() : null);
          List<JAXBElement<?>> rhsExpression;
          rhsExpression = (rightObject.isSetExpression() ? rightObject.getExpression() : null);
          List<JAXBElement<?>> mergedExpression =
              ((List<JAXBElement<?>>)
                  strategy.merge(
                      LocatorUtils.property(leftLocator, "expression", lhsExpression),
                      LocatorUtils.property(rightLocator, "expression", rhsExpression),
                      lhsExpression,
                      rhsExpression,
                      leftObject.isSetExpression(),
                      rightObject.isSetExpression()));
          target.unsetExpression();
          if (mergedExpression != null) {
            List<JAXBElement<?>> uniqueExpressionl = target.getExpression();
            uniqueExpressionl.addAll(mergedExpression);
          }
        } else {
          if (expressionShouldBeMergedAndSet == Boolean.FALSE) {
            target.unsetExpression();
          }
        }
      }
      {
        Boolean wildCardShouldBeMergedAndSet =
            strategy.shouldBeMergedAndSet(
                leftLocator, rightLocator, leftObject.isSetWildCard(), rightObject.isSetWildCard());
        if (wildCardShouldBeMergedAndSet == Boolean.TRUE) {
          String lhsWildCard;
          lhsWildCard = leftObject.getWildCard();
          String rhsWildCard;
          rhsWildCard = rightObject.getWildCard();
          String mergedWildCard =
              ((String)
                  strategy.merge(
                      LocatorUtils.property(leftLocator, "wildCard", lhsWildCard),
                      LocatorUtils.property(rightLocator, "wildCard", rhsWildCard),
                      lhsWildCard,
                      rhsWildCard,
                      leftObject.isSetWildCard(),
                      rightObject.isSetWildCard()));
          target.setWildCard(mergedWildCard);
        } else {
          if (wildCardShouldBeMergedAndSet == Boolean.FALSE) {
            target.wildCard = null;
          }
        }
      }
      {
        Boolean singleCharShouldBeMergedAndSet =
            strategy.shouldBeMergedAndSet(
                leftLocator,
                rightLocator,
                leftObject.isSetSingleChar(),
                rightObject.isSetSingleChar());
        if (singleCharShouldBeMergedAndSet == Boolean.TRUE) {
          String lhsSingleChar;
          lhsSingleChar = leftObject.getSingleChar();
          String rhsSingleChar;
          rhsSingleChar = rightObject.getSingleChar();
          String mergedSingleChar =
              ((String)
                  strategy.merge(
                      LocatorUtils.property(leftLocator, "singleChar", lhsSingleChar),
                      LocatorUtils.property(rightLocator, "singleChar", rhsSingleChar),
                      lhsSingleChar,
                      rhsSingleChar,
                      leftObject.isSetSingleChar(),
                      rightObject.isSetSingleChar()));
          target.setSingleChar(mergedSingleChar);
        } else {
          if (singleCharShouldBeMergedAndSet == Boolean.FALSE) {
            target.singleChar = null;
          }
        }
      }
      {
        Boolean escapeCharShouldBeMergedAndSet =
            strategy.shouldBeMergedAndSet(
                leftLocator,
                rightLocator,
                leftObject.isSetEscapeChar(),
                rightObject.isSetEscapeChar());
        if (escapeCharShouldBeMergedAndSet == Boolean.TRUE) {
          String lhsEscapeChar;
          lhsEscapeChar = leftObject.getEscapeChar();
          String rhsEscapeChar;
          rhsEscapeChar = rightObject.getEscapeChar();
          String mergedEscapeChar =
              ((String)
                  strategy.merge(
                      LocatorUtils.property(leftLocator, "escapeChar", lhsEscapeChar),
                      LocatorUtils.property(rightLocator, "escapeChar", rhsEscapeChar),
                      lhsEscapeChar,
                      rhsEscapeChar,
                      leftObject.isSetEscapeChar(),
                      rightObject.isSetEscapeChar()));
          target.setEscapeChar(mergedEscapeChar);
        } else {
          if (escapeCharShouldBeMergedAndSet == Boolean.FALSE) {
            target.escapeChar = null;
          }
        }
      }
      {
        Boolean matchCaseShouldBeMergedAndSet =
            strategy.shouldBeMergedAndSet(
                leftLocator,
                rightLocator,
                leftObject.isSetMatchCase(),
                rightObject.isSetMatchCase());
        if (matchCaseShouldBeMergedAndSet == Boolean.TRUE) {
          Boolean lhsMatchCase;
          lhsMatchCase = leftObject.getMatchCase();
          Boolean rhsMatchCase;
          rhsMatchCase = rightObject.getMatchCase();
          Boolean mergedMatchCase =
              ((Boolean)
                  strategy.merge(
                      LocatorUtils.property(leftLocator, "matchCase", lhsMatchCase),
                      LocatorUtils.property(rightLocator, "matchCase", rhsMatchCase),
                      lhsMatchCase,
                      rhsMatchCase,
                      leftObject.isSetMatchCase(),
                      rightObject.isSetMatchCase()));
          target.setMatchCase(mergedMatchCase);
        } else {
          if (matchCaseShouldBeMergedAndSet == Boolean.FALSE) {
            target.matchCase = null;
          }
        }
      }
    }
  }

  public void setExpression(List<JAXBElement<?>> value) {
    this.expression = null;
    if (value != null) {
      List<JAXBElement<?>> draftl = this.getExpression();
      draftl.addAll(value);
    }
  }

  public PropertyIsLikeType withExpression(JAXBElement<?>... values) {
    if (values != null) {
      for (JAXBElement<?> value : values) {
        getExpression().add(value);
      }
    }
    return this;
  }

  public PropertyIsLikeType withExpression(Collection<JAXBElement<?>> values) {
    if (values != null) {
      getExpression().addAll(values);
    }
    return this;
  }

  public PropertyIsLikeType withWildCard(String value) {
    setWildCard(value);
    return this;
  }

  public PropertyIsLikeType withSingleChar(String value) {
    setSingleChar(value);
    return this;
  }

  public PropertyIsLikeType withEscapeChar(String value) {
    setEscapeChar(value);
    return this;
  }

  public PropertyIsLikeType withExpression(List<JAXBElement<?>> value) {
    setExpression(value);
    return this;
  }

  public PropertyIsLikeType withMatchCase(Boolean value) {
    setMatchCase(value);
    return this;
  }
}
