////
NOTE TO REVIEWERS:
The Content in this file is being migrated to other files. Ignore changes here, as the content has been moved to a new home. A nice farm; upstate.
////
=== Design

The Catalog is composed of several components and an API that connects them together.
The Catalog API is central to ${branding}'s architectural qualities of extensibility and flexibility. 
The Catalog API consists of Java interfaces that define Catalog functionality and specify interactions between components. 
These interfaces provide the ability for components to interact without a dependency on a particular underlying implementation, thus allowing the possibility of alternate implementations that can maintain interoperability and share developed components.
As such, new capabilities can be developed independently, in a modular fashion, using the Catalog API interfaces and reused by other ${branding} installations.

==== Ensuring Compatibility

The Catalog API will evolve, but great care is taken to retain backwards compatibility with developed components.
Compatibility is reflected in version numbers.

This section supports integration of the Catalog Application.



// end move
=== ${branding} Data Migration

Data migration is the process of moving metadata from one catalog provider to another.
It is also the process of translating metadata from one format to another. 
Data migration is necessary when a user decides to use metadata from one catalog provider in another catalog provider.
The following steps define the procedure for transferring metadata from one catalog provider to another catalog provider.
In addition, the procedures define the steps for converting metadata to different data formats.

==== Set Up

Set up ${branding} as instructed in Starting ${branding} section.

==== Move Metadata from One Catalog Provider to Another

===== Export Metadata Out of Catalog Provider

. Configure a desired catalog provider.
. From the command line of ${branding} console, use the command to export all metadata from the catalog provider into serialized data files dump. The following example shows a command for running on Linux and a command for running on Windows.

.${branding-lowercase}${at-symbol}local
----
dump "/myDirectory/exportFolder"
or
dump "C:/myDirectory/exportFolder"
----

===== Ingest Exported Metadata into Catalog Provider

. Configure a different catalog provider.

. From the command line of ${branding} console, use the *ingest* command to import exported metadata from serialized data files into catalog provider. The following example shows a command for running on Linux and a command for running on Windows.

.${branding-lowercase}${at-symbol}local
----
ingest -p "/myDirectory/exportFolder"
or
ingest -p "C:/myDirectory/exportFolder"
----

===== Translate Metadata from One Format to Another

Metadata can be converted from one data format to another format. 
Only the data format changes, but the content of the metadata does not, as long as `option -p` is used with the ingest command.
The process for converting metadata is performed by ingesting a data file into a catalog provider in one format and dumping it out into a file in another format. 


=== Integrating Catalog Framework

[ditaa, catalog_framework_architecture, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |c369               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Catalog Framework

The Catalog Framework wires all Catalog components together.
It is responsible for routing Catalog requests and responses to the appropriate target.
Endpoints send Catalog requests to the Catalog Framework.
The Catalog Framework then invokes Catalog Plugins, Transformers, and Resource Components as needed before sending requests to the intended destination, such as one or more Sources. 

===== Example Catalog Frameworks

The Catalog comes with the following Catalog Frameworks out of the box:

* Catalog Framework
* Catalog Fanout Framework

===== Catalog Framework Sequence Diagrams

Because the Catalog Framework plays a central role to Catalog functionality, it interacts with many different Catalog components.
To illustrate these relationships, high level sequence diagrams with notional class names are provided below.
These examples are for illustrative purposes only and do not necessarily represent every step in each procedure.

===== Ingest

.Ingest Request
[ditaa,ingest_request,png]
....
+------+      +--------------------------------------------------------------------------------------------------------------------+
| cDEF |      |/-----------------------\/--------------------------\/---------------\/----------------\/--------------------------\|/--------------------\
|Client|      ||c369  <<Endpoint>>     ||c369<<CatalogFramework>>  ||c369           ||c369            ||c369<<CatalogProvider>>   |||c369<<External>>    |
+------+      ||Ingest Service Endpoint||Standard Catalog Framework||PreIngestPlugin||PostIngestPlugin||  Solr Catalog Provider   ||| Solr Search Server |
  :           |\-----------------------/\--------------------------/\---------------/\----------------/\--------------------------/|\--------------------/
  |Web Service|Ingest Request :                       :                       :               :                     :              |           :
  |-----------|-------------->|                       |                       |               |                     |              |           |
  |           |               |create(CreateRequest)  |                       |               |                     |              |           |
  |           |               |---------------------->|process(CreateRequest) |               |                     |              |           |
  |           |               |                       |---------------------->|               |                     |              |           |
  |           |               |                       |   CreateRequest       |               |                     |              |           |
  |           |               |                       |<----------------------|               |                     |              |           |
  |           |    cDEF       |                       |create(CreateRequest)  |               |                     |              |           |
  |           |               |                       |------------------------------------------------------------>|create        |           |
  |           |               |                       |                       :               :                     |--------------|---------->|
  |           |               |                       |                       |               |                     |              |          response
  |           |               |                       |                       |               |       CreateResponse|<-------------|-----------|
  |           |               |                       |<------------------------------------------------------------|              |           |
  |           |               |                       |process(CreateResponse):               :                     |              |           |
  |           |               |                       |-----------------------|-------------->|                     |              |           |
  |           |               |                       |                       | CreateResponse|                     |              |           |
  |           |               |         CreateResponse|<--------------------------------------|                     |              |           |
  |Web Service|Ingest Response|<----------------------|                       :               |                     |              |           |
  |<----------|---------------|                       |                       |               |                     |              |           |
  |           |               |                       |                       |               |                     |              |           |
  |           +--------------------------------------------------------------------------------------------------------------------+           |
  |                                                                                                                                            |
....

The Ingest Service Endpoint, the Catalog Framework, and the Catalog Provider are key components of the Reference Implementation.
The Endpoint bundle implements a Web service that allows clients to create, update, and delete metacards.
The Endpoint calls the `CatalogFramework` to execute the operations of its specification.
The `CatalogFramework` routes the request through optional `PreIngest` and `PostIngest` Catalog Plugins, which may modify the ingest request/response before/after the Catalog Provider executes the ingest request and provides the response. 
Note that a `CatalogProvider` must be present for any ingest requests to be successfully processed, otherwise a fault is returned.

This process is similar for updating catalog entries, with update requests calling the `update(UpdateRequest)` methods on the Endpoint, `CatalogFramework`, and Catalog Provider.
Similarly, for deletion of catalog entries, the delete requests call the `delete(DeleteRequest)` methods on the `Endpoint`, `CatalogFramework`, and `CatalogProvider`.

===== Error Handling

Any ingest attempts that fail inside the Catalog Framework (whether the failure comes from the Catalog Framework itself, pre-ingest plugin failures, or issues with the Catalog Provider) will be logged to a separate log file for ease of error handling.
The file is located at `data/log/ingest_error.log` and will log the Metacards that fail, their ID and Title name, and the stack trace associated with their failure.
By default, successful ingest attempts are not logged.
However, that functionality can be achieved by setting the log level of the `ingestLogger` to DEBUG (note that enabling DEBUG can cause a non-trivial performance hit).

[TIP]
====
To turn off logging failed ingest attempts into a separate file, execute the following
via the command line console
----
log:set
 ERROR ingestLogger
----
====

===== Query

.Ingest Request
[ditaa,query_request,png]
....
+------+      +--------------------------------------------------------------------------------------------------------------------+
|      |      |/-----------------------\/--------------------------\/---------------\/----------------\/--------------------------\|/--------------------\
|Client|      ||c369  <<Endpoint>>     ||c369<<CatalogFramework>>  ||c369           ||c369            ||c369<<CatalogProvider>>   |||c369<<External>>    |
+------+      || Query Service Endpoint||Standard Catalog Framework||PreQueryPlugin ||PostQueryPlugin ||  Solr Catalog Provider   ||| Solr Search Server |
  :           |\-----------------------/\--------------------------/\---------------/\----------------/\--------------------------/|\--------------------/
  |Web Service|Query Request  :                       :                       :               :                     :              |         :
  |-----------|-------------->|                       |                       |               |                     |              |         |
  |           |cDEF           |query(QueryRequest)    |                       |               |                     |              |         |
  |           |               |---------------------->|process(QueryRequest)  |               |                     |              |         |
  |           |               |                       |---------------------->|               |                     |              |         |
  |           |               |                       |    QueryRequest       |               |                     |              |         |
  |           |               |                       |<----------------------|               |                     |              |         |
  |           |               |                       |create(QueryRequest)   |               |                     |              |         |
  |           |               |                       |------------------------------------------------------------>|query         |         |
  |           |               |                       |                       :               |                     |--------------|-------->|
  |           |               |                       |                       |               |                     |                     response     |
  |           |               |                       |                       |               |        QueryResponse|<-------------|---------|
  |           |               |                       |<------------------------------------------------------------|              |         |
  |           |               |                       | process(QueryResponse)|               |                     |              |         |
  |           |               |                       |-----------------------:-------------->|                     |              |         |
  |           |               |                       |                       | QueryResponse |                     |              |         |
  |           |               |          QueryResponse|<--------------------------------------|                     |              |         |
  | Web Service Query Response|<----------------------|                       :               |                     |              |         |
  |<----------|---------------|                       |                       |               |                     |              |         |
  |           |               |                       |                       |               |                     |              |         |
  |           +--------------------------------------------------------------------------------------------------------------------+         |
....

The Query Service Endpoint, the Catalog Framework, and the `CatalogProvider` are key components for processing a query request as well.
The Endpoint bundle contains a Web service that exposes the interface to query for `Metacards`.
The Endpoint calls the `CatalogFramework` to execute the operations of its specification.
The `CatalogFramework` relies on the `CatalogProvider` to execute the actual query.
Optional PreQuery and PostQuery Catalog Plugins may be invoked by the `CatalogFramework` to modify the query request/response prior to the Catalog Provider processing the query request and providing the query response.
If a `CatalogProvider` is not configured and no other remote Sources are configured, a fault will be returned.
It is possible to have only remote Sources configured and no local `CatalogProvider` configured and be able to execute queries to specific remote Sources by specifying the site name(s) in the query request.

==== Product Retrieval

The Query Service Endpoint, the Catalog Framework, and the `CatalogProvider` are key components for processing a retrieve product request.
The Endpoint bundle contains a Web service that exposes the interface to retrieve products, also referred to as Resources.
The Endpoint calls the `CatalogFramework` to execute the operations of its specification.
The `CatalogFramework` relies on the Sources to execute the actual product retrieval.
Optional `PreResource` and `PostResource` Catalog Plugins may be invoked by the `CatalogFramework` to modify the product retrieval request/response prior to the Catalog Provider processing the request and providing the response. 
It is possible to retrieve products from specific remote Sources by specifying the site name(s) in the request.

===== Product Caching

The Catalog Framework optionally provides caching of products, so future requests to retrieve the same product will be serviced much quicker.
If caching is enabled, each time a retrieve product request is received, the Catalog Framework will look in its cache (default location `<INSTALL_DIR>/data/product-cache`) to see if the product has been cached locally.
If it has, the product is retrieved from the local site and returned to the client, providing a much quicker turnaround because remote product retrieval and network traffic was avoided.
If the requested product is not in the cache, the product is retrieved from the Source (local or remote) and cached locally while returning the product to the client.
The caching to a local file of the product and the streaming of the product to the client are done simultaneously so that the client does not have to wait for the caching to complete before receiving the product.
If errors are detected during the caching, caching of the product will be abandoned, and the product will be returned to the client. 

The Catalog Framework attempts to detect any network problems during the product retrieval, e.g., long pauses where no bytes are read implying a network connection was dropped.
(The amount of time defined as a "long pause" is configurable, with the default value being five seconds.)
The Catalog Framework will attempt to retrieve the product up to a configurable number of times (default = three), waiting for a configurable amount of time (default = 10 seconds) between each attempt, trying to successfully retrieve the product.
If the Catalog Framework is unable to retrieve the product, an error message is returned to the client.

If the admin has enabled the *Always Cache When Canceled* option, caching of the product will occur even if the client cancels the product retrieval so that future requests will be serviced quickly.
Otherwise, caching is canceled if the user cancels the product download.

===== Product Download Status

As part of the caching of products, the Catalog Framework also posts events to the OSGi notification framework. Information includes when the product download started, whether the download is retrying or failed (after the number of retrieval attempts configured for product caching has been exhausted), and when the download completes. These events are retrieved by the Search UI and presented to the user who initiated the download.

=== ${branding} Schematron

Custom schematron rulesets can be used to validate metacard metadata.
Multiple services can be created, and each service can have multiple rule sets associated with it.
Namespaces are used to distinguish services.
The root schematron files may be placed anywhere on the file system as long as they are configured with an absolute path.
Any root schematron files with a relative path are assumed to be relative to `${ddf-branding}_HOME/schematron`.

[TIP]
====
Schematron files may reference other schematron files using an include statement with a relative path.
However, when using the document function within a schematron ruleset to reference another file, the path must be absolute or relative to the ${ddf-branding} installation home directory.
====

==== Configuring

Schematron validation services are configured with a namespace and one or more schematron rule sets.
Additionally, warnings may be suppressed so that only errors are reported.
To create a new service, ensure that catalog-schematron-plugin is started and then click Schematron Validation Services.

=== Adding New Attribute Types, Metacard Types, Validators, and More Using JSON Files

[WARNING]
====
This section concerns capabilities that are considered experimental. The features described in this section may change or be removed in a future version of the application.
====

==== Definition File Format

A definition file follows the JSON format as specified in ECMA-404. All definition files must be valid JSON in order to be parsed.

The following may be defined in a JSON definition file:

- Attribute Types
- Metacard Types
- Global Attribute Validators
- Default Attribute Values
- Attribute Injections

Within a definition file you may define as many of the types as you wish. This means that types can be defined across multiple files for grouping or clarity.

==== Deploying
The file must have a `.json` extension in order to be picked up by the deployer. Once the definition file is ready to be deployed, put the definition file `<filename>.json` into the `etc/definitions` folder.

Definition files can be updated while they are in the `etc/definitions` folder. Once the file is updated (e.g., by editing and saving it), the changes will be applied to ${branding}.

If a definition file is removed from the `etc/definitions` folder, the changes that were applied by that file will be undone.

* * *
==== Attribute Type Definition

To define Attribute Types, your definition file must have an `attributeTypes` key in the root object.

[source,json]
----
{
    "attributeTypes": {...}
}
----

The value of `attributeTypes` must be a map where each key is the attribute type's name and each value is a map that includes the data type and whether the attribute type is stored, indexed, tokenized, or multi-valued.

[source,json]
----
{
    "attributeTypes": {
        "temperature": {
            "type": "DOUBLE_TYPE",
            "stored": true,
            "indexed": true,
            "tokenized": false,
            "multivalued": false
        }
    }
}
----

The attributes `stored`, `indexed`, `tokenized`, and `multivalued` must be included and must have a boolean value. The `type` attribute must also be included and must have one of the following values:

 - `DATE_TYPE`
 - `STRING_TYPE`
 - `XML_TYPE`
 - `LONG_TYPE`
 - `BINARY_TYPE`
 - `GEO_TYPE`
 - `BOOLEAN_TYPE`
 - `DOUBLE_TYPE`
 - `FLOAT_TYPE`
 - `INTEGER_TYPE`
 - `OBJECT_TYPE`
 - `SHORT_TYPE`

An example with multiple attributes defined:

[source,json]
----
{
    "attributeTypes": {
        "resolution": {
            "type": "STRING_TYPE",
            "stored": true,
            "indexed": true,
            "tokenized": false,
            "multivalued": false
        },
        "target-areas": {
            "type": "GEO_TYPE",
            "stored": true,
            "indexed": true,
            "tokenized": false,
            "multivalued": true
        }
    }
}
----

* * *

==== Metacard Type Definition

To define Metacard Types, your definition file must have a `metacardTypes` key in the root object.

[source,javascript]
----
{
    "metacardTypes": [...]
}
----

The value of `metacardTypes` must be an array of Metacard Type Objects, which are composed of the `type` and `attributes` keys.

[source,json]
----
{
    "metacardTypes": [
        {
            "type": "my-metacard-type",
            "attributes": {...}
        }
    ]
}
----

The value of the `type` key is the name of the metacard type being defined.

The value of the `attributes` key is a map where each key is the name of an attribute type to include in this metacard type and each value is a map with a single key named `required` and a boolean value. Required attributes are used for metacard validation - metacards that lack required attributes will be flagged with validation errors.

[source,json]
----
{
    "metacardTypes": [
        {
            "type": "my-metacard-type",
            "attributes": {
                "resolution": {
                    "required": true
                },
                "target-areas": {
                    "required": false
                },
                "expiration": {
                    "required": false
                },
                "point-of-contact": {
                    "required": true
                }
            }
        }
    ]
}
----

[NOTE]
====
The ${ddf-branding} basic metacard attribute types are added to custom metacard types by default. If you wish to make any of them required by your metacard type, just include them in your `attributes` map and set `required` to `true`, as shown in the above example with `point-of-contact`.
====

You can define multiple metacard types in a single file:
[source,json]
----
{
    "metacardTypes": [
        {
            "type": "my-metacard-type",
            "attributes": {
                "resolution": {
                    "required": true
                },
                "target-areas": {
                    "required": false
                }
            }
        },
        {
            "type": "another-metacard-type",
            "attributes": {
                "effective": {
                    "required": true
                },
                "resolution": {
                    "required": false
                }
            }
        }
    ]
}
----

==== Validator Definition

To define Validators, your definition file must have a `validators` key in the root object.

[source,json]
----
{
    "validators": {...}
}
----

The value of `validators` is a map of the attribute name to a list of validators for that attribute.

[source,json]
----
{
    "validators": {
        "point-of-contact": [...]
    }
}
----

Each object in the list of validators is the validator name and list of arguments for that validator.

[source,json]
----
{
    "validators": {
        "point-of-contact": [
            {
                "validator": "pattern",
                "arguments": [".*regex.+\\s"]
            }
        ]
    }
}
----

[WARNING]
====
The value of the `arguments` key must always be an array of strings, even for numeric arguments, e.g. `["1", "10"]`
====

The `validator` key must have a value of one of the following:

 - `size` (validates the size of Strings, Arrays, Collections, and Maps)
 * `arguments`: (2) [integer: lower bound (inclusive), integer: upper bound (inclusive)]
 - `pattern`
 * `arguments`: (1) [regular expression]
 - `pastdate`
 * `arguments`: (0) [NO ARGUMENTS]
 - `futuredate`
 * `arguments`: (0) [NO ARGUMENTS]
 - `range`
 ** (2) [number (decimal or integer): inclusive lower bound, number (decimal or integer): inclusive upper bound]
 *** uses a default epsilon of 1E-6 on either side of the range to account for floating point representation inaccuracies
 ** (3) [number (decimal or integer): inclusive lower bound, number (decimal or integer): inclusive upper bound, decimal number: epsilon (the maximum tolerable error on either side of the range)]
 - `enumeration`
 * `arguments`: (unlimited) [list of strings: each argument is one case-sensitive, valid enumeration value]

Examples:
[source, json]
----
{
    "validators": {
        "title": [
            {
                "validator": "size",
                "arguments": ["1", "50"]
            },
            {
                "validator": "pattern",
                "arguments": ["\\D+"]
            }
        ],
        "created": [
            {
                "validator": "pastdate",
                "arguments": []
            }
        ],
        "expiration": [
            {
                "validator": "futuredate",
                "arguments": []
            }
        ],
        "page-count": [
            {
                "validator": "range",
                "arguments": ["1", "500"]
            }
        ],
        "temperature": [
            {
                "validator": "range",
                "arguments": ["12.2", "19.8", "0.01"]
            }
        ],
        "resolution": [
            {
                "validator": "enumeration",
                "arguments": ["1080p", "1080i", "720p"]
            }
        ]
    }
}
----

==== Default Attribute Values

To define default attribute values, your definition file must have a `defaults` key in the root object.

[source,json]
----
{
    "defaults": [...]
}
----

The value of `defaults` is a list of objects where each object contains the keys `attribute`, `value`, and optionally `metacardTypes`.

[source,json]
----
{
    "defaults": [
        {
            "attribute": ...,
            "value": ...,
            "metacardTypes": [...]
        }
    ]
}
----

The value corresponding to the `attribute` key is the name of the attribute to which the default value will be applied. The value corresponding to the `value` key is the default value of the attribute.

[NOTE]
====
The attribute's default value must be of the same type as the attribute, but it has to be written as a string (i.e., enclosed in quotation marks) in the JSON file.

Dates must be UTC datetimes in the ISO 8601 format, i.e., `yyyy-MM-ddTHH:mm:ssZ`
====

The `metacardTypes` key is optional. If it is left out, then the default attribute value will be applied to every metacard that has that attribute. It can be thought of as a 'global' default value. If the `metacardTypes` key is included, then its value must be a list of strings where each string is the name of a metacard type. In this case, the default attribute value will be applied only to metacards that match one of the types given in the list.

[NOTE]
====
In the event that an attribute has a 'global' default value as well as a default value for a specific metacard type, the default value for the specific metacard type will be applied (i.e., the more specific default value wins).
====

Example:
[source,json]
----
{
    "defaults": [
        {
            "attribute": "title",
            "value": "Default Title"
        },
        {
            "attribute": "description",
            "value": "Default video description",
            "metacardTypes": ["video"]
        },
        {
            "attribute": "expiration",
            "value": "2020-05-06T12:00:00Z",
            "metacardTypes": ["video", "nitf"]
        },
        {
            "attribute": "frame-rate",
            "value": "30"
        }
    ]
}
----

==== Attribute Injection Definition

Attribute injections are defined attributes that will be injected into all metacard types or into specific metacard types. This capability allows metacard types to be extended with new attributes.

To define attribute injections, your definition file must have an `inject` key in the root object.

[source,json]
----
{
    "inject": [...]
}
----

The value of `inject` is simply a list of objects where each object contains the key `attribute` and optionally `metacardTypes`.

[source,json]
----
{
    "inject": [
        {
            "attribute": ...,
            "metacardTypes": [...]
        }
    ]
}
----

The value corresponding to the `attribute` key is the name of the attribute to inject.

The `metacardTypes` key is optional. If it is left out, then the attribute will be injected into every metacard type. It can be thought of as a 'global' attribute injection. If the `metacardTypes` key is included, then its value must be a list of strings where each string is the name of a metacard type. In this case, the attribute will be injected only into metacard types that match one of the types given in the list.

Example:
[source,json]
----
{
    "inject": [
        {
            "attribute": "rating"
        },
        {
            "attribute": "cloud-cover",
            "metacardTypes": ["nitf", "video"]
        }
    ]
}
----

[NOTE]
====
Attributes must be registered in the attribute registry (see the `AttributeRegistry` interface) in order to be injected into metacard types. For example, attributes defined in JSON definition files are placed in the registry, so they can be injected.
====
