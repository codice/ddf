////
NOTE TO REVIEWERS:
The Content in this file is being migrated to other files. Ignore changes here, as the content has been moved to a new home. A nice farm; upstate.
////
The ${ddf-catalog} provides a framework for storing, searching, processing, and transforming information.
Clients typically perform query, create, read, update, and delete (QCRUD) operations against the Catalog.  
At the core of the Catalog functionality is the Catalog Framework, which routes all requests and responses through the system, invoking additional processing per the system configuration.

This guide supports developers creating extensions of the existing framework.

=== Whitelist

The following packages have been exported by the ${ddf-catalog} application and are approved for use by third parties:

* `${ddf-branding-lowercase}.camel.component.catalog`
* `${ddf-branding-lowercase}.catalog`
* `${ddf-branding-lowercase}.catalog.cache`
* `${ddf-branding-lowercase}.catalog.data`
* `${ddf-branding-lowercase}.catalog.data.metacardtype`
* `${ddf-branding-lowercase}.catalog.event`
* `${ddf-branding-lowercase}.catalog.federation`
* `${ddf-branding-lowercase}.catalog.federation.impl`
* `${ddf-branding-lowercase}.catalog.filter`
* `${ddf-branding-lowercase}.catalog.filter.delegate`
* `${ddf-branding-lowercase}.catalog.impl.filter`
* `${ddf-branding-lowercase}.catalog.operation`
* `${ddf-branding-lowercase}.catalog.plugin`
* `${ddf-branding-lowercase}.catalog.plugin.groomer`
* `${ddf-branding-lowercase}.catalog.pubsub`
* `${ddf-branding-lowercase}.catalog.pubsub.tracker`
* `${ddf-branding-lowercase}.catalog.resource`
* `${ddf-branding-lowercase}.catalog.resource.data`
* `${ddf-branding-lowercase}.catalog.resource.impl`
* `${ddf-branding-lowercase}.catalog.resourceretriever`
* `${ddf-branding-lowercase}.catalog.service`
* `${ddf-branding-lowercase}.catalog.source`
* `${ddf-branding-lowercase}.catalog.transform`
* `${ddf-branding-lowercase}.catalog.transformer.api`
* `${ddf-branding-lowercase}.catalog.transformer.metacard.geojson`
* `${ddf-branding-lowercase}.catalog.util`
* `${ddf-branding-lowercase}.catalog.validation`
* `${ddf-branding-lowercase}.common`
* `${ddf-branding-lowercase}.geo.formatter`
* `${ddf-branding-lowercase}.util`
* `org.codice.${ddf-branding-lowercase}.endpoints`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest.action`
* `org.codice.${ddf-branding-lowercase}.opensearch.query`
* `org.codice.${ddf-branding-lowercase}.opensearch.query.filter`




=

==== CatalogProvider





==== Plugins



=== Catalog Development Fundamentals

This section introduces the fundamentals of working with the Catalog API the OGC Filter for Queries.

==== Simple Catalog API Implementations

The Catalog API implementations, which are denoted with the suffix of `Impl` on the Java file names, have multiple purposes and uses.

* First, they provide a good starting point for other developers to extend functionality in the framework. For instance, extending the `MetacardImpl` allows developers to focus less on the inner workings of ${branding} and more on the developer's intended purposes and objectives. 

* Second, the Catalog API Implementations display the proper usage of an interface and an interface's intentions. Also, they are good code examples for future implementations. If a developer does not want to extend the simple implementations, the developer can at least have a working code reference to base future development.

==== Use of the Whiteboard Design Pattern

The ${ddf-catalog} makes extensive use of the Whiteboard Design Pattern.
Catalog Components are registered as services in the OSGi Service Registry, and the Catalog Framework or any other clients tracking the OSGi Service Registry are automatically notified by the OSGi Framework of additions and removals of relevant services.

The Whiteboard Design Pattern is a common OSGi technique that is derived from a technical whitepaper provided by the OSGi Alliance in 2004.
It is recommended to use the Whiteboard pattern over the Listener pattern in OSGi because it provides less complexity in code (both on the client and server sides), fewer deadlock possibilities than the Listener pattern, and closely models the intended usage of the OSGi framework.

==== Working with Queries

Clients use `${ddf-branding}.catalog.operation.Query` objects to describe which metacards are needed from Sources. 
Query objects have two major components:

* Filter 
* Query Options

A Source uses the Filter criteria constraints to find the requested set of metacards within its domain of metacards.
The Query Options are used to further restrict the Filter's set of requested metacards.

===== Query Options
[cols="2*", options="header"]
|===
|Option
|Description

|`StartIndex`
|1-based index that states which metacard the Source should return first out of the requested metacards.

|`PageSize`
|Represents the maximum amount of metacards the Source should return.

|`SortBy`
|Determines how the results are sorted and on which property.

|`RequestsTotalResultsCount`
|Determines whether the total number of results should be returned.

|`TimeoutMillis`
|The amount of time in milliseconds before the query is to be abandoned.

|===

===== Creating a query

The easiest way to create a Query is to use `${ddf-branding}.catalog.operation.QueryImpl` object.
It is first necessary to create an OGC Filter object then set the Query Options after `QueryImpl` has been constructed.

.QueryImpl Example 1
[source,java,linenums]
----
/*
  Builds a query that requests a total results count and
  that the first record to be returned is the second record found from
  the requested set of metacards.
 */

 String property = ...;

 String value = ...;

 org.geotools.filter.FilterFactoryImpl filterFactory = new FilterFactoryImpl() ;

 QueryImpl query = new QueryImpl( filterFactory.equals(filterFactory.property(property),

filterFactory.literal(value))) ;

 query.setStartIndex(2) ;

 query.setRequestsTotalResultsCount(true);
----

===== Evaluating a query

Every Source must be able to evaluate a Query object.
Nevertheless, each Source could evaluate the Query differently depending on what that Source supports as to properties and query capabilities.
For instance, a common property all Sources understand is id, but a Source could possibly store frequency values under the property name "frequency."
Some Sources may not support frequency property inquiries and will
throw an error stating it cannot interpret the property.
In addition, some Sources might be able to handle spatial operations, while others might not.
A developer should consult a Source's documentation for the limitations, capabilities, and properties that a Source can support.

=== Working with Filters

An OGC Filter is a Open Geospatial Consortium (OGC) standard (
http://www.opengeospatial.org/standards/filter
) that describes a query expression
in terms of Extensible Markup Language (XML) and key-value pairs (KVP). The ${ddf-catalog} Framework does not use the XML representation of
the OGC Filter standard. ${branding} instead utilizes the Java implementation provided by Geotools (
http://geotools.org/
). Geotools provides Java
equivalent classes for OGC Filter XML elements. Geotools originally provided the standard Java classes for the OGC Filter Encoding 1.0 under the
package name 
`org.opengis.filter`. The same package name is used today and is currently used by ${branding}.  Java developers do not parse or
view the XML representation of a 
Filter
 in ${branding}. Instead, developers use only the Java objects to complete query tasks.

Note that the ${ddf-branding}.catalog.operation.Query interface extends the org.opengis.filter.Filter interface, which means that a Query object is an OGC Java Filter with Query Options.

.A Query is an OGC Filter
[source,java]
----
public interface Query extends Filter
----

==== Using Filters

==== FilterBuilder API

To abstract developers from the complexities of working with the Filter interface directly and implementing the ${branding} Profile of the Filter specification, the ${ddf-catalog} includes an API, primarily in `${ddf-branding}.filter`, to build Filters using a fluent API.

To use the FilterBuilder API, an instance of `${ddf-branding}.filter.FilterBuilder` should be used via the OSGi registry.
Typically, this will be injected via a dependency injection framework.
Once an instance of `FilterBuilder` is available, methods can be called to create and combine Filters.

[TIP]
====
The fluent API is best accessed using an IDE that supports code-completion.  For additional details, refer to the Catalog API Javadoc.
====

==== Boolean Operators

`FilterBuilder.allOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean AND), either from a List or Array of Filter instances.

`FilterBuilder.anyOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean OR), either from a List or Array of Filter instances.

`FilterBuilder.not(Filter filter)`:: creates a new Filter that requires the provided Filter must not be match (Boolean NOT).

===== Attribute

`FilterBuilder.attribute(String attributeName)`:: begins a fluent API for creating an Attribute-based Filter, i.e., a Filter that matches on Metacards with Attributes of a particular value.

===== XPath

`FilterBuilder.xpath(String xpath)`:: begins a fluent API for creating an XPath-based Filter, i.e., a Filter that matches on Metacards with Attributes of type XML that match when evaluating a provided XPath selector.

===== Contextual Operators

[source,java,linenums]
----
FilterBuilder.attribute(attributeName).is().like().text(String contextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().caseSensitiveText(StringcaseSensitiveContextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().fuzzyText(String fuzzySearchPhrase);
----

===== Directly Implementing the Filter (Advanced)
[WARNING]
====
Implementing the Filter interface directly is only for extremely advanced use cases and is highly discouraged.
Instead, use of the ${branding}-specific `FilterBuilder` API is recommended.
====

Developers create a `Filter` object in order to filter or constrain the amount of records returned from a `Source`.
The OGC Filter Specification has several types of filters that can be combined in a tree-like structure to describe the set of metacards that should be returned. 

===== Categories of Filters

* Comparison Operators
* Logical Operators
* Expressions
* Literals
* Functions
* Spatial Operators
* Temporal Operators

===== Units of Measure

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 09-026r1] and http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 04-095], units of measure can be expressed as a URI.
To fulfill that requirement, ${branding} utilizes the Geotools class `org.geotools.styling.UomOgcMapping` for spatial filters requiring a standard for units of measure for scalar distances.
Essentially, the `UomOgcMapping` maps the http://www.opengeospatial.org/standards/symbol[OGC Symbology Encoding] standard URIs to Java Units.
This class provides three options for units of measure: 

* FOOT
* METRE
* PIXEL

${branding} only supports FOOT and METRE since they are the most applicable to scalar distances.

===== Creating Filters

The common way to create a `Filter` is to use the Geotools `FilterFactoryImpl` object, which provides Java implementations for the various types of filters in the Filter Specification.
Examples are the easiest way to understand how to properly create a `Filter` and a `Query`. 

[NOTE]
====
Refer to the http://docs.geotools.org/latest/javadocs/[Geotools javadoc] for more information on `FilterFactoryImpl`.
====

The example below illustrates creating a query, and thus an OGC Filter, that does a case-insensitive search for the phrase "mission" in the entire metacard's text.
Note that the OGC `PropertyIsLike` Filter is used for this simple contextual query.

===== Example Creating-Filters-1 

.Simple Contextual Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar,
and the escapeChar itself

String searchPhrase = "mission" ;
org.opengis.filter.Filter propertyIsLikeFilter =
    filterFactory.like(filterFactory.property(Metacard.ANY_TEXT), searchPhrase, wildcardChar, singleChar, escapeChar, isCaseSensitive);
${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( propertyIsLikeFilter );
----

The example below illustrates creating an absolute temporal query, meaning the query is searching for Metacards whose modified timestamp occurred during a specific time range.
Note that this query uses the `During` OGC Filter for an absolute temporal query.

===== Example Creating-Filters-2

.Absolute Temporal Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
org.opengis.temporal.Instant startInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(start));

org.opengis.temporal.Instant endInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(end));

org.opengis.temporal.Period period =  new org.geotools.temporal.object.DefaultPeriod(startInstant, endInstant);

String property = Metacard.MODIFIED ; // modified date of a metacard

org.opengis.filter.Filter filter = filterFactory.during( filterFactory.property(property), filterFactory.literal(period)  );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl(filter) ;
----

===== Contextual Searches

Most contextual searches can be expressed using the `PropertyIsLike` filter. The special haracters that have meaning in a `PropertyIsLike` filter are the wildcard, single wildcard, and escape characters (see Example Creating-Filters-1).

====== `PropertyIsLike` Special Characters
[cols="2*", options="header"]
|===
|Character
|Description

|Wildcard
|Matches zero or more characters.

|Single Wildcard
|Matches exactly one character.

|Escape
|Escapes the meaning of the Wildcard, Single Wildcard, and the Escape character itself
|===

Characters and words, such as `AND`, `&`, `and`, `OR`, `|`, `or`, `NOT`, `~`, `not`, `{`, and `}`, are treated as literals in a `PropertyIsLike` filter. In order to create equivalent logical queries, a developer must instead use the Logical Operator filters {`AND`, `OR`, `NOT`}. The Logical Operator filters can be combined together with `PropertyIsLike` filters to create a tree that represents the search phrase expression. 

===== Example Creating-Filters-3

.Creating the search phrase "mission and planning"
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;

boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar, and the escapeChar itself

Filter filter =
    filterFactory.and(
       filterFactory.like(filterFactory.property(Metacard.METADATA), "mission" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive),
       filterFactory.like(filterFactory.property(Metacard.METADATA), "planning" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive)
    );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( filter );
----

====== Tree View of Example Creating-Filters-3 

Filters used in ${branding} can always be represented in a tree diagram.

[ditaa,tree1, png,600]
....
+--------------------\
|cEEE /-------\      |
|     |  And  |      |
|     \-+---+-/      |
|       |   |        |
|     +-+   +-+      |
|     |       |      |
|     v       v      |
|/-------\ /--------\|
||mission| |planning||
|\-------/ \--------/|
\--------------------/
....

====== XML View of Example Creating-Filters-3

Another way to view this type of Filter is through an XML model, which is shown below.

.Pseudo XML of Example Creating-Filters-3
[source,xml,linenums]
----
<Filter>
   <And>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>mission</Literal>
      </PropertyIsLike>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>planning</Literal>
      </PropertyIsLike>
   <And>
</Filter>
----

Using the Logical Operators and `PropertyIsLike` filters, a developer can create a whole language of search phrase expressions.

===== Fuzzy Operation 

${branding} only supports one custom function.
The Filter specification does not include a fuzzy operator, so a Filter function was created to represent a fuzzy operation.
The function and class is called `FuzzyFunction`, which is used by clients to notify the Sources to perform a fuzzy search.
The syntax expected by providers is similar to the Fuzzy Function.
Refer to the example below.

[source,java,linenums]
----
String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar

boolean isCaseSensitive = false ;

Filter fuzzyFilter = filterFactory.like(
     new ${ddf-branding}.catalog.impl.filter.FuzzyFunction(
          Arrays.asList((Expression) (filterFactory.property(Metacard.ANY_TEXT))),
          filterFactory.literal("")),
     searchPhrase,
     wildcardChar,
     singleChar,
     escapeChar,
     isCaseSensitive);

QueryImpl query = new QueryImpl(fuzzyFilter);
----

===== Parsing Filters

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specification 04-095]: a "(filter expression) representation can be ... parsed and then transformed into whatever target language is required to retrieve or modify object instances stored in some persistent object store."
Filters can be thought of as the `WHERE` clause for a SQL SELECT statement to "fetch data stored in a SQL-based relational database." 

Sources can parse OGC Filters using the `FilterAdapter` and `FilterDelegate`.
See Developing a Filter Delegate for more details on implementing a new `FilterDelegate`.
This is the preferred way to handle OGC Filters in a consistent manner.

Alternately, `org.opengis.filter.Filter` implementations can be parsed using implementations of the interface `org.opengis.filter.FilterVisitor`. 
The `FilterVisitor` uses the http://www.oodesign.com/visitor-pattern.html[Visitor pattern]. Essentially, `FilterVisitor` instances "visit" each part of the `Filter` tree allowing developers to implement logic to handle the filter's operations. 
Geotools 8 includes implementations of the `FilterVisitor` interface.
The `DefaultFilterVisitor`, as an example, provides only business logic to visit every node in the `Filter` tree.
The `DefaultFilterVisitor` methods are meant to be overwritten with the correct business logic. 
The simplest approach when using `FilterVisitor` instances is to build the appropriate query syntax for a target language as each part of the `Filter` is visited.
For instance, when given an incoming `Filter` object to be evaluated against a RDBMS, a `CatalogProvider instance could use a `FilterVisitor` to interpret each filter operation on the `Filter` object and translate those operations into SQL.
The `FilterVisitor` may be needed to support `Filter` functionality not currently handled by the `FilterAdapter` and `FilterDelegate` reference implementation.

===== Examples

====== Interpreting a Filter to Create SQL

If the `FilterAdapter` encountered or "visited" a `PropertyIsLike` filter with its property assigned as `title` and its literal expression assigned as `mission`, the `FilterDelegate` could create the proper SQL syntax similar to title `LIKE` mission.

.Figure Parsing-Filters1
[ditaa,tree2,png]
....
+-------------------------\
|    /----------------\   |
|    | PropertyIsLike |   |
|    \----------------/   |
| cEEE      |  |          |
|      /----/  \----\     |
|      |            |     |
|      v            v     |
|/----------\  /---------\|
||Property- |  |Literal- ||
|| title    |  | mission ||
|\----------/  \---------/|
\-------------------------/
....

====== Interpreting a Filter to Create XQuery

If the `FilterAdapter` encountered an `OR` filter, such as in Figure Parsing-Filters2 and the target language was XQuery, the `FilterDelegate` could yield an expression such as 

[source]
----
ft:query(//inventory:book/@subject,'math') union
ft:query(//inventory:book/@subject,'science').
----

.Figure Parsing-Filters2
[ditaa, tree3, png]
....
+---------------------------------------------------\
|                       /----\                      |
|  cEEE                 | OR |                      |
|                       \----/                      |
|                        |  |                       |
|             /----------/  \----------\            |
|             |                        |            |
|             v                        v            |
|    /----------------\        /----------------\   |
|    | PropertyIsLike |        | PropertyIsLike |   |
|    \----------------/        \----------------/   |
|           |  |                      |  |          |
|      /----/  \----\            /----/  \----\     |
|      |            |            |            |     |
|      v            v            v            v     |
|/----------\  /---------\  /---------\  /---------\|
||Property- |  |Literal- |  |Property-|  |Literal- ||
|| title    |  | mission |  | Subject |  | science ||
|\----------/  \---------/  \---------/  \---------/|
\---------------------------------------------------/
....


====== FilterAdapter/Delegate Process for Figure Parsing-Filters2

. `FilterAdapter` visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike`method with the LHS property and literal.
. The LHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to the `OR` filter, which visits its second child.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike` method with the RHS property and literal.
. The RHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to its `OR Filter which is now done with its children.
. It then collects the output of each child and sends the list of results to the `FilterDelegate OR` method.
. The final result object will be returned from the `FilterAdapter` adapt method.

====== FilterVisitor Process for Figure Parsing-Filters2

. FilterVisitor visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The LHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to the `OR` filter, which visits its second child.
. The RHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to its `OR` filter, which is now done with its children. It then collects the output of each child and could potentially execute the following code to produce the above expression.

[source,java,linenums]
----
public visit( Or filter, Object data) {
...
   /* the equivalent statement for the OR filter in this domain (XQuery) */
   xQuery = childFilter1Output + " union " + childFilter2Output;
...
}
----

==== Filter Profile

===== Role of the OGC Filter

Both Queries and Subscriptions extend the OGC GeoAPI Filter interface.

The Filter Builder and Adapter do not fully implement the OGC Filter Specification.
The filter support profile contains suggested filter to metacard type mappings.
For example, even though a Source could support a `PropertyIsGreaterThan` filter on `XML_TYPE`, it would not likely be useful.

===== Catalog Filter Profile

====== Metacard Attribute To Type Mapping

The filter profile maps filters to metacard types.
The following table displays the common metacard attributes with their respective types for reference.

[cols="2*", options="header"]
|===

|Metacard Attribute
|Metacard Type

|ANY_DATE
|DATE_TYPE

|ANY_GEO
|GEO_TYPE

|ANY_TEXT
|STRING_TYPE

|CONTENT_TYPE
|STRING_TYPE

|CONTENT_TYPE_VERSION
|STRING_TYPE

|CREATED
|DATE_TYPE

|EFFECTIVE
|DATE_TYPE

|GEOGRAPHY
|GEO_TYPE

|ID
|STRING_TYPE

|METADATA
|XML_TYPE

|MODIFIED
|DATE_TYPE

|RESOURCE_SIZE
|STRING_TYPE

|RESOURCE_URI
|STRING_TYPE

|SOURCE_ID
|STRING_TYPE

|TARGET_NAMESPACE
|STRING_TYPE

|THUMBNAIL
|BINARY_TYPE

|TITLE
|STRING_TYPE

|===

====== Comparison Operators

Comparison operators compare the value associated with a property name with a given Literal value.
Endpoints and sources should try to use metacard types other than the object type.
The object type only supports backwards compatibility with `java.net.URI`.  
Endpoints that send other objects will not be supported by standard sources.
The following table maps the metacard types to supported comparison operators.

[cols="12*", options="header"]
|===

|PropertyIs
|Between
|EqualTo
|GreaterThan
|GreaterThan
|OrEqualTo
|LessThan
|LessThan
|OrEqualTo
|Like
|NotEqualTo
|Null

|BINARY_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|BOOLEAN_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|DATE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|DOUBLE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|FLOAT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

 

|GEO_TYPE
|
|
|
|
|
|
|
|
|
|
|*X*

|INTEGER_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|LONG_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|OBJECT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|SHORT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|STRING_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*

|XML_TYPE
|
|*X*
|
|
|
|
|
|
|*X*
|
|*X*
 
|===

The following table describes each comparison operator.

.Comparison Operators
[cols="2*", options="header"]
|===

|Operator
|Description

|PropertyIsBetween
|Lower <= Property <= Upper

|PropertyIsEqualTo
|Property == Literal

|PropertyIsGreaterThan
|Property > Literal

|PropertyIsGreaterThanOrEqualTo
|Property >= Literal

|PropertyIsLessThan
|Property < Literal

|PropertyIsLessThanOrEqualTo
|Property <= Literal

|PropertyIsLike
|Property LIKE Literal

Equivalent to SQL "like" 

|PropertyIsNotEqualTo
|Property != Literal

|PropertyIsNull
|Property == null

|===

====== Logical Operators
Logical operators apply Boolean logic to one or more child filters.

.Logical Operators
[cols="4*", options="header"]
|===

|
|And
|Not
|Or

|Supported Filters
|*X*
|*X*
|*X*

|===

====== Temporal Operators
Temporal operators compare a date associated with a property name to a given Literal date or date range.
The following table displays the supported temporal operators.

[cols="12*", options="header"]
|===
|
|After
|AnyInteracts
|Before
|Begins
|BegunBy
|During
|EndedBy
|Meets
|MetBy
|OverlappedBy
|TContains

|DATE_TYPE
|*X*
|
|*X*
|
|
|*X*
|
|
|
|
|

|===

The following table describes each temporal operator.
Literal values can be either date instants or date periods.
[cols="2*", options="header"]
|===

|Operator
|Description

|After
|Property > (Literal \|\| Literal.end)

|Before
|Property < (Literal \|\| Literal.start)

|During
|Literal.start < Property < Literal.end

|===

====== Spatial Operators

Spatial operators compare a geometry associated with a property name to a given Literal geometry. 
The following table displays the supported spatial operators.

[cols="11*", options="headers"]
|===

|BBox
|Beyond
|Contains
|Crosses
|Disjoint
|Equals
|DWithin
|Intersects
|Overlaps
|Touches
|Within

|GEO_TYPE
|
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*
|*X*
|

|===

The following table describes each spatial operator.
Geometries are usually represented as Well-Known Text (_WKT_).

[cols="2*", options="header"]
|===

|Operator
|Description

|Beyond
|Property geometries beyond given distance of Literal geometry

|Contains
|Property geometry contains Literal geometry

|Crosses
|Property geometry crosses Literal geometry

|Disjoint
|Property geometry direct positions are not interior to Literal geometry

|DWithin
|Property geometry lies within distance to Literal geometry

|Intersects
|Property geometry intersects Literal geometry; opposite to the Disjoint operator 

|Overlaps
|Property geometry interior somewhere overlaps Literal geometry interior

|Touches
|Property geometry touches but does not overlap Literal geometry

|Within
|Property geometry completely contains Literal geometry

|===

==== Commons-DDF Utilities

The `commons-${ddf-branding}`bundle, located in `<DDF_HOME_SOURCE_DIRECTORY>/common/commons-${ddf-branding}`, provides utilities and functionality commonly used across other ${branding} components, such as the endpoints and providers. 

==== Noteworthy Classes

===== FuzzyFunction

`${ddf-branding}.catalog.impl.filter.FuzzyFunction` class is used to indicate that a `PropertyIsLike` filter should interpret the search as a fuzzy query. 

===== XPathHelper

`${ddf-branding}.util.XPathHelper` provides convenience methods for executing XPath operations on XML.
It also provides convenience methods for converting XML as a `String` from a `org.w3c.dom.Document` object and vice versa.





==== Developing Console Commands

===== Console Commands

${branding} supports development of custom console commands.

${branding} includes custom commands for working with the Catalog, as described in the <<managing.adoc#_console_commands, Managing Console Commands>> section.







==== Developing a Filter Delegate

Filter Delegates help reduce the complexity of parsing OGC Filters.
The reference Filter Adapter implementation contains the necessary boilerplate visitor code and input normalization to handle commonly supported OGC Filters.

===== Creating a New Filter Delegate

A Filter Delegate contains the logic that converts normalized filter input into a form that the targeted data source can handle.
Delegate methods will be called in a depth first order as the Filter Adapter visits filter nodes.

===== Implementing the Filter Delegate

. Create a Java class extending `FilterDelegate`. +
`public class ExampleDelegate extends ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> {`
. `FilterDelegate` will throw an appropriate exception for all methods not implemented.  Refer to the ${branding} JavaDoc for more details about what is expected of each `FilterDelegate` method.

[NOTE]
====
A code example of a Filter Delegate can be found in `${ddf-branding}.catalog.filter.proxy.adapter.test` of the `filter-proxy` bundle.
====

===== Throwing Exceptions

Filter delegate methods can throw `UnsupportedOperationException` run-time exceptions.
The `GeotoolsFilterAdapterImpl` will catch and re-throw these exceptions as `UnsupportedQueryExceptions`.

===== Using the Filter Adapter

The FilterAdapter can be requested from the OSGi registry.

[source,xml]
----
<reference id="filterAdapter" interface="${ddf-branding}.catalog.filter.FilterAdapter" />
----

The Query in a QueryRequest implements the Filter interface.
The Query can be passed to a `FilterAdapter` and `FilterDelegate` to process the Filter.

[source,java,linenums]
----
@Override
public ${ddf-branding}.catalog.operation.QueryResponse query(${ddf-branding}.catalog.operation.QueryRequest queryRequest)
    throws ${ddf-branding}.catalog.source.UnsupportedQueryException {

    ${ddf-branding}.catalog.operation.Query query = queryRequest.getQuery();

    ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> delegate = new ExampleDelegate();

    // ${ddf-branding}.catalog.filter.FilterAdapter adapter injected via Blueprint
    ExampleReturnObjectType result = adapter.adapt(query, delegate);
}
----

Import the ${ddf-catalog} API Filter package and the reference implementation package of the Filter Adapter in the bundle manifest  (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.filter, ${ddf-branding}.catalog.source`

===== Filter Support

Not all OGC Filters are exposed at this time.
If demand for further OGC Filter functionality is requested, it can be added to the Filter Adapter and Delegate so sources can support more complex filters.
The following OGC Filter types are currently available:

[cols="1" options="header"]
|===
|Logical
|And
|Or
|Not
|Include
|Exclude
|===

[cols="1" options="header"]
|===
|Property Comparison
|`PropertyIsBetween`
|`PropertyIsEqualTo`
|`PropertyIsGreaterThan`
|`PropertyIsGreaterThanOrEqualTo`
|`PropertyIsLessThan`
|`PropertyIsLessThanOrEqualTo`
|`PropertyIsLike`
|`PropertyIsNotEqualTo`
|`PropertyIsNull`
|===

[cols="2,5" options="header"]
|===
|`Spatial`
|Definition

|`Beyond`
|True if the geometry being tested is beyond the stated distance of the geometry provided.

|`Contains`
|True if the second geometry is wholly inside the first geometry.

|`Crosses`
|True if the intersection of the two geometries results in a value whose dimension is less than the geometries and the maximum dimension of the intersection value includes points interior to both the geometries, and the intersection value is not equal to either of the geometries.

|`Disjoint`
|True if the two geometries do not touch or intersect.

|`DWithin`
|True if the geometry being tested is within the stated distance of the geometry provided.

|`Intersects`
|True if the two geometries intersect. This is a convenience method as you could always ask for Not Disjoint(A,B) to get the same result.

|`Overlaps`
|True if the intersection of the geometries results in a value of the same dimension as the geometries that is different from both of the geometries.

|`Touches`
|True if and only if the only common points of the two geometries are in the union of the boundaries of the geometries.

|`Within`
|True if the first geometry is wholly inside the second geometry.
|===

[cols="1" options="header"]
|===
|Temporal
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/After.html[After]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/Before.html[Before]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/During.html[During]
|===




=== Extending Eventing


=== Extending Resource Components

Resource components are used when working with resources, i.e., the data that is represented by the cataloged metadata.

A resource is a URI-addressable entity that is represented by a metacard. Resources may also be known as products or data.

Resources may exist either locally or on a remote data store.

Examples of resources include:

* NITF image
* MPEG video
* Live video stream
* Audio recording
* Document

A resource object in ${branding} contains an `InputStream` with the binary data of the resource. 
It describes that resource with a name, which could be a file name, URI, or another identifier. 
It also contains a mime type or content type that a client can use to interpret the binary data.  

.Resources Architecture
[ditaa, catalog_architecture_resources, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |c369   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Resource Readers

A resource reader retrieves resources associated with metacards via URIs.
Each resource reader must know how to interpret the resource's URI and how to interact with the data store to retrieve the resource.

There can be multiple resource readers in a Catalog instance.
The `Catalog Framework` selects the appropriate resource reader based on the scheme of the resource's URI. 

In order to make a resource reader available to the Catalog Framework, it must be exported to the OSGi Service Registry as a `${ddf-branding}.catalog.resource.ResourceReader`. 

===== URL Resource Reader

The `URLResourceReader` is an implementation of `ResourceReader` which is included in the ${branding} Catalog. 
It obtains a resource given an http, https, or file-based URL. 
The `URLResourceReader` will connect to the provided Resource URL and read the resource's bytes into an `InputStream`.  

[WARNING]
====
When a resource linked using a file-based URL is in the product cache, the `URLResourceReader`&#8217;s rootResourceDirectories is not checked when downloading the product.
It is downloaded from the product cache which bypasses the `URLResourceReader`.
For example, if path `/my/valid/path` is configured in the `URLResourceReader`&#8217;s rootResourceDirectories and one downloads the product with resource-uri `file:///my/valid/path/product.txt` and then one removes `/my/valid/path` from the `URLResourceReader`&#8217;s `rootResourceDirectories` configuration, the product will still be accessible via the product cache.
====

===== Installing and Uninstalling

`URLResourceReader` is installed by default with the ${branding} Catalog.

===== Configuring

====== Configurable Properties

_URL Resource Reader_

[cols="1,1,3,1,1", options="header"]
|===

|Property
|Type
|Description
|Default Value
|Required

|`rootResourceDirectories`
|String array
|Specifies the only directories the `URLResourceReader` has access to when attempting to download resources linked using file-based URLs (i.e. the metacard attribute resource-uri uses the file URI scheme). This property is used to restrict the `URLResourceReader`&#8217;s access to the file system. The `URLResourceReader` can be given full access to the file system by setting the `rootResourceDirectories` property to the root directory (e.g. `/`), but this configuration is not recommended.
|<${ddf-branding}.home>/data/products
|yes

|===

===== Using

`URLResourceReader` will be used by the Catalog Framework to obtain a resource whose metacard is cataloged in the local data store.
This particular `ResourceReader` will be chosen by the `CatalogFramework` if the requested resource's URL has a protocol of `http`, `https`, or `file`.  

For example, requesting a resource with the following URL will make the Catalog Framework invoke the `URLResourceReader` to retrieve the product.

.Example
[source,http]
----
file:///home/users/${ddf-branding}_user/data/example.txt
----

If a resource was requested with the URL `udp://123.45.67.89:80/SampleResourceStream`, the `URLResourceReader` would _not_ be invoked.

===== Implementation Details

Supported Schemes:

* http
* https
* file

[NOTE]
====
If a file-based URL is passed to the `URLResourceReader`, that file path needs to be accessible by the ${branding} instance.
====

===== Known Issues

None

==== Developing a Resource Reader

A `ResourceReader` is a class that retrieves a resource or product from a native/external source and returns it to ${branding}.
A simple example is that of a File `ResourceReader`.
It takes a file from the local file system and passes it back to ${branding}.
New implementations can be created in order to support obtaining Resources from various Resource data stores. 

===== Create a New ResourceReader

Complete the following procedure to create a `ResourceReader`.

. Create a Java class that implements the `${ddf-branding}.catalog.resource.ResourceReader` interface.
. Deploy the OSGi bundled packaged service to the ${branding} run-time.

===== Implementing the ResourceReader Interface

[source,java,linenums]
----
public class TestResourceReader implements ${ddf-branding}.catalog.resource.ResourceReader
----

`ResourceReader` has a couple of key methods where most of the work is performed.

[NOTE]
====
*URI* +
It is recommended to become familiar with the Java API URI class in order to properly build a `ResourceReader`. 
Furthermore, a URI should be used according to its http://www.w3.org/Addressing/URL/uri-spec.html[specification].
====

===== retrieveResource

[source,java,linenums]
----
public ResourceResponse retrieveResource( URI uri, Map<String, Serializable> arguments )throws IOException, ResourceNotFoundException, ResourceNotSupportedException;
----

This method is the main entry to the `ResourceReader`.
It is used to retrieve a `Resource` and send it back to the caller (generally the `CatalogFramework`).
Information needed to obtain the entry is contained in the `URI` reference.
The URI Scheme will need to match a scheme specified in the `getSupportedSchemes` method.
This is how the CatalogFramework determines which `ResourceReader` implementation to use. 
If there are multiple `ResourceReaders` supporting the same scheme, these `ResourceReaders` will be invoked iteratively. 
Invocation of the `ResourceReaders` stops once one of them returns a `Resource`.

Arguments are also passed in.
These can be used by the `ResourceReader` to perform additional operations on the resource.

An example of how `URLResourceReader` (located in the source code at `/trunk/${ddf-branding}/catalog/resource/URLResourceReader.java`) implements the `getResource` method.
This `ResourceReader` simply reads a file from a URI.

[NOTE]
====
The `Map<String, Serializable> arguments` parameter is passed in to support any options or additional information associated with retrieving the resource.
====

===== Implement `retrieveResource()`

. Define supported schemes (e.g., file, http, etc.).
. Check if the incoming URI matches a supported scheme. If it does not, throw `ResourceNotSupportedException`.

.Example:
[source,java,linenums]
----
if ( !uri.getScheme().equals("http") )
 {
   throw new ResourceNotSupportedException("Unsupported scheme received, was expecting http")
 }
----

. Implement the business logic.
. For example, the `URLResourceReader` will obtain the resource through a connection:

[source,java,linenums]
----
URL url = uri.toURL();
URLConnection conn = url.openConnection();
String mimeType = conn.getContentType();
if ( mimeType == null ) {
    mimeType = URLConnection.guessContentTypeFromName( url.getFile() );
}
InputStream is = conn.getInputStream();
----

[NOTE]
====
The `Resource` needs to be accessible from the ${branding} installation (see the rootResourceDirectories property of the `URLResourceReader`). 
This includes being able to find a file locally or reach out to a remote URI. 
This may require Internet access, and ${branding} may need to be configured to use a proxy (`http.proxyHost` and `http.proxyPort` can be added to the system properties on the command line script).
====

. Return `Resource` in `ResourceResponse`.

For example:
[source,java,linenums]
----
return ResourceResponseImpl( new ResourceImpl( new BufferedInputStream( is ), new MimeType( mimeType ), url.getFile() ) );
----

If the Resource cannot be found, throw a `ResourceNotFoundException`.  

===== `getSupportedSchemes`

[source,java]
----
public Set<String> getSupportedSchemes();
----

This method lets the `ResourceReader` inform the CatalogFramework about the type of URI scheme that it accepts and should be passed.
For single-use ResourceReaders (like a URLResourceReader), there may be only one scheme that it can accept while others may understand more than one.
A ResourceReader must, at minimum, accept one qualifier. 
As mentioned before, this method is used by the `CatalogFramework` to determine which `ResourceReader` to invoke. 

[NOTE]
====
*`ResourceReader` extends `Describable`* +
Additionally, there are other methods that are used to uniquely describe a `ResourceReader`.
 The `describe` methods are straight-forward and can be implemented with guidance from the Javadoc.
====

===== Export to OSGi Service Registry

In order for the `ResourceReader` to be used by the `CatalogFramework`, it should be exported to the OSGi Service Registry as a `${ddf-branding}.catalog.resource.ResourceReader`.

See the XML below for an example:

.Blueprint example
[source,xml,linenums]
----
<bean id="[[customResourceReaderId]]" class="[[example.resource.reader.impl.CustomResourceReader]]" />
<service ref="[[customResourceReaderId]]" interface="${ddf-branding}.catalog.source.ResourceReader" />
----

==== Resource Writers

A resource writer stores a resource and produces a URI that can be used to retrieve the resource at a later time.
The resource URI uniquely locates and identifies the resource.
Resource writers can interact with an underlying data store and store the resource in the proper place.
Each implementation can do this differently, providing flexibility in the data stores used to persist the resources.

===== Examples

The Catalog reference implementation currently does not include any resource writers out of the box.

==== Developing a Resource Writer

A `ResourceWriter` is an object used to store or delete a `Resource`. 
`ResourceWriter` objects should be registered within the OSGi Service Registry, so clients can retrieve an instance when clients need to store a `Resource`. 

===== Create a New `ResourceWriter`

Complete the following procedure to create a `ResourceWriter`.

. Create a Java class that implements the `${ddf-branding}.catalog.resource.ResourceWriter` interface.

.ResourceWriter Implementation Skeleton
[source,java,linenums]
----
import java.io.IOException;
import java.net.URI;
import java.util.Map;
import ${ddf-branding}.catalog.resource.Resource;
import ${ddf-branding}.catalog.resource.ResourceNotFoundException;
import ${ddf-branding}.catalog.resource.ResourceNotSupportedException;
import ${ddf-branding}.catalog.resource.ResourceWriter;

public class SampleResourceWriter implements ResourceWriter {

	@Override
	public void deleteResource(URI uri, Map<String, Object> arguments) throws ResourceNotFoundException, IOException {
	   // WRITE IMPLEMENTATION
	 }

	@Override
	public URI storeResource(Resource resource, Map<String, Object> arguments)throws ResourceNotSupportedException, IOException {
	   // WRITE IMPLEMENTATION
	   return null;
	}

	@Override
	public URI storeResource(Resource resource, String id, Map<String, Object> arguments) throws ResourceNotSupportedException, IOException {
	   // WRITE IMPLEMENTATION
	   return null;
	}

}
----
. Register the implementation as a Service in the OSGi Service Registry.

.Blueprint Service Registration Example
[source,xml,linenums]
----
...
<service ref="[[ResourceWriterReference]]" interface="${ddf-branding}.catalog.resource.ResourceWriter" />
...
----

. Deploy the OSGi bundled packaged service to the ${branding} run-time (Refer to the Working with OSGi - Bundles section.)

[TIP]
====
*ResourceWriter Javadoc* +
Refer to the ${ddf-catalog} API Javadoc for more information about the methods required for implementing the interface. 
====

==== Developing a Registry Client

Registry Clients create Federated Sources using the OSGi Configuration Admin.
Developers should reference an individual `Source`'s (Federated, Connected, or Catalog Provider) documentation for the Configuration properties (such as a Factory PID, addresses, intervals, etc) necessary to establish that `Source` in the framework. 

===== Example

.Creating a Source Configuration
[source,java,linenums]
----
org.osgi.service.cm.ConfigurationAdmin configurationAdmin = getConfigurationAdmin() ;
org.osgi.service.cm.Configuration currentConfiguration = configurationAdmin.createFactoryConfiguration(getFactoryPid(), null);
Dictionary properties = new Dictionary() ;
properties.put(QUERY_ADDRESS_PROPERTY,queryAddress);
currentConfiguration.update( properties );
----

Note that the `QUERY_ADDRESS_PROPERTY` is specific to this Configuration and might not be required for every `Source`.
The properties necessary for creating a Configuration are different for every `Source`. 

==== Working with Resources

===== Metacards and Resources

Metacards are used to describe a resource through metadata. 
This metadata includes the time the resource was created, the location where the resource was created, etc. 
A ${branding} `Metacard` contains the `getResourceUri` method, which is used to locate and retrieve its corresponding resource.

===== Retrieve Resource

When a client attempts to retrieve a resource, it must provide a metacard ID or URI corresponding to a unique resource. 
As mentioned above, the resource URI is obtained from a `Metacard`'s `getResourceUri` method. 
The `CatalogFramework` has three methods that can be used by clients to obtain a resource: `getEnterpriseResource`, `getResource`, and `getLocalResource`.
The `getEnterpriseResource` method invokes the `retrieveResource` method on a local `ResourceReader` as well as all the `Federated` and `Connected` Sources inthe ${branding} enterprise. 
The second method, `getResource`, takes in a source ID as a parameter and only invokes `retrieveResource` on the specified `Source`. 
The third method invokes `retrieveResource` on a local `ResourceReader`. 

The parameter for each of these methods in the `CatalogFramework` is a 	`ResourceRequest`. 
${branding} includes two implementations of `ResourceRequest`: `ResourceRequestById` and `ResourceRequestByProductUri`. 
Since these implementations extend `OperationImpl`, they can pass a `Map` of generic properties through the `CatalogFramework` to customize how the resource request is carried out. 
One example of this is explained in the Options section below. 
The following is a basic example of how to create a `ResourceRequest` and invoke the `CatalogFramework` resource retrieval methods to process the request.   

.Retrieve Resource Example
[source,java,linenums]
----
Map<String, Serializable> properties = new HashMap<String, Serializable>();
properties.put("PropertyKey1", "propertyA"); //properties to customize Resource retrieval
ResourceRequestById resourceRequest = new ResourceRequestById("0123456789abcdef0123456789abcdef", properties); //object containing ID of Resource to be retrieved
String sourceName = "LOCAL_SOURCE"; //the Source ID or name of the local Catalog or a Federated Source
ResourceResponse resourceResponse; //object containing the retrieved Resource and the request that was made to get it.
resourceResponse = catalogFramework.getResource(resourceRequest, sourceName); //Source-based retrieve Resource request
Resource resource = resourceResponse.getResource(); //actual Resource object containing InputStream, mime type, and Resource name
----

`${ddf-branding}.catalog.resource.ResourceReader` instances can be discovered via the OSGi Service Registry.
The system can contain multiple `ResourceReaders`. 
The `CatalogFramework` determines which one to call based on the scheme of the resource's URI and what schemes the `ResourceReader` supports. 
The supported schemes are obtained by a `ResourceReader`'s `getSupportedSchemes` method. 
As an example, one `ResourceReader` may know how to handle file-based URIs with the scheme 	`file`, whereas another `ResourceReader` may support HTTP-based URIs with the scheme `http`.

The `ResourceReader` or `Source` is responsible for locating the resource, reading its bytes, adding the binary data to a `Resource` implementation, then returning that `Resource` in a `ResourceResponse`. 
The `ResourceReader` or `Source` is also responsible for determining the `Resource`'s name and mime type, which it sends back in the `Resource` implementation.  
 

===== Options

Options can be specified on a retrieve resource request made through any of the supporting endpoint. 
To specify an option for a retrieve resource request, the endpoint needs to first instantiate a `ResourceRequestByProductUri` or a `ResourceRequestById`. 
Both of these `ResourceRequest` implementations allow a `Map` of properties to be specified. 
Put the specified option into the `Map` under the key `RESOURCE_OPTION`.  

.Retrieve Resource with Options
[source,java,linenums]
----
Map<String, Serializable> properties = new HashMap<String, Serializable>();
properties.put("RESOURCE_OPTION", "OptionA");
ResourceRequestById resourceRequest = new ResourceRequestById("0123456789abcdef0123456789abcdef", properties);
----

Depending on the support that the `ResourceReader` or `Source` provides for options, the `properties``Map` will be checked for the `RESOURCE_OPTION` entry. 
If that entry is found, the option will be handled; however, the `ResourceReader` or `Source` supports options. 
If the `ResourceReader` or `Source` does not support options, that entry will be ignored.

A new `ResourceReader` or `Source` implementation can be created to support options in a way that is most appropriate. 
Since the option is passed through the catalog framework as a property, the `ResourceReader` or `Source` will have access to that option as long as the endpoint supports options.       

===== Store Resource

Resources are saved using a `ResourceWriter`. 
`${ddf-branding}.catalog.resource.ResourceWriter` instances can be discovered via the OSGi Service Registry.
Once retrieved, the `ResourceWriter` instance provides clients a way to store resources and get a corresponding URI that can be used to subsequently retrieve the resource via a `ResourceReader`. 
Simply invoke either of the `storeResource` methods with a resource and any potential arguments.
 
The `ResourceWriter` implementation is responsible for determining where the resource is saved and how it is saved. 
This allows flexibility for a resource to be saved in any one of  a variety of data stores or file systems. 
The following is an example of how to use a generic implementation of `ResourceWriter`.

[source,java,linenums]
----
InputStream inputStream = <Video_Input_Stream>; //InputStream of raw Resource data
MimeType mimeType = new MimeType("video/mpeg"); //Mime Type or content type of Resource
String name = "Facility_Video";  //Descriptive Resource name
Resource resource = new ResourceImpl(inputStream, mimeType, name);
Map<String, Object> optionalArguments = new HashMap<String, Object>();
ResourceWriter writer = new ResourceWriterImpl();
URI resourceUri; //URI that can be used to retrieve Resource
resourceUri = writer.storeResource(resource, optionalArguments); //Null can be passed in here
----

===== BinaryContent

`BinaryContent` is an object used as a container to store translated or transformed ${branding} components. 
`Resource` extends `BinaryContent` andincludes a `getName` method.  `
BinaryContent` has methods to get the `InputStream`, `byte` array, MIME type, and size of the represented binary data.
An implementation of `BinaryContent` (`BinaryContentImpl`) can be found in the Catalog API in the `${ddf-branding}.catalog.data` package.

====== Additional Information

* URI on Wikipedia (http://en.wikipedia.org/wiki/Uniform_resource_identifier)
* URI Javadoc (http://docs.oracle.com/javase/6/docs/api/java/net/URI.html)
