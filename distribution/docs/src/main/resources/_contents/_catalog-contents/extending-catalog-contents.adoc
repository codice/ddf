////
NOTE TO REVIEWERS:
The Content in this file is being migrated to other files. Ignore changes here, as the content has been moved to a new home. A nice farm; upstate.
////
The ${ddf-catalog} provides a framework for storing, searching, processing, and transforming information.
Clients typically perform query, create, read, update, and delete (QCRUD) operations against the Catalog.  
At the core of the Catalog functionality is the Catalog Framework, which routes all requests and responses through the system, invoking additional processing per the system configuration.

This guide supports developers creating extensions of the existing framework.

=== Whitelist

The following packages have been exported by the ${ddf-catalog} application and are approved for use by third parties:

* `${ddf-branding-lowercase}.camel.component.catalog`
* `${ddf-branding-lowercase}.catalog`
* `${ddf-branding-lowercase}.catalog.cache`
* `${ddf-branding-lowercase}.catalog.data`
* `${ddf-branding-lowercase}.catalog.data.metacardtype`
* `${ddf-branding-lowercase}.catalog.event`
* `${ddf-branding-lowercase}.catalog.federation`
* `${ddf-branding-lowercase}.catalog.federation.impl`
* `${ddf-branding-lowercase}.catalog.filter`
* `${ddf-branding-lowercase}.catalog.filter.delegate`
* `${ddf-branding-lowercase}.catalog.impl.filter`
* `${ddf-branding-lowercase}.catalog.operation`
* `${ddf-branding-lowercase}.catalog.plugin`
* `${ddf-branding-lowercase}.catalog.plugin.groomer`
* `${ddf-branding-lowercase}.catalog.pubsub`
* `${ddf-branding-lowercase}.catalog.pubsub.tracker`
* `${ddf-branding-lowercase}.catalog.resource`
* `${ddf-branding-lowercase}.catalog.resource.data`
* `${ddf-branding-lowercase}.catalog.resource.impl`
* `${ddf-branding-lowercase}.catalog.resourceretriever`
* `${ddf-branding-lowercase}.catalog.service`
* `${ddf-branding-lowercase}.catalog.source`
* `${ddf-branding-lowercase}.catalog.transform`
* `${ddf-branding-lowercase}.catalog.transformer.api`
* `${ddf-branding-lowercase}.catalog.transformer.metacard.geojson`
* `${ddf-branding-lowercase}.catalog.util`
* `${ddf-branding-lowercase}.catalog.validation`
* `${ddf-branding-lowercase}.common`
* `${ddf-branding-lowercase}.geo.formatter`
* `${ddf-branding-lowercase}.util`
* `org.codice.${ddf-branding-lowercase}.endpoints`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest.action`
* `org.codice.${ddf-branding-lowercase}.opensearch.query`
* `org.codice.${ddf-branding-lowercase}.opensearch.query.filter`




=

==== CatalogProvider





==== Plugins



=== Catalog Development Fundamentals

This section introduces the fundamentals of working with the Catalog API the OGC Filter for Queries.

==== Simple Catalog API Implementations

The Catalog API implementations, which are denoted with the suffix of `Impl` on the Java file names, have multiple purposes and uses.

* First, they provide a good starting point for other developers to extend functionality in the framework. For instance, extending the `MetacardImpl` allows developers to focus less on the inner workings of ${branding} and more on the developer's intended purposes and objectives. 

* Second, the Catalog API Implementations display the proper usage of an interface and an interface's intentions. Also, they are good code examples for future implementations. If a developer does not want to extend the simple implementations, the developer can at least have a working code reference to base future development.

==== Use of the Whiteboard Design Pattern

The ${ddf-catalog} makes extensive use of the Whiteboard Design Pattern.
Catalog Components are registered as services in the OSGi Service Registry, and the Catalog Framework or any other clients tracking the OSGi Service Registry are automatically notified by the OSGi Framework of additions and removals of relevant services.

The Whiteboard Design Pattern is a common OSGi technique that is derived from a technical whitepaper provided by the OSGi Alliance in 2004.
It is recommended to use the Whiteboard pattern over the Listener pattern in OSGi because it provides less complexity in code (both on the client and server sides), fewer deadlock possibilities than the Listener pattern, and closely models the intended usage of the OSGi framework.

==== Working with Queries

Clients use `${ddf-branding}.catalog.operation.Query` objects to describe which metacards are needed from Sources. 
Query objects have two major components:

* Filter 
* Query Options

A Source uses the Filter criteria constraints to find the requested set of metacards within its domain of metacards.
The Query Options are used to further restrict the Filter's set of requested metacards.

===== Query Options
[cols="2*", options="header"]
|===
|Option
|Description

|`StartIndex`
|1-based index that states which metacard the Source should return first out of the requested metacards.

|`PageSize`
|Represents the maximum amount of metacards the Source should return.

|`SortBy`
|Determines how the results are sorted and on which property.

|`RequestsTotalResultsCount`
|Determines whether the total number of results should be returned.

|`TimeoutMillis`
|The amount of time in milliseconds before the query is to be abandoned.

|===

===== Creating a query

The easiest way to create a Query is to use `${ddf-branding}.catalog.operation.QueryImpl` object.
It is first necessary to create an OGC Filter object then set the Query Options after `QueryImpl` has been constructed.

.QueryImpl Example 1
[source,java,linenums]
----
/*
  Builds a query that requests a total results count and
  that the first record to be returned is the second record found from
  the requested set of metacards.
 */

 String property = ...;

 String value = ...;

 org.geotools.filter.FilterFactoryImpl filterFactory = new FilterFactoryImpl() ;

 QueryImpl query = new QueryImpl( filterFactory.equals(filterFactory.property(property),

filterFactory.literal(value))) ;

 query.setStartIndex(2) ;

 query.setRequestsTotalResultsCount(true);
----

===== Evaluating a query

Every Source must be able to evaluate a Query object.
Nevertheless, each Source could evaluate the Query differently depending on what that Source supports as to properties and query capabilities.
For instance, a common property all Sources understand is id, but a Source could possibly store frequency values under the property name "frequency."
Some Sources may not support frequency property inquiries and will
throw an error stating it cannot interpret the property.
In addition, some Sources might be able to handle spatial operations, while others might not.
A developer should consult a Source's documentation for the limitations, capabilities, and properties that a Source can support.

=== Working with Filters

An OGC Filter is a Open Geospatial Consortium (OGC) standard (
http://www.opengeospatial.org/standards/filter
) that describes a query expression
in terms of Extensible Markup Language (XML) and key-value pairs (KVP). The ${ddf-catalog} Framework does not use the XML representation of
the OGC Filter standard. ${branding} instead utilizes the Java implementation provided by Geotools (
http://geotools.org/
). Geotools provides Java
equivalent classes for OGC Filter XML elements. Geotools originally provided the standard Java classes for the OGC Filter Encoding 1.0 under the
package name 
`org.opengis.filter`. The same package name is used today and is currently used by ${branding}.  Java developers do not parse or
view the XML representation of a 
Filter
 in ${branding}. Instead, developers use only the Java objects to complete query tasks.

Note that the ${ddf-branding}.catalog.operation.Query interface extends the org.opengis.filter.Filter interface, which means that a Query object is an OGC Java Filter with Query Options.

.A Query is an OGC Filter
[source,java]
----
public interface Query extends Filter
----

==== Using Filters

==== FilterBuilder API

To abstract developers from the complexities of working with the Filter interface directly and implementing the ${branding} Profile of the Filter specification, the ${ddf-catalog} includes an API, primarily in `${ddf-branding}.filter`, to build Filters using a fluent API.

To use the FilterBuilder API, an instance of `${ddf-branding}.filter.FilterBuilder` should be used via the OSGi registry.
Typically, this will be injected via a dependency injection framework.
Once an instance of `FilterBuilder` is available, methods can be called to create and combine Filters.

[TIP]
====
The fluent API is best accessed using an IDE that supports code-completion.  For additional details, refer to the Catalog API Javadoc.
====

==== Boolean Operators

`FilterBuilder.allOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean AND), either from a List or Array of Filter instances.

`FilterBuilder.anyOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean OR), either from a List or Array of Filter instances.

`FilterBuilder.not(Filter filter)`:: creates a new Filter that requires the provided Filter must not be match (Boolean NOT).

===== Attribute

`FilterBuilder.attribute(String attributeName)`:: begins a fluent API for creating an Attribute-based Filter, i.e., a Filter that matches on Metacards with Attributes of a particular value.

===== XPath

`FilterBuilder.xpath(String xpath)`:: begins a fluent API for creating an XPath-based Filter, i.e., a Filter that matches on Metacards with Attributes of type XML that match when evaluating a provided XPath selector.

===== Contextual Operators

[source,java,linenums]
----
FilterBuilder.attribute(attributeName).is().like().text(String contextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().caseSensitiveText(StringcaseSensitiveContextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().fuzzyText(String fuzzySearchPhrase);
----

===== Directly Implementing the Filter (Advanced)
[WARNING]
====
Implementing the Filter interface directly is only for extremely advanced use cases and is highly discouraged.
Instead, use of the ${branding}-specific `FilterBuilder` API is recommended.
====

Developers create a `Filter` object in order to filter or constrain the amount of records returned from a `Source`.
The OGC Filter Specification has several types of filters that can be combined in a tree-like structure to describe the set of metacards that should be returned. 

===== Categories of Filters

* Comparison Operators
* Logical Operators
* Expressions
* Literals
* Functions
* Spatial Operators
* Temporal Operators

===== Units of Measure

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 09-026r1] and http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 04-095], units of measure can be expressed as a URI.
To fulfill that requirement, ${branding} utilizes the Geotools class `org.geotools.styling.UomOgcMapping` for spatial filters requiring a standard for units of measure for scalar distances.
Essentially, the `UomOgcMapping` maps the http://www.opengeospatial.org/standards/symbol[OGC Symbology Encoding] standard URIs to Java Units.
This class provides three options for units of measure: 

* FOOT
* METRE
* PIXEL

${branding} only supports FOOT and METRE since they are the most applicable to scalar distances.

===== Creating Filters

The common way to create a `Filter` is to use the Geotools `FilterFactoryImpl` object, which provides Java implementations for the various types of filters in the Filter Specification.
Examples are the easiest way to understand how to properly create a `Filter` and a `Query`. 

[NOTE]
====
Refer to the http://docs.geotools.org/latest/javadocs/[Geotools javadoc] for more information on `FilterFactoryImpl`.
====

The example below illustrates creating a query, and thus an OGC Filter, that does a case-insensitive search for the phrase "mission" in the entire metacard's text.
Note that the OGC `PropertyIsLike` Filter is used for this simple contextual query.

===== Example Creating-Filters-1 

.Simple Contextual Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar,
and the escapeChar itself

String searchPhrase = "mission" ;
org.opengis.filter.Filter propertyIsLikeFilter =
    filterFactory.like(filterFactory.property(Metacard.ANY_TEXT), searchPhrase, wildcardChar, singleChar, escapeChar, isCaseSensitive);
${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( propertyIsLikeFilter );
----

The example below illustrates creating an absolute temporal query, meaning the query is searching for Metacards whose modified timestamp occurred during a specific time range.
Note that this query uses the `During` OGC Filter for an absolute temporal query.

===== Example Creating-Filters-2

.Absolute Temporal Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
org.opengis.temporal.Instant startInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(start));

org.opengis.temporal.Instant endInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(end));

org.opengis.temporal.Period period =  new org.geotools.temporal.object.DefaultPeriod(startInstant, endInstant);

String property = Metacard.MODIFIED ; // modified date of a metacard

org.opengis.filter.Filter filter = filterFactory.during( filterFactory.property(property), filterFactory.literal(period)  );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl(filter) ;
----

===== Contextual Searches

Most contextual searches can be expressed using the `PropertyIsLike` filter. The special haracters that have meaning in a `PropertyIsLike` filter are the wildcard, single wildcard, and escape characters (see Example Creating-Filters-1).

====== `PropertyIsLike` Special Characters
[cols="2*", options="header"]
|===
|Character
|Description

|Wildcard
|Matches zero or more characters.

|Single Wildcard
|Matches exactly one character.

|Escape
|Escapes the meaning of the Wildcard, Single Wildcard, and the Escape character itself
|===

Characters and words, such as `AND`, `&`, `and`, `OR`, `|`, `or`, `NOT`, `~`, `not`, `{`, and `}`, are treated as literals in a `PropertyIsLike` filter. In order to create equivalent logical queries, a developer must instead use the Logical Operator filters {`AND`, `OR`, `NOT`}. The Logical Operator filters can be combined together with `PropertyIsLike` filters to create a tree that represents the search phrase expression. 

===== Example Creating-Filters-3

.Creating the search phrase "mission and planning"
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;

boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar, and the escapeChar itself

Filter filter =
    filterFactory.and(
       filterFactory.like(filterFactory.property(Metacard.METADATA), "mission" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive),
       filterFactory.like(filterFactory.property(Metacard.METADATA), "planning" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive)
    );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( filter );
----

====== Tree View of Example Creating-Filters-3 

Filters used in ${branding} can always be represented in a tree diagram.

[ditaa,tree1, png,600]
....
+--------------------\
|cEEE /-------\      |
|     |  And  |      |
|     \-+---+-/      |
|       |   |        |
|     +-+   +-+      |
|     |       |      |
|     v       v      |
|/-------\ /--------\|
||mission| |planning||
|\-------/ \--------/|
\--------------------/
....

====== XML View of Example Creating-Filters-3

Another way to view this type of Filter is through an XML model, which is shown below.

.Pseudo XML of Example Creating-Filters-3
[source,xml,linenums]
----
<Filter>
   <And>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>mission</Literal>
      </PropertyIsLike>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>planning</Literal>
      </PropertyIsLike>
   <And>
</Filter>
----

Using the Logical Operators and `PropertyIsLike` filters, a developer can create a whole language of search phrase expressions.

===== Fuzzy Operation 

${branding} only supports one custom function.
The Filter specification does not include a fuzzy operator, so a Filter function was created to represent a fuzzy operation.
The function and class is called `FuzzyFunction`, which is used by clients to notify the Sources to perform a fuzzy search.
The syntax expected by providers is similar to the Fuzzy Function.
Refer to the example below.

[source,java,linenums]
----
String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar

boolean isCaseSensitive = false ;

Filter fuzzyFilter = filterFactory.like(
     new ${ddf-branding}.catalog.impl.filter.FuzzyFunction(
          Arrays.asList((Expression) (filterFactory.property(Metacard.ANY_TEXT))),
          filterFactory.literal("")),
     searchPhrase,
     wildcardChar,
     singleChar,
     escapeChar,
     isCaseSensitive);

QueryImpl query = new QueryImpl(fuzzyFilter);
----

===== Parsing Filters

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specification 04-095]: a "(filter expression) representation can be ... parsed and then transformed into whatever target language is required to retrieve or modify object instances stored in some persistent object store."
Filters can be thought of as the `WHERE` clause for a SQL SELECT statement to "fetch data stored in a SQL-based relational database." 

Sources can parse OGC Filters using the `FilterAdapter` and `FilterDelegate`.
See Developing a Filter Delegate for more details on implementing a new `FilterDelegate`.
This is the preferred way to handle OGC Filters in a consistent manner.

Alternately, `org.opengis.filter.Filter` implementations can be parsed using implementations of the interface `org.opengis.filter.FilterVisitor`. 
The `FilterVisitor` uses the http://www.oodesign.com/visitor-pattern.html[Visitor pattern]. Essentially, `FilterVisitor` instances "visit" each part of the `Filter` tree allowing developers to implement logic to handle the filter's operations. 
Geotools 8 includes implementations of the `FilterVisitor` interface.
The `DefaultFilterVisitor`, as an example, provides only business logic to visit every node in the `Filter` tree.
The `DefaultFilterVisitor` methods are meant to be overwritten with the correct business logic. 
The simplest approach when using `FilterVisitor` instances is to build the appropriate query syntax for a target language as each part of the `Filter` is visited.
For instance, when given an incoming `Filter` object to be evaluated against a RDBMS, a `CatalogProvider instance could use a `FilterVisitor` to interpret each filter operation on the `Filter` object and translate those operations into SQL.
The `FilterVisitor` may be needed to support `Filter` functionality not currently handled by the `FilterAdapter` and `FilterDelegate` reference implementation.

===== Examples

====== Interpreting a Filter to Create SQL

If the `FilterAdapter` encountered or "visited" a `PropertyIsLike` filter with its property assigned as `title` and its literal expression assigned as `mission`, the `FilterDelegate` could create the proper SQL syntax similar to title `LIKE` mission.

.Figure Parsing-Filters1
[ditaa,tree2,png]
....
+-------------------------\
|    /----------------\   |
|    | PropertyIsLike |   |
|    \----------------/   |
| cEEE      |  |          |
|      /----/  \----\     |
|      |            |     |
|      v            v     |
|/----------\  /---------\|
||Property- |  |Literal- ||
|| title    |  | mission ||
|\----------/  \---------/|
\-------------------------/
....

====== Interpreting a Filter to Create XQuery

If the `FilterAdapter` encountered an `OR` filter, such as in Figure Parsing-Filters2 and the target language was XQuery, the `FilterDelegate` could yield an expression such as 

[source]
----
ft:query(//inventory:book/@subject,'math') union
ft:query(//inventory:book/@subject,'science').
----

.Figure Parsing-Filters2
[ditaa, tree3, png]
....
+---------------------------------------------------\
|                       /----\                      |
|  cEEE                 | OR |                      |
|                       \----/                      |
|                        |  |                       |
|             /----------/  \----------\            |
|             |                        |            |
|             v                        v            |
|    /----------------\        /----------------\   |
|    | PropertyIsLike |        | PropertyIsLike |   |
|    \----------------/        \----------------/   |
|           |  |                      |  |          |
|      /----/  \----\            /----/  \----\     |
|      |            |            |            |     |
|      v            v            v            v     |
|/----------\  /---------\  /---------\  /---------\|
||Property- |  |Literal- |  |Property-|  |Literal- ||
|| title    |  | mission |  | Subject |  | science ||
|\----------/  \---------/  \---------/  \---------/|
\---------------------------------------------------/
....


====== FilterAdapter/Delegate Process for Figure Parsing-Filters2

. `FilterAdapter` visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike`method with the LHS property and literal.
. The LHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to the `OR` filter, which visits its second child.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike` method with the RHS property and literal.
. The RHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to its `OR Filter which is now done with its children.
. It then collects the output of each child and sends the list of results to the `FilterDelegate OR` method.
. The final result object will be returned from the `FilterAdapter` adapt method.

====== FilterVisitor Process for Figure Parsing-Filters2

. FilterVisitor visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The LHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to the `OR` filter, which visits its second child.
. The RHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to its `OR` filter, which is now done with its children. It then collects the output of each child and could potentially execute the following code to produce the above expression.

[source,java,linenums]
----
public visit( Or filter, Object data) {
...
   /* the equivalent statement for the OR filter in this domain (XQuery) */
   xQuery = childFilter1Output + " union " + childFilter2Output;
...
}
----

==== Filter Profile

===== Role of the OGC Filter

Both Queries and Subscriptions extend the OGC GeoAPI Filter interface.

The Filter Builder and Adapter do not fully implement the OGC Filter Specification.
The filter support profile contains suggested filter to metacard type mappings.
For example, even though a Source could support a `PropertyIsGreaterThan` filter on `XML_TYPE`, it would not likely be useful.

===== Catalog Filter Profile

====== Metacard Attribute To Type Mapping

The filter profile maps filters to metacard types.
The following table displays the common metacard attributes with their respective types for reference.

[cols="2*", options="header"]
|===

|Metacard Attribute
|Metacard Type

|ANY_DATE
|DATE_TYPE

|ANY_GEO
|GEO_TYPE

|ANY_TEXT
|STRING_TYPE

|CONTENT_TYPE
|STRING_TYPE

|CONTENT_TYPE_VERSION
|STRING_TYPE

|CREATED
|DATE_TYPE

|EFFECTIVE
|DATE_TYPE

|GEOGRAPHY
|GEO_TYPE

|ID
|STRING_TYPE

|METADATA
|XML_TYPE

|MODIFIED
|DATE_TYPE

|RESOURCE_SIZE
|STRING_TYPE

|RESOURCE_URI
|STRING_TYPE

|SOURCE_ID
|STRING_TYPE

|TARGET_NAMESPACE
|STRING_TYPE

|THUMBNAIL
|BINARY_TYPE

|TITLE
|STRING_TYPE

|===

====== Comparison Operators

Comparison operators compare the value associated with a property name with a given Literal value.
Endpoints and sources should try to use metacard types other than the object type.
The object type only supports backwards compatibility with `java.net.URI`.  
Endpoints that send other objects will not be supported by standard sources.
The following table maps the metacard types to supported comparison operators.

[cols="12*", options="header"]
|===

|PropertyIs
|Between
|EqualTo
|GreaterThan
|GreaterThan
|OrEqualTo
|LessThan
|LessThan
|OrEqualTo
|Like
|NotEqualTo
|Null

|BINARY_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|BOOLEAN_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|DATE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|DOUBLE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|FLOAT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

 

|GEO_TYPE
|
|
|
|
|
|
|
|
|
|
|*X*

|INTEGER_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|LONG_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|OBJECT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|SHORT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|STRING_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*

|XML_TYPE
|
|*X*
|
|
|
|
|
|
|*X*
|
|*X*
 
|===

The following table describes each comparison operator.

.Comparison Operators
[cols="2*", options="header"]
|===

|Operator
|Description

|PropertyIsBetween
|Lower <= Property <= Upper

|PropertyIsEqualTo
|Property == Literal

|PropertyIsGreaterThan
|Property > Literal

|PropertyIsGreaterThanOrEqualTo
|Property >= Literal

|PropertyIsLessThan
|Property < Literal

|PropertyIsLessThanOrEqualTo
|Property <= Literal

|PropertyIsLike
|Property LIKE Literal

Equivalent to SQL "like" 

|PropertyIsNotEqualTo
|Property != Literal

|PropertyIsNull
|Property == null

|===

====== Logical Operators
Logical operators apply Boolean logic to one or more child filters.

.Logical Operators
[cols="4*", options="header"]
|===

|
|And
|Not
|Or

|Supported Filters
|*X*
|*X*
|*X*

|===

====== Temporal Operators
Temporal operators compare a date associated with a property name to a given Literal date or date range.
The following table displays the supported temporal operators.

[cols="12*", options="header"]
|===
|
|After
|AnyInteracts
|Before
|Begins
|BegunBy
|During
|EndedBy
|Meets
|MetBy
|OverlappedBy
|TContains

|DATE_TYPE
|*X*
|
|*X*
|
|
|*X*
|
|
|
|
|

|===

The following table describes each temporal operator.
Literal values can be either date instants or date periods.
[cols="2*", options="header"]
|===

|Operator
|Description

|After
|Property > (Literal \|\| Literal.end)

|Before
|Property < (Literal \|\| Literal.start)

|During
|Literal.start < Property < Literal.end

|===

====== Spatial Operators

Spatial operators compare a geometry associated with a property name to a given Literal geometry. 
The following table displays the supported spatial operators.

[cols="11*", options="headers"]
|===

|BBox
|Beyond
|Contains
|Crosses
|Disjoint
|Equals
|DWithin
|Intersects
|Overlaps
|Touches
|Within

|GEO_TYPE
|
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*
|*X*
|

|===

The following table describes each spatial operator.
Geometries are usually represented as Well-Known Text (_WKT_).

[cols="2*", options="header"]
|===

|Operator
|Description

|Beyond
|Property geometries beyond given distance of Literal geometry

|Contains
|Property geometry contains Literal geometry

|Crosses
|Property geometry crosses Literal geometry

|Disjoint
|Property geometry direct positions are not interior to Literal geometry

|DWithin
|Property geometry lies within distance to Literal geometry

|Intersects
|Property geometry intersects Literal geometry; opposite to the Disjoint operator 

|Overlaps
|Property geometry interior somewhere overlaps Literal geometry interior

|Touches
|Property geometry touches but does not overlap Literal geometry

|Within
|Property geometry completely contains Literal geometry

|===

==== Commons-DDF Utilities

The `commons-${ddf-branding}`bundle, located in `<DDF_HOME_SOURCE_DIRECTORY>/common/commons-${ddf-branding}`, provides utilities and functionality commonly used across other ${branding} components, such as the endpoints and providers. 

==== Noteworthy Classes

===== FuzzyFunction

`${ddf-branding}.catalog.impl.filter.FuzzyFunction` class is used to indicate that a `PropertyIsLike` filter should interpret the search as a fuzzy query. 

===== XPathHelper

`${ddf-branding}.util.XPathHelper` provides convenience methods for executing XPath operations on XML.
It also provides convenience methods for converting XML as a `String` from a `org.w3c.dom.Document` object and vice versa.





==== Developing Console Commands

===== Console Commands

${branding} supports development of custom console commands.

${branding} includes custom commands for working with the Catalog, as described in the <<managing.adoc#_console_commands, Managing Console Commands>> section.







==== Developing a Filter Delegate

Filter Delegates help reduce the complexity of parsing OGC Filters.
The reference Filter Adapter implementation contains the necessary boilerplate visitor code and input normalization to handle commonly supported OGC Filters.

===== Creating a New Filter Delegate

A Filter Delegate contains the logic that converts normalized filter input into a form that the targeted data source can handle.
Delegate methods will be called in a depth first order as the Filter Adapter visits filter nodes.

===== Implementing the Filter Delegate

. Create a Java class extending `FilterDelegate`. +
`public class ExampleDelegate extends ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> {`
. `FilterDelegate` will throw an appropriate exception for all methods not implemented.  Refer to the ${branding} JavaDoc for more details about what is expected of each `FilterDelegate` method.

[NOTE]
====
A code example of a Filter Delegate can be found in `${ddf-branding}.catalog.filter.proxy.adapter.test` of the `filter-proxy` bundle.
====

===== Throwing Exceptions

Filter delegate methods can throw `UnsupportedOperationException` run-time exceptions.
The `GeotoolsFilterAdapterImpl` will catch and re-throw these exceptions as `UnsupportedQueryExceptions`.

===== Using the Filter Adapter

The FilterAdapter can be requested from the OSGi registry.

[source,xml]
----
<reference id="filterAdapter" interface="${ddf-branding}.catalog.filter.FilterAdapter" />
----

The Query in a QueryRequest implements the Filter interface.
The Query can be passed to a `FilterAdapter` and `FilterDelegate` to process the Filter.

[source,java,linenums]
----
@Override
public ${ddf-branding}.catalog.operation.QueryResponse query(${ddf-branding}.catalog.operation.QueryRequest queryRequest)
    throws ${ddf-branding}.catalog.source.UnsupportedQueryException {

    ${ddf-branding}.catalog.operation.Query query = queryRequest.getQuery();

    ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> delegate = new ExampleDelegate();

    // ${ddf-branding}.catalog.filter.FilterAdapter adapter injected via Blueprint
    ExampleReturnObjectType result = adapter.adapt(query, delegate);
}
----

Import the ${ddf-catalog} API Filter package and the reference implementation package of the Filter Adapter in the bundle manifest  (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.filter, ${ddf-branding}.catalog.source`

===== Filter Support

Not all OGC Filters are exposed at this time.
If demand for further OGC Filter functionality is requested, it can be added to the Filter Adapter and Delegate so sources can support more complex filters.
The following OGC Filter types are currently available:

[cols="1" options="header"]
|===
|Logical
|And
|Or
|Not
|Include
|Exclude
|===

[cols="1" options="header"]
|===
|Property Comparison
|`PropertyIsBetween`
|`PropertyIsEqualTo`
|`PropertyIsGreaterThan`
|`PropertyIsGreaterThanOrEqualTo`
|`PropertyIsLessThan`
|`PropertyIsLessThanOrEqualTo`
|`PropertyIsLike`
|`PropertyIsNotEqualTo`
|`PropertyIsNull`
|===

[cols="2,5" options="header"]
|===
|`Spatial`
|Definition

|`Beyond`
|True if the geometry being tested is beyond the stated distance of the geometry provided.

|`Contains`
|True if the second geometry is wholly inside the first geometry.

|`Crosses`
|True if the intersection of the two geometries results in a value whose dimension is less than the geometries and the maximum dimension of the intersection value includes points interior to both the geometries, and the intersection value is not equal to either of the geometries.

|`Disjoint`
|True if the two geometries do not touch or intersect.

|`DWithin`
|True if the geometry being tested is within the stated distance of the geometry provided.

|`Intersects`
|True if the two geometries intersect. This is a convenience method as you could always ask for Not Disjoint(A,B) to get the same result.

|`Overlaps`
|True if the intersection of the geometries results in a value of the same dimension as the geometries that is different from both of the geometries.

|`Touches`
|True if and only if the only common points of the two geometries are in the union of the boundaries of the geometries.

|`Within`
|True if the first geometry is wholly inside the second geometry.
|===

[cols="1" options="header"]
|===
|Temporal
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/After.html[After]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/Before.html[Before]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/During.html[During]
|===

