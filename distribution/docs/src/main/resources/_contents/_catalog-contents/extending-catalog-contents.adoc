////
NOTE TO REVIEWERS:
The Content in this file is being migrated to other files. Ignore changes here, as the content has been moved to a new home. A nice farm; upstate.
////
The ${ddf-catalog} provides a framework for storing, searching, processing, and transforming information.
Clients typically perform query, create, read, update, and delete (QCRUD) operations against the Catalog.  
At the core of the Catalog functionality is the Catalog Framework, which routes all requests and responses through the system, invoking additional processing per the system configuration.

This guide supports developers creating extensions of the existing framework.

=== Whitelist

The following packages have been exported by the ${ddf-catalog} application and are approved for use by third parties:

* `${ddf-branding-lowercase}.camel.component.catalog`
* `${ddf-branding-lowercase}.catalog`
* `${ddf-branding-lowercase}.catalog.cache`
* `${ddf-branding-lowercase}.catalog.data`
* `${ddf-branding-lowercase}.catalog.data.metacardtype`
* `${ddf-branding-lowercase}.catalog.event`
* `${ddf-branding-lowercase}.catalog.federation`
* `${ddf-branding-lowercase}.catalog.federation.impl`
* `${ddf-branding-lowercase}.catalog.filter`
* `${ddf-branding-lowercase}.catalog.filter.delegate`
* `${ddf-branding-lowercase}.catalog.impl.filter`
* `${ddf-branding-lowercase}.catalog.operation`
* `${ddf-branding-lowercase}.catalog.plugin`
* `${ddf-branding-lowercase}.catalog.plugin.groomer`
* `${ddf-branding-lowercase}.catalog.pubsub`
* `${ddf-branding-lowercase}.catalog.pubsub.tracker`
* `${ddf-branding-lowercase}.catalog.resource`
* `${ddf-branding-lowercase}.catalog.resource.data`
* `${ddf-branding-lowercase}.catalog.resource.impl`
* `${ddf-branding-lowercase}.catalog.resourceretriever`
* `${ddf-branding-lowercase}.catalog.service`
* `${ddf-branding-lowercase}.catalog.source`
* `${ddf-branding-lowercase}.catalog.transform`
* `${ddf-branding-lowercase}.catalog.transformer.api`
* `${ddf-branding-lowercase}.catalog.transformer.metacard.geojson`
* `${ddf-branding-lowercase}.catalog.util`
* `${ddf-branding-lowercase}.catalog.validation`
* `${ddf-branding-lowercase}.common`
* `${ddf-branding-lowercase}.geo.formatter`
* `${ddf-branding-lowercase}.util`
* `org.codice.${ddf-branding-lowercase}.endpoints`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest.action`
* `org.codice.${ddf-branding-lowercase}.opensearch.query`
* `org.codice.${ddf-branding-lowercase}.opensearch.query.filter`




=

==== CatalogProvider





==== Plugins

Plugins are additional tools to use to add additional business logic at certain points, depending on the type of plugin.
Plugins can be designed to run before or after certain processes.
They are often used for validation, optimization, or logging.

===== "Pre-" Plugins

These plugins are executed before an action is taken.
[cols="2*", options="header"]
|===

|Plugin
|Description

|Pre-IngestPlugin
|Performs any changes to a resource prior to ingesting it.

|Pre-Query Plugin
|Performs any changes to query before executing.

|Pre-Resource Plugin
|Performs any changes to a resource associated with a metacard prior to download.

|Pre-Subscription Plugin 
|Performs any changes before creating a subscription.

|Pre-Delivery Plugin
|Performs any changes before delivered a subscribed event.

|===

===== “Post-“ Plugins

[cols="2*", options="header"]
|===

|Plugin
|Description

|Post-Ingest Plugin
|Performs actions after ingest is completed.

|Post-Query Plugin
|Performs any changes to response after query completes.

|Post-Get Resource Plugin   
|performs any changes to a resource after download

|===

==== Transformers


[cols="2*", options="header"]
|===

|Transformer
|Description

|Input Transformers
|create metacards from input.

|Metacard Transformers
|translates a metacard from catalog metadata to a specific data format.

|Query Response Transformers
|translates a list of Result objects to a desired format.

|===

=== Catalog Development Fundamentals

This section introduces the fundamentals of working with the Catalog API the OGC Filter for Queries.

==== Simple Catalog API Implementations

The Catalog API implementations, which are denoted with the suffix of `Impl` on the Java file names, have multiple purposes and uses.

* First, they provide a good starting point for other developers to extend functionality in the framework. For instance, extending the `MetacardImpl` allows developers to focus less on the inner workings of ${branding} and more on the developer's intended purposes and objectives. 

* Second, the Catalog API Implementations display the proper usage of an interface and an interface's intentions. Also, they are good code examples for future implementations. If a developer does not want to extend the simple implementations, the developer can at least have a working code reference to base future development.

==== Use of the Whiteboard Design Pattern

The ${ddf-catalog} makes extensive use of the Whiteboard Design Pattern.
Catalog Components are registered as services in the OSGi Service Registry, and the Catalog Framework or any other clients tracking the OSGi Service Registry are automatically notified by the OSGi Framework of additions and removals of relevant services.

The Whiteboard Design Pattern is a common OSGi technique that is derived from a technical whitepaper provided by the OSGi Alliance in 2004.
It is recommended to use the Whiteboard pattern over the Listener pattern in OSGi because it provides less complexity in code (both on the client and server sides), fewer deadlock possibilities than the Listener pattern, and closely models the intended usage of the OSGi framework.

==== Working with Queries

Clients use `${ddf-branding}.catalog.operation.Query` objects to describe which metacards are needed from Sources. 
Query objects have two major components:

* Filter 
* Query Options

A Source uses the Filter criteria constraints to find the requested set of metacards within its domain of metacards.
The Query Options are used to further restrict the Filter's set of requested metacards.

===== Query Options
[cols="2*", options="header"]
|===
|Option
|Description

|`StartIndex`
|1-based index that states which metacard the Source should return first out of the requested metacards.

|`PageSize`
|Represents the maximum amount of metacards the Source should return.

|`SortBy`
|Determines how the results are sorted and on which property.

|`RequestsTotalResultsCount`
|Determines whether the total number of results should be returned.

|`TimeoutMillis`
|The amount of time in milliseconds before the query is to be abandoned.

|===

===== Creating a query

The easiest way to create a Query is to use `${ddf-branding}.catalog.operation.QueryImpl` object.
It is first necessary to create an OGC Filter object then set the Query Options after `QueryImpl` has been constructed.

.QueryImpl Example 1
[source,java,linenums]
----
/*
  Builds a query that requests a total results count and
  that the first record to be returned is the second record found from
  the requested set of metacards.
 */

 String property = ...;

 String value = ...;

 org.geotools.filter.FilterFactoryImpl filterFactory = new FilterFactoryImpl() ;

 QueryImpl query = new QueryImpl( filterFactory.equals(filterFactory.property(property),

filterFactory.literal(value))) ;

 query.setStartIndex(2) ;

 query.setRequestsTotalResultsCount(true);
----

===== Evaluating a query

Every Source must be able to evaluate a Query object.
Nevertheless, each Source could evaluate the Query differently depending on what that Source supports as to properties and query capabilities.
For instance, a common property all Sources understand is id, but a Source could possibly store frequency values under the property name "frequency."
Some Sources may not support frequency property inquiries and will
throw an error stating it cannot interpret the property.
In addition, some Sources might be able to handle spatial operations, while others might not.
A developer should consult a Source's documentation for the limitations, capabilities, and properties that a Source can support.

=== Working with Filters

An OGC Filter is a Open Geospatial Consortium (OGC) standard (
http://www.opengeospatial.org/standards/filter
) that describes a query expression
in terms of Extensible Markup Language (XML) and key-value pairs (KVP). The ${ddf-catalog} Framework does not use the XML representation of
the OGC Filter standard. ${branding} instead utilizes the Java implementation provided by Geotools (
http://geotools.org/
). Geotools provides Java
equivalent classes for OGC Filter XML elements. Geotools originally provided the standard Java classes for the OGC Filter Encoding 1.0 under the
package name 
`org.opengis.filter`. The same package name is used today and is currently used by ${branding}.  Java developers do not parse or
view the XML representation of a 
Filter
 in ${branding}. Instead, developers use only the Java objects to complete query tasks.

Note that the ${ddf-branding}.catalog.operation.Query interface extends the org.opengis.filter.Filter interface, which means that a Query object is an OGC Java Filter with Query Options.

.A Query is an OGC Filter
[source,java]
----
public interface Query extends Filter
----

==== Using Filters

==== FilterBuilder API

To abstract developers from the complexities of working with the Filter interface directly and implementing the ${branding} Profile of the Filter specification, the ${ddf-catalog} includes an API, primarily in `${ddf-branding}.filter`, to build Filters using a fluent API.

To use the FilterBuilder API, an instance of `${ddf-branding}.filter.FilterBuilder` should be used via the OSGi registry.
Typically, this will be injected via a dependency injection framework.
Once an instance of `FilterBuilder` is available, methods can be called to create and combine Filters.

[TIP]
====
The fluent API is best accessed using an IDE that supports code-completion.  For additional details, refer to the Catalog API Javadoc.
====

==== Boolean Operators

`FilterBuilder.allOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean AND), either from a List or Array of Filter instances.

`FilterBuilder.anyOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean OR), either from a List or Array of Filter instances.

`FilterBuilder.not(Filter filter)`:: creates a new Filter that requires the provided Filter must not be match (Boolean NOT).

===== Attribute

`FilterBuilder.attribute(String attributeName)`:: begins a fluent API for creating an Attribute-based Filter, i.e., a Filter that matches on Metacards with Attributes of a particular value.

===== XPath

`FilterBuilder.xpath(String xpath)`:: begins a fluent API for creating an XPath-based Filter, i.e., a Filter that matches on Metacards with Attributes of type XML that match when evaluating a provided XPath selector.

===== Contextual Operators

[source,java,linenums]
----
FilterBuilder.attribute(attributeName).is().like().text(String contextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().caseSensitiveText(StringcaseSensitiveContextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().fuzzyText(String fuzzySearchPhrase);
----

===== Directly Implementing the Filter (Advanced)
[WARNING]
====
Implementing the Filter interface directly is only for extremely advanced use cases and is highly discouraged.
Instead, use of the ${branding}-specific `FilterBuilder` API is recommended.
====

Developers create a `Filter` object in order to filter or constrain the amount of records returned from a `Source`.
The OGC Filter Specification has several types of filters that can be combined in a tree-like structure to describe the set of metacards that should be returned. 

===== Categories of Filters

* Comparison Operators
* Logical Operators
* Expressions
* Literals
* Functions
* Spatial Operators
* Temporal Operators

===== Units of Measure

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 09-026r1] and http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 04-095], units of measure can be expressed as a URI.
To fulfill that requirement, ${branding} utilizes the Geotools class `org.geotools.styling.UomOgcMapping` for spatial filters requiring a standard for units of measure for scalar distances.
Essentially, the `UomOgcMapping` maps the http://www.opengeospatial.org/standards/symbol[OGC Symbology Encoding] standard URIs to Java Units.
This class provides three options for units of measure: 

* FOOT
* METRE
* PIXEL

${branding} only supports FOOT and METRE since they are the most applicable to scalar distances.

===== Creating Filters

The common way to create a `Filter` is to use the Geotools `FilterFactoryImpl` object, which provides Java implementations for the various types of filters in the Filter Specification.
Examples are the easiest way to understand how to properly create a `Filter` and a `Query`. 

[NOTE]
====
Refer to the http://docs.geotools.org/latest/javadocs/[Geotools javadoc] for more information on `FilterFactoryImpl`.
====

The example below illustrates creating a query, and thus an OGC Filter, that does a case-insensitive search for the phrase "mission" in the entire metacard's text.
Note that the OGC `PropertyIsLike` Filter is used for this simple contextual query.

===== Example Creating-Filters-1 

.Simple Contextual Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar,
and the escapeChar itself

String searchPhrase = "mission" ;
org.opengis.filter.Filter propertyIsLikeFilter =
    filterFactory.like(filterFactory.property(Metacard.ANY_TEXT), searchPhrase, wildcardChar, singleChar, escapeChar, isCaseSensitive);
${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( propertyIsLikeFilter );
----

The example below illustrates creating an absolute temporal query, meaning the query is searching for Metacards whose modified timestamp occurred during a specific time range.
Note that this query uses the `During` OGC Filter for an absolute temporal query.

===== Example Creating-Filters-2

.Absolute Temporal Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
org.opengis.temporal.Instant startInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(start));

org.opengis.temporal.Instant endInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(end));

org.opengis.temporal.Period period =  new org.geotools.temporal.object.DefaultPeriod(startInstant, endInstant);

String property = Metacard.MODIFIED ; // modified date of a metacard

org.opengis.filter.Filter filter = filterFactory.during( filterFactory.property(property), filterFactory.literal(period)  );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl(filter) ;
----

===== Contextual Searches

Most contextual searches can be expressed using the `PropertyIsLike` filter. The special haracters that have meaning in a `PropertyIsLike` filter are the wildcard, single wildcard, and escape characters (see Example Creating-Filters-1).

====== `PropertyIsLike` Special Characters
[cols="2*", options="header"]
|===
|Character
|Description

|Wildcard
|Matches zero or more characters.

|Single Wildcard
|Matches exactly one character.

|Escape
|Escapes the meaning of the Wildcard, Single Wildcard, and the Escape character itself
|===

Characters and words, such as `AND`, `&`, `and`, `OR`, `|`, `or`, `NOT`, `~`, `not`, `{`, and `}`, are treated as literals in a `PropertyIsLike` filter. In order to create equivalent logical queries, a developer must instead use the Logical Operator filters {`AND`, `OR`, `NOT`}. The Logical Operator filters can be combined together with `PropertyIsLike` filters to create a tree that represents the search phrase expression. 

===== Example Creating-Filters-3

.Creating the search phrase "mission and planning"
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;

boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar, and the escapeChar itself

Filter filter =
    filterFactory.and(
       filterFactory.like(filterFactory.property(Metacard.METADATA), "mission" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive),
       filterFactory.like(filterFactory.property(Metacard.METADATA), "planning" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive)
    );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( filter );
----

====== Tree View of Example Creating-Filters-3 

Filters used in ${branding} can always be represented in a tree diagram.

[ditaa,tree1, png,600]
....
+--------------------\
|cEEE /-------\      |
|     |  And  |      |
|     \-+---+-/      |
|       |   |        |
|     +-+   +-+      |
|     |       |      |
|     v       v      |
|/-------\ /--------\|
||mission| |planning||
|\-------/ \--------/|
\--------------------/
....

====== XML View of Example Creating-Filters-3

Another way to view this type of Filter is through an XML model, which is shown below.

.Pseudo XML of Example Creating-Filters-3
[source,xml,linenums]
----
<Filter>
   <And>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>mission</Literal>
      </PropertyIsLike>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>planning</Literal>
      </PropertyIsLike>
   <And>
</Filter>
----

Using the Logical Operators and `PropertyIsLike` filters, a developer can create a whole language of search phrase expressions.

===== Fuzzy Operation 

${branding} only supports one custom function.
The Filter specification does not include a fuzzy operator, so a Filter function was created to represent a fuzzy operation.
The function and class is called `FuzzyFunction`, which is used by clients to notify the Sources to perform a fuzzy search.
The syntax expected by providers is similar to the Fuzzy Function.
Refer to the example below.

[source,java,linenums]
----
String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar

boolean isCaseSensitive = false ;

Filter fuzzyFilter = filterFactory.like(
     new ${ddf-branding}.catalog.impl.filter.FuzzyFunction(
          Arrays.asList((Expression) (filterFactory.property(Metacard.ANY_TEXT))),
          filterFactory.literal("")),
     searchPhrase,
     wildcardChar,
     singleChar,
     escapeChar,
     isCaseSensitive);

QueryImpl query = new QueryImpl(fuzzyFilter);
----

===== Parsing Filters

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specification 04-095]: a "(filter expression) representation can be ... parsed and then transformed into whatever target language is required to retrieve or modify object instances stored in some persistent object store."
Filters can be thought of as the `WHERE` clause for a SQL SELECT statement to "fetch data stored in a SQL-based relational database." 

Sources can parse OGC Filters using the `FilterAdapter` and `FilterDelegate`.
See Developing a Filter Delegate for more details on implementing a new `FilterDelegate`.
This is the preferred way to handle OGC Filters in a consistent manner.

Alternately, `org.opengis.filter.Filter` implementations can be parsed using implementations of the interface `org.opengis.filter.FilterVisitor`. 
The `FilterVisitor` uses the http://www.oodesign.com/visitor-pattern.html[Visitor pattern]. Essentially, `FilterVisitor` instances "visit" each part of the `Filter` tree allowing developers to implement logic to handle the filter's operations. 
Geotools 8 includes implementations of the `FilterVisitor` interface.
The `DefaultFilterVisitor`, as an example, provides only business logic to visit every node in the `Filter` tree.
The `DefaultFilterVisitor` methods are meant to be overwritten with the correct business logic. 
The simplest approach when using `FilterVisitor` instances is to build the appropriate query syntax for a target language as each part of the `Filter` is visited.
For instance, when given an incoming `Filter` object to be evaluated against a RDBMS, a `CatalogProvider instance could use a `FilterVisitor` to interpret each filter operation on the `Filter` object and translate those operations into SQL.
The `FilterVisitor` may be needed to support `Filter` functionality not currently handled by the `FilterAdapter` and `FilterDelegate` reference implementation.

===== Examples

====== Interpreting a Filter to Create SQL

If the `FilterAdapter` encountered or "visited" a `PropertyIsLike` filter with its property assigned as `title` and its literal expression assigned as `mission`, the `FilterDelegate` could create the proper SQL syntax similar to title `LIKE` mission.

.Figure Parsing-Filters1
[ditaa,tree2,png]
....
+-------------------------\
|    /----------------\   |
|    | PropertyIsLike |   |
|    \----------------/   |
| cEEE      |  |          |
|      /----/  \----\     |
|      |            |     |
|      v            v     |
|/----------\  /---------\|
||Property- |  |Literal- ||
|| title    |  | mission ||
|\----------/  \---------/|
\-------------------------/
....

====== Interpreting a Filter to Create XQuery

If the `FilterAdapter` encountered an `OR` filter, such as in Figure Parsing-Filters2 and the target language was XQuery, the `FilterDelegate` could yield an expression such as 

[source]
----
ft:query(//inventory:book/@subject,'math') union
ft:query(//inventory:book/@subject,'science').
----

.Figure Parsing-Filters2
[ditaa, tree3, png]
....
+---------------------------------------------------\
|                       /----\                      |
|  cEEE                 | OR |                      |
|                       \----/                      |
|                        |  |                       |
|             /----------/  \----------\            |
|             |                        |            |
|             v                        v            |
|    /----------------\        /----------------\   |
|    | PropertyIsLike |        | PropertyIsLike |   |
|    \----------------/        \----------------/   |
|           |  |                      |  |          |
|      /----/  \----\            /----/  \----\     |
|      |            |            |            |     |
|      v            v            v            v     |
|/----------\  /---------\  /---------\  /---------\|
||Property- |  |Literal- |  |Property-|  |Literal- ||
|| title    |  | mission |  | Subject |  | science ||
|\----------/  \---------/  \---------/  \---------/|
\---------------------------------------------------/
....


====== FilterAdapter/Delegate Process for Figure Parsing-Filters2

. `FilterAdapter` visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike`method with the LHS property and literal.
. The LHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to the `OR` filter, which visits its second child.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike` method with the RHS property and literal.
. The RHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to its `OR Filter which is now done with its children.
. It then collects the output of each child and sends the list of results to the `FilterDelegate OR` method.
. The final result object will be returned from the `FilterAdapter` adapt method.

====== FilterVisitor Process for Figure Parsing-Filters2

. FilterVisitor visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The LHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to the `OR` filter, which visits its second child.
. The RHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to its `OR` filter, which is now done with its children. It then collects the output of each child and could potentially execute the following code to produce the above expression.

[source,java,linenums]
----
public visit( Or filter, Object data) {
...
   /* the equivalent statement for the OR filter in this domain (XQuery) */
   xQuery = childFilter1Output + " union " + childFilter2Output;
...
}
----

==== Filter Profile

===== Role of the OGC Filter

Both Queries and Subscriptions extend the OGC GeoAPI Filter interface.

The Filter Builder and Adapter do not fully implement the OGC Filter Specification.
The filter support profile contains suggested filter to metacard type mappings.
For example, even though a Source could support a `PropertyIsGreaterThan` filter on `XML_TYPE`, it would not likely be useful.

===== Catalog Filter Profile

====== Metacard Attribute To Type Mapping

The filter profile maps filters to metacard types.
The following table displays the common metacard attributes with their respective types for reference.

[cols="2*", options="header"]
|===

|Metacard Attribute
|Metacard Type

|ANY_DATE
|DATE_TYPE

|ANY_GEO
|GEO_TYPE

|ANY_TEXT
|STRING_TYPE

|CONTENT_TYPE
|STRING_TYPE

|CONTENT_TYPE_VERSION
|STRING_TYPE

|CREATED
|DATE_TYPE

|EFFECTIVE
|DATE_TYPE

|GEOGRAPHY
|GEO_TYPE

|ID
|STRING_TYPE

|METADATA
|XML_TYPE

|MODIFIED
|DATE_TYPE

|RESOURCE_SIZE
|STRING_TYPE

|RESOURCE_URI
|STRING_TYPE

|SOURCE_ID
|STRING_TYPE

|TARGET_NAMESPACE
|STRING_TYPE

|THUMBNAIL
|BINARY_TYPE

|TITLE
|STRING_TYPE

|===

====== Comparison Operators

Comparison operators compare the value associated with a property name with a given Literal value.
Endpoints and sources should try to use metacard types other than the object type.
The object type only supports backwards compatibility with `java.net.URI`.  
Endpoints that send other objects will not be supported by standard sources.
The following table maps the metacard types to supported comparison operators.

[cols="12*", options="header"]
|===

|PropertyIs
|Between
|EqualTo
|GreaterThan
|GreaterThan
|OrEqualTo
|LessThan
|LessThan
|OrEqualTo
|Like
|NotEqualTo
|Null

|BINARY_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|BOOLEAN_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|DATE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|DOUBLE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|FLOAT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

 

|GEO_TYPE
|
|
|
|
|
|
|
|
|
|
|*X*

|INTEGER_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|LONG_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|OBJECT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|SHORT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|STRING_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*

|XML_TYPE
|
|*X*
|
|
|
|
|
|
|*X*
|
|*X*
 
|===

The following table describes each comparison operator.

.Comparison Operators
[cols="2*", options="header"]
|===

|Operator
|Description

|PropertyIsBetween
|Lower <= Property <= Upper

|PropertyIsEqualTo
|Property == Literal

|PropertyIsGreaterThan
|Property > Literal

|PropertyIsGreaterThanOrEqualTo
|Property >= Literal

|PropertyIsLessThan
|Property < Literal

|PropertyIsLessThanOrEqualTo
|Property <= Literal

|PropertyIsLike
|Property LIKE Literal

Equivalent to SQL "like" 

|PropertyIsNotEqualTo
|Property != Literal

|PropertyIsNull
|Property == null

|===

====== Logical Operators
Logical operators apply Boolean logic to one or more child filters.

.Logical Operators
[cols="4*", options="header"]
|===

|
|And
|Not
|Or

|Supported Filters
|*X*
|*X*
|*X*

|===

====== Temporal Operators
Temporal operators compare a date associated with a property name to a given Literal date or date range.
The following table displays the supported temporal operators.

[cols="12*", options="header"]
|===
|
|After
|AnyInteracts
|Before
|Begins
|BegunBy
|During
|EndedBy
|Meets
|MetBy
|OverlappedBy
|TContains

|DATE_TYPE
|*X*
|
|*X*
|
|
|*X*
|
|
|
|
|

|===

The following table describes each temporal operator.
Literal values can be either date instants or date periods.
[cols="2*", options="header"]
|===

|Operator
|Description

|After
|Property > (Literal \|\| Literal.end)

|Before
|Property < (Literal \|\| Literal.start)

|During
|Literal.start < Property < Literal.end

|===

====== Spatial Operators

Spatial operators compare a geometry associated with a property name to a given Literal geometry. 
The following table displays the supported spatial operators.

[cols="11*", options="headers"]
|===

|BBox
|Beyond
|Contains
|Crosses
|Disjoint
|Equals
|DWithin
|Intersects
|Overlaps
|Touches
|Within

|GEO_TYPE
|
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*
|*X*
|

|===

The following table describes each spatial operator.
Geometries are usually represented as Well-Known Text (_WKT_).

[cols="2*", options="header"]
|===

|Operator
|Description

|Beyond
|Property geometries beyond given distance of Literal geometry

|Contains
|Property geometry contains Literal geometry

|Crosses
|Property geometry crosses Literal geometry

|Disjoint
|Property geometry direct positions are not interior to Literal geometry

|DWithin
|Property geometry lies within distance to Literal geometry

|Intersects
|Property geometry intersects Literal geometry; opposite to the Disjoint operator 

|Overlaps
|Property geometry interior somewhere overlaps Literal geometry interior

|Touches
|Property geometry touches but does not overlap Literal geometry

|Within
|Property geometry completely contains Literal geometry

|===

==== Commons-DDF Utilities

The `commons-${ddf-branding}`bundle, located in `<DDF_HOME_SOURCE_DIRECTORY>/common/commons-${ddf-branding}`, provides utilities and functionality commonly used across other ${branding} components, such as the endpoints and providers. 

==== Noteworthy Classes

===== FuzzyFunction

`${ddf-branding}.catalog.impl.filter.FuzzyFunction` class is used to indicate that a `PropertyIsLike` filter should interpret the search as a fuzzy query. 

===== XPathHelper

`${ddf-branding}.util.XPathHelper` provides convenience methods for executing XPath operations on XML.
It also provides convenience methods for converting XML as a `String` from a `org.w3c.dom.Document` object and vice versa.

=== Extending Catalog Plugins

The Catalog Framework calls Catalog Plugins to process requests and responses as they enter and leave the Framework. 

[ditaa, catalog_architecture_plugins, png,${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||c369           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Existing Plugins

===== Pre-Ingest Plugin

.Ingest Plugin Flow
[ditaa,ingest-plugin-flow,png, ${image-width}]
....
/------\
|Client|
|cDEF  |
\------/
    ^
    |
+-------------------------------------------\
|DDF|                                  cCCC |
|   v                                       |
|/--------\   /-----------------\   /------\|
||Endpoint|<->|Catalog Framework|<->|Source||
|| cDEF   |   | cDEF            |   | cDEF ||
|\--------/   \-----------------/   \------/|
|                     | |                   |
|          /----------/ \--------\          |
|          |                     |          |
|          v                     v          |
|/------------------\  /-------------------\|
||PreIngest Plugins |  |PostIngest Plugins ||
|| cDEF             |  | cDEF              ||
|\------------------/  \-------------------/|
\-------------------------------------------/
....

===== Using

Pre-Ingest plugins are invoked before an ingest operation is sent to the catalog.
They are not run on a query.
This is an opportunity to take any action on the ingest request, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-Ingest plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 

The output of a Pre-Ingest plugin is sent to the next Pre-Ingest plugin, until all have executed and the ingest operation is sent to the requested Source.

===== Metacard Groomer

The Metacard Groomer Pre-Ingest plugin makes modifications to `CreateRequest` and `UpdateRequest` metacards.

This plugin makes the following modifications when metacards are in a `CreateRequest`:

* Overwrites the `Metacard.ID` field with a generated, unique, 32 character hexadecimal value
* Overwrites the `Metacard.CREATED` date with a current time stamp
* Overwrites the `Metacard.MODIFIED` date with a current time stamp

The plugin also makes the following modifications when metacards are in an `UpdateRequest`:

* If no value is provided for `Metacard.ID` in the new metacard, it will be set using the `UpdateRequest` ID if applicable.
* If no value is provided, sets the `Metacard.CREATED` date with the `Metacard.MODIFIED` date so that the `Metacard.CREATED` date is not null.
* Overwrites the `Metacard.MODIFIED` date with a current time stamp.

====== Installing and UnInstalling

This plugin can be installed and uninstalled using the normal processes described in the Configuring ${branding} section.

====== Configuring

No configuration is necessary for this plugin. 

====== Using

Use this pre-ingest plugin as a convenience to apply basic rules for your metacards. 

====== Known Issues

None

===== Metacard Validity Marker

The Metacard Validity Marker Pre-Ingest plugin modifies the metacards contained in `CreateRequest`s and `UpdateRequest`s.

The plugin runs each metacard in the `CreateRequest` and `UpdateRequest` against each registered `MetacardValidator` service.

[NOTE]
====
This plugin can make it seem like ingested products are not successfully ingested.
If after ingesting, the ingest did not fail and there are no errors in the ingest log, but the expected results do not show up after a query,
verify either that the ingested data is valid or that the <<catalogFederationStrategy, Catalog Federation Strategy>> is configured to show warnings and/or errors.
====


====== Installing and Uninstalling

This plugin can be installed and uninstalled using the normal processes described in the Configuring ${branding} section.

====== Configuring

No configuration is necessary for this plugin. 
By default, it will mark metacards with validation errors and warnings as they are reported by each metacard validator and then allow the ingest.
To prevent the ingest of certain invalid metacards, the `Metacard Validity Marker` plugin can be configured to "enforce" one or more validators.
Metacards that are invalid according to an "enforced" validator will not be ingested.

====== Using

Use this pre-ingest plugin to validate metacards against metacard validators, which can check schemas, schematron, or any other logic. 

====== Known Issues

None

===== Post-Ingest Plugin

====== Using

Post-ingest plugins are invoked after data has been created, updated, or deleted in a Catalog Provider.

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.

====== Invocation

Because the event has already occurred and changes from one post-ingest plugin cannot affect others, all Post-Ingest plugins are invoked in parallel and no priority is enforced.

.QueryPlugin Flow
[ditaa,query-plugin-flow,png]
....
/------\
|Client|
|cDEF  |
\------/
    ^
    |
+-------------------------------------------\
|DDF|                                  cCCC |
|   v                                       |
|/--------\   /-----------------\   /------\|
||Endpoint|<->|Catalog Framework|<->|Source||
|| cDEF   |   | cDEF            |   | cDEF ||
|\--------/   \-----------------/   \------/|
|                     | |                   |
|          /----------/ \--------\          |
|          |                     |          |
|          v                     v          |
|/------------------\  /-------------------\|
|| PreQuery Plugins |  | PostQuery Plugins ||
||  cDEF            |  |  cDEF             ||
|\------------------/  \-------------------/|
\-------------------------------------------/
....

===== Pre-Query Plugin

====== Using

Pre-query plugins are invoked before a query operation is sent to any of the Sources. 
This is an opportunity to take any action on the query, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-query plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 
The output of a pre-query plugin is sent to the next pre-query plugin, until all have executed and the query operation is sent to the requested Source.

===== Post-Query Plugin

====== Using

Post-query plugins are invoked after a query has been executed successfully, but before the response is returned to the endpoint. 
This is an opportunity to take any action on the query response, including but not limited to:

* logging
* auditing
* security filtering/redaction
* deduplication

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Post-query plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 
The output of the first plugin is sent to the next plugin, until all have executed and the response is returned to the requesting endpoint.

==== Metacard Resource Size Plugin

This post-query plugin updates the resource size attribute of each metacard in the query results if there is a cached file for the product and it has a size greater than zero; otherwise, the resource size is unmodified and the original result is returned.

====== Installing and UnInstalling
This feature can be installed and uninstalled using the normal processes described in the Configuring ${branding} section.

====== Configuring
No configuration is necessary for this plugin. 

====== Using
Use this post-query plugin as a convenience to return query results with accurate resource sizes for cached products. 

====== Known Issues
None

==== Other Types of Plugins

===== Pre-Get Resource Plugin

====== Using
Pre-get resource plugins are invoked before a request to retrieve a resource is sent to a Source. 
This is an opportunity to take any action on the request, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled. 
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-get resource plugins are invoked serially, prioritized by descending OSGi service ranking. 
That is, the plugin with the highest service ranking will be executed first. 

The output of the first plugin is sent to the next plugin, until all have executed and the request is sent to the targeted Source.

===== Post-Get Resource Plugin

====== Using

Post-get resource plugins are invoked after a resource has been retrieved, but before it is returned to the endpoint. 
This is an opportunity to take any action on the response, including but not limited to:

* logging
* auditing
* security filtering/redaction

===== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown. 
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Post-get resource plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 

The output of the first plugin is sent to the next plugin, until all have executed and the response is returned to the requesting endpoint.

===== Pre-Subscription Plugin

====== Using

Pre-subscription plugins are invoked before a Subscription is activated by an Event Processor. 
This is an opportunity to take any action on the Subscription, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

===== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

===== Invocation

Pre-subscription plugins are invoked serially, prioritized by descending OSGi service ranking. 
That is, the plugin with the highest service ranking will be executed first. 

The output of a pre-subscription plugin is sent to the next pre-subscription plugin, until all have executed and the create Subscription operation is sent to the Event Processor.

====== Examples

${branding} includes a pre-subscription plugin example in the SDK that illustrates how to modify a subscription's filter.
This example is located in the ${branding} trunk at `sdk/sample-plugins/${ddf-branding}/sdk/plugin/presubscription`.

===== Pre-Delivery Plugin

====== Using

Pre-delivery plugins are invoked before a Delivery Method is invoked on a Subscription. 
This is an opportunity to take any action before notification, including but not limited to:

* logging
* auditing
* security filtering/redaction

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-delivery plugins are invoked serially, prioritized by descending OSGi service ranking.
The plugin with the highest service ranking will be executed first. 

The output of a pre-delivery plugin is sent to the next pre-delivery plugin, until all have executed and the Delivery Method is invoked on the associated Subscription.

==== Developing a Catalog Plugin

==== Policy Plugin

===== Using

Policy plugins are invoked before all other plugin types to set up the policy for a request/response.  This provides an opportunity to attach custom requirements on operations or individual metacards.
All the 'requirements' from each Policy plugin will be combined into a single policy that will be included in the request/response. Access plugins will be used to act on this combined policy.

===== Failure Behavior

All failure cases should be handled internally to the plugin with the exception of the StopProcessingException. If the exception encountered should stop/block the request then a StopProcessingException should be thrown.

==== Access Plugin

===== Using

Access plugins are invoked directly after the Policy plugins have been successfully executed.  This is an opportunity to either stop processing or modify the request/response based on policy information.

===== Failure Behavior

All failure cases should be handled internally to the plugin with the exception of the StopProcessingException. If the exception encountered should stop/block the request then a StopProcessingException should be thrown.

==== Developing a Catalog Plugin

Plugins extend the functionality of the Catalog Framework by performing actions at specified times during a transaction. 
Plugins can be _Pre-Ingest_, _Post-Ingest_, _Pre-Query_, _Post-Query_, _Pre-Subscription_, _Pre-Delivery_, _Pre-Resource_, or _Post-Resource_. 
By implementing these interfaces, actions can be performed at the desired time. 

===== Create New Plugins

====== Implement Plugin Interface

The following types of plugins can be created:

[cols="4*", options="header"]
|===

|Plugin Type
|Plugin Interface
|Description
|Example

|Pre-Ingest
|`${ddf-branding}.catalog.plugin.PreIngestPlugin`
|Runs before the Create/Update/Delete method is sent to the CatalogProvider
|Metadata validation services

|Post-Ingest
|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|Runs after the Create/Update/Delete method is sent to the CatalogProvider
|EventProcessor for processing and publishing event notifications to subscribers

|Pre-Query
|`${ddf-branding}.catalog.plugin.PreQueryPlugin`
|Runs prior to the Query/Read method being sent to the Source
|An example is not included with ${branding}

|Post-Query
|`${ddf-branding}.catalog.plugin.PostQueryPlugin`
|Runs after results have been retrieved from the query but before they are posted to the Endpoint
|An example is not included with ${branding}

|Pre-Subscription
|`${ddf-branding}.catalog.plugin.PreSubscription`
|Runs prior to a Subscription being created or updated
|Modify a query prior to creating a subscription

|Pre-Delivery
|`${ddf-branding}.catalog.plugin.PreDeliveryPlugin`
|Runs prior to the delivery of a Metacard when an event is posted
|Inspect a metacard prior to delivering it to the Event Consumer

|Pre-Resource
|`${ddf-branding}.catalog.plugin.PreResource`
|Runs prior to a Resource being retrieved
|An example is not included with ${branding}

|Post-Resource
|`${ddf-branding}.catalog.plugin.PostResource`
|Runs after a Resource is retrieved, but before it is sent to the Endpoint
|Verification of a resource prior to returning to a client

|Policy
|${ddf-branding}.catalog.plugin.PolicyPlugin
|Runs prior to all other catalog plugins to esablish the policy for requests/responses
|An example is MetacardValidityFilterPlugin

|Access
|${ddf-branding}.catalog.plugin.AccessPlugin
|Runs directly after the PolicyPlugin
|An examples are the FilterPlugin and OperationPlugin

|===

===== Implement Plugins

The procedure for implementing any of the plugins follows a similar format:

. Create a new class that implements the specified plugin interface.

. Implement the required methods.

. Create OSGi descriptor file to communicate with the OSGi registry.

.. Import ${branding} packages.

.. Register plugin class as service to OSGi registry.

. Deploy to ${branding}.

[TIP]
====
Refer to the Javadoc for more information on all Requests and Responses in the `${ddf-branding-lowercase}.catalog.operation` and `${ddf-branding-lowercase}.catalog.event` packages.
====

===== Pre-Ingest

. Create a Java class that implements `PreIngestPlugin.` +
`public class SamplePreIngestPlugin implements ${ddf-branding}.catalog.plugin.PreIngestPlugin`

. Implement the required methods. +
 * `public CreateRequest process(CreateRequest input) throws PluginExecutionException;`
 * `public UpdateRequest process(UpdateRequest input) throws PluginExecutionException;`
 * `public DeleteRequest process(DeleteRequest input) throws PluginExecutionException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
*Blueprint descriptor example*
`<service ref="[[SamplePreIngestPlugin ]]"interface="${ddf-branding}.catalog.plugin.PreIngestPlugin" />`

===== Post-Ingest

. Create a Java class that implements `PostIngestPlugin`. +
`public class SamplePostIngestPlugin implements ${ddf-branding}.catalog.plugin.PostIngestPlugin`

. Implement the required methods. +
 * `public CreateResponse process(CreateResponse input) *throws* PluginExecutionException;`
 * `public UpdateResponse process(UpdateResponse input) *throws* PluginExecutionException;`
 * `public DeleteResponse process(DeleteResponse input) *throws* PluginExecutionException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
*Blueprint descriptor example*
`<service ref="[[SamplePostIngestPlugin ]]"interface="${ddf-branding}.catalog.plugin.PostIngestPlugin" />`

===== Pre-Query

. Create a Java class that implements `PreQueryPlugin`. +
`public class SamplePreQueryPlugin implements ${ddf-branding}.catalog.plugin.PreQueryPlugin`

. Implement the required method. +
`public QueryRequest process(QueryRequest input) *throws* PluginExecutionException, StopProcessingException;`
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
`<service ref="[[SamplePreQueryPlugin]]"interface="${ddf-branding}.catalog.plugin.PreQueryPlugin" />`

===== Post-Query

. Create a Java class that implements `PostQueryPlugin`. +
`public class SamplePostQueryPlugin implements ${ddf-branding}.catalog.plugin.PostQueryPlugin`

. Implement the required method. +
`public QueryResponse process(QueryResponse input) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
`<service ref="[[SamplePostQueryPlugin]]"interface="${ddf-branding}.catalog.plugin.PostQueryPlugin" />`

===== Pre-Delivery

. Create a Java class that implements `PreDeliveryPlugin`. +
`public class SamplePreDeliveryPlugin *implements* ${ddf-branding}.catalog.plugin.PreDeliveryPlugin`

. Implement the required methods. +
`public Metacard processCreate(Metacard metacard) *throws* PluginExecutionException, StopProcessingException;`
`public Update processUpdateMiss(Update update) *throws* PluginExecutionException,
StopProcessingException;`
 * `public Update processUpdateHit(Update update) *throws* PluginExecutionException, StopProcessingException;`
 * `public Metacard processCreate(Metacard metacard) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation,${ddf-branding}.catalog.event`

. Export the service to the OSGi registry. +
*Blueprint descriptor example* +
`<service ref="[[SamplePreDeliveryPlugin]]"interface="${ddf-branding}.catalog.plugin.PreDeliveryPlugin" />`

===== Pre-Subscription

. Create a Java class that implements `PreSubscriptionPlugin`. +
`public class SamplePreSubscriptionPlugin *implements* ${ddf-branding}.catalog.plugin.PreSubscriptionPlugin

. Implement the required method.
 * `public Subscription process(Subscription input) *throws* PluginExecutionException, StopProcessingException;`

===== Pre-Resource

. Create a Java class that implements `PreResourcePlugin`.
`public class SamplePreResourcePlugin *implements* ${ddf-branding}.catalog.plugin.PreResourcePlugin`

. Implement the required method. +
 * `public ResourceRequest process(ResourceRequest input) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.
.Blueprint descriptor example
[source,xml]
----
<service ref="[[SamplePreResourcePlugin]]" interface="${ddf-branding}.catalog.plugin.PreResourcePlugin" />
----

===== Post-Resource

. Create a Java class that implements `PostResourcePlugin`. +
`public class SamplePostResourcePlugin *implements* ${ddf-branding}.catalog.plugin.PostResourcePlugin`

. Implement the required method. +
 * `public ResourceResponse process(ResourceResponse input) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.

.Blueprint descriptor example
[source,xml]
----
<service ref="[[SamplePostResourcePlugin]]" interface="${ddf-branding}.catalog.plugin.PostResourcePlugin" />
----

===== Policy

. Create a Java class that implements `PolicyPlugin`. +
`public class SamplePolicyPlugin *implements* ${ddf-branding}.catalog.plugin.PolicyPlugin`

. Implement the required methods. +
 * `PolicyResponse processPreCreate(Metacard input, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPreUpdate(Metacard input, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPreDelete(String attributeName, List<Serializable> attributeValues, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPreQuery(Query query, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPostQuery(Result input, Map<String, Serializable> properties) *throws* StopProcessingException;`

. Import the DDF interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.  +
*Blueprint descriptor example* +
`<service ref="[[SamplePolicyPlugin]]" interface="${ddf-branding}.catalog.plugin.PolicyPlugin" />`


===== Access

. Create a Java class that implements `AccessPlugin`. +
`public class SamplePostResourcePlugin *implements* ${ddf-branding}.catalog.plugin.AccessPlugin`

. Implement the required methods. +
 * `CreateRequest processPreCreate(CreateRequest input) *throws* StopProcessingException;`
 * `UpdateRequest processPreUpdate(UpdateRequest input) *throws* StopProcessingException;`
 * `DeleteRequest processPreDelete(DeleteRequest input) *throws* StopProcessingException;`
 * `QueryRequest processPreQuery(QueryRequest input) *throws* StopProcessingException;`
 * `QueryResponse processPostQuery(QueryResponse input) *throws* StopProcessingException;`

. Import the DDF interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.  +
*Blueprint descriptor example* +
`<service ref="[[SampleAccessPlugin]]" interface="${ddf-branding}.catalog.plugin.AccessPlugin" />`


=== Extending Operations

The Catalog provides the capability to query, create, update, and delete metacards; retrieve resources; and retrieve information about the sources in the enterprise.

Each of these operations follow a request/response paradigm.
The request is the input to the operation and contains all of the input parameters needed by the Catalog Framework's operation to communicate with the Sources.
The response is the output from the execution of the operation that is returned to the client, which contains all of the data returned by the sources.
For each operation there is an associated request/response pair, e.g., the `QueryRequest` and `QueryResponse` pair for the Catalog Framework's query operation.

All of the request and response objects are extensible in that they can contain additional key/value properties on each request/response.
This allows additional capability to be added without changing the Catalog API, helping to maintain backwards compatibility.

[ditaa, catalog_architecture_operations, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |c369        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Extending Data and Metadata Basics

The catalog stores and translates Metadata which can be transformed into many data formats, shared, and queried.
The primary form of this metadata is the metacard. 
A `Metacard` is a container for metadata. 
`CatalogProviders` accept `Metacards` as input for ingest, and `Sources` search for metadata and return matching `Results` that include `Metacards`.

[ditaa, catalog_architecture_data, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |c369  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Metacard

A single instance of metadata in the Catalog (an instance of a metacard type) which generally contains metadata providing a title for the product and describing a product's geo-location, created and modified dates, owner or producer, security classification, etc. 

==== Metacard Type

===== Metacard Type

A metacard type indicates the attributes available for a particular metacard.
It is a model used to define the attributes of a metacard, much like a schema.

===== Default Metacard Type and Attributes

Most metacards within the system are created using with the default metacard type.
The default metacard type of the system can be programmatically retrieved by calling `${ddf-branding}.catalog.data.BasicTypes.BASIC_METACARD`.
The name of the default MetacardType can be retrieved from `${ddf-branding}.catalog.data.MetacardType.DEFAULT_METACARD_TYPE_NAME`.

The default metacard type has the following required attributes.
Though the following attributes are required on all metacard types, setting their values is optional except for ID.

===== Required Attributes

[cols="4*", options="header"]
|===

|`${ddf-branding}.catalog.data.Metacard` Constant
|Attribute Name
|Attribute Format
|Description

|`CONTENT_TYPE`
|`metadata-content-type`
|STRING
|Attribute name accessing for the metadata content type of a Metacard.

|`CONTENT_TYPE_VERSION`
|`metadata-content-type-version`
|STRING
|Attribute name for the version of the metadata content accessing type of a Metacard.

|`CREATED`
|`created`
|DATE
|Attribute name for accessing the date/time *this Metacard* was created.

|`EFFECTIVE`
|`effective`
|DATE
|Attribute name for accessing the date/time of *the product* represented by the Metacard.

|`EXPIRATION`
|`expiration`
|DATE
|Attribute name for accessing the date/time the Metacard is no longer valid and could be removed.

|`GEOGRAPHY`
|`location`
|GEOMETRY
|Attribute name for accessing the location for this Metacard.

|`ID`
|`id`
|STRING
|Attribute name for accessing the ID of the Metacard.

|`METADATA`
|`metadata`
|XML
|Attribute name for accessing the XML metadata for this Metacard.

|`MODIFIED`
|`modified`
|DATE
|Attribute name for accessing the date/time this Metacard was last modified.

|`RESOURCE_SIZE`
|`resource-size`
|STRING
|Attribute name for accessing the size in bytes of the product this Metacard represents.

|`RESOURCE_URI`
|`resource-uri`
|STRING
|Attribute name for accessing the URI reference to the product this Metacard represents.

|`TARGET_NAMESPACE`
|`metadata-target-namespace`
|STRING
|Attribute name for the target namespace of the accessing metadata content type of a Metacard.

|`THUMBNAIL`
|`thumbnail`
|BINARY
|Attribute name for accessing the thumbnail image of the product this Metacard represents. The thumbnail must be of MIME Type `image/jpeg` and be less than 128 kilobytes. 

|`TITLE`
|`title`
|STRING
|Attribute name for accessing the title of the Metacard.

|===

[NOTE]
====
It is highly recommended when referencing a default attribute name to use the `${ddf-branding}.catalog.data.Metacard` constants whenever possible.
====

[WARNING]
====
Every Source should at the very least return an ID attribute according to Catalog API.
Other fields might or might not be applicable, but a unique ID must be returned by a Source.
====

===== Extensible Metacards

Metacard extensibility is achieved by creating a new `MetacardType` that supports attributes in addition to the required attributes listed above.

Required attributes must be the base of all extensible metacard types. 

[WARNING]
====
Not all Catalog Providers support extensible metacards.
Nevertheless, each Catalog Provider should at least have support for the default `MetacardType`; i.e., it should be able to store and query on the attributes and attribute formats specified by the default metacard type.
Consult the documentation of the Catalog Provider in use for more information on its support of extensible metacards.
====

===== Metacard Extensibility

Often, the `BASIC_METACARD` `MetacardType` does not provide all the functionality or attributes necessary for a specific task.
For performance or convenience purposes, it may be necessary to create custom attributes even if others will not be aware of those attributes.
One example could be if a user wanted to optimize a search for a date field that did not fit the definition of `CREATED`, `MODIFIED`, `EXPIRATION`, or `EFFECTIVE`.
The user could create an additional `java.util.Date` attribute in order to query the attribute separately. 

`Metacard` objects are extensible because they allow clients to store and retrieve standard and custom key/value Attributes from the `Metacard`. 
All `Metacards` must return a `MetacardType` object that includes an `AttributeDescriptor` for each `Attribute`, indicating it's key and value type.
`AttributeType` support is limited to those types defined by the Catalog.

New `MetacardType` implementations can be made by implementing the `MetacardType` interface.

==== Metacard Type Registry

[WARNING]
====
The `MetacardTypeRegistry` is experimental. 
While this component has been tested and is functional, it may change as more information is gathered about what is needed and as it is used in more scenarios.
====

The `MetacardTypeRegistry` allows ${branding} components, primarily CatalogProviders and Sources, to make available the `MetacardTypes` that they support. 
It maintains a list of all supported `MetacardTypes` in the `CatalogFramework`, so that other components such as Endpoints, Plugins, and Transformers can make use of those `MetacardTypes`. 
The `MetacardType` is essential for a component in the `CatalogFramework` to understand how it should interpret a metacard by knowing what attributes are available in that metacard. 

For example, an endpoint receiving incoming metadata can perform a lookup in the `MetacardTypeRegistry` to find a corresponding `MetacardType`. 
The discovered `MetacardType` will then be used to help the endpoint populate a metacard based on the specified attributes in the `MetacardType`. 
By doing this, all the incoming metadata elements can then be available for processing, cataloging, and searching by the rest of the `CatalogFramework`.

`MetacardTypes` should be registered with the `MetacardTypeRegistry`.  The `MetacardTypeRegistry` makes those `MetacardTypes` available to other ${branding} `CatalogFramework` components. 
Other components that need to know how to interpret metadata or metacards should look up the appropriate `MetacardType` from the registry. 
By having these `MetacardTypes` available to the `CatalogFramework`, these components can be aware of the custom attributes. 

The `MetacardTypeRegistry` is accessible as an OSGi service. 
The following blueprint snippet shows how to inject that service into another component:

[source,xml,linenums]
----
<bean id="sampleComponent" class="${ddf-branding}.catalog.SampleComponent">
    <argument ref="metacardTypeRegistry" />
</bean>

<!-- Access MetacardTypeRegistry -->
<reference id="metacardTypeRegistry" interface="${ddf-branding}.catalog.data.MetacardTypeRegistry"/>
----

The reference to this service can then be used to register new `MetacardTypes` or to lookup existing ones. 

Typically, new `MetacardTypes` will be registered by `CatalogProviders` or Sources indicating they know how to persist, index, and query attributes from that type. 
Typically, Endpoints or `InputTransformers` will use the lookup functionality to access a `MetacardType` based on a parameter in the incoming metadata. 
Once the appropriate `MetacardType` is discovered and obtained from the registry, the component will know how to translate incoming raw metadata into a ${branding} Metacard.

===== Attribute

A single field of a metacard, an instance of an attribute type.
Attributes are typically indexed for searching by a Source or Catalog Provider.

====== Attribute Type

An attribute type indicates the attribute format of the value stored as an attribute. 
It is a model for an attribute.

====== Attribute Format

An enumeration of attribute formats are available in the catalog.
Only these attribute formats may be used.

[cols="2*", options="header"]
|===
|AttributeFormat
|Description

|`BINARY`
|Attributes of this attribute format must have a value that is a Java `byte[]` and `AttributeType.getBinding()` should return `Class<Array>of` byte.

|`BOOLEAN`
|Attributes of this attribute format must have a value that is a Java boolean.

|`DATE`
|Attributes of this attribute format must have a value that is a Java date.

|`DOUBLE`
|Attributes of this attribute format must have a value that is a Java double.

|`FLOAT`
|Attributes of this attribute format must have a value that is a Java float.

|`GEOMETRY`
|Attributes of this attribute format must have a value that is a WKT-formatted Java string.

|`INTEGER`
|Attributes of this attribute format must have a value that is a Java integer.

|`LONG`
|Attributes of this attribute format must have a value that is a Java long.

|`OBJECT`
|Attributes of this attribute format must have a value that implements the serializable interface.

|`SHORT`
|Attributes of this attribute format must have a value that is a Java short.

|`STRING`
|Attributes of this attribute format must have a value that is a Java string and treated as plain text.

|`XML`
|Attributes of this attribute format must have a value that is a XML-formatted Java string.

|===

===== Result

A single "hit" included in a query response.

A result object consists of the following:

* a metacard
* a relevance score if included
* distance in meters if included

===== Creating Metacards

The quickest way to create a `Metacard` is to extend or construct the `MetacardImpl` object. 
`MetacardImpl` is the most commonly used and extended `Metacard` implementation in the system because it provides a convenient way for developers to retrieve and set `Attribute`s without having to create a new `MetacardType` (see below).
`MetacardImpl` uses `BASIC_METACARD` as its `MetacardType`.  

===== Limitations

A given developer does not have all the information necessary to programmatically interact with any arbitrary `Source`. 
Developers hoping to query custom fields from extensible `Metacards` of other `Sources` cannot easily accomplish that task with the current API.
A developer cannot question a random `Source` for all its _queryable_ fields.
A developer only knows about the `MetacardTypes` which that individual developer has used or created previously. 

The only exception to this limitation is the `Metacard.ID` field, which is required in every `Metacard` that is stored in a `Source`.
A developer can always request `Metacards` from a `Source` for which that developer has the `Metacard.ID` value. 
The developer could also perform a wildcard search on the `Metacard.ID` field if the `Source` allows.

===== Processing Metacards

As `Metacard` objects are created, updated, and read throughout the Catalog, care should be taken by all Catalog Components to interrogate the `MetacardType` to ensure that additional `Attributes` are processed accordingly.

===== Basic Types

The Catalog includes definitions of several Basic Types all found in the `${ddf-branding}.catalog.data.BasicTypes` class.

[cols="3*", options="header"]
|===

|Name
|Type
|Description

|`BASIC_METACARD`
|MetacardType
|representing all required Metacard Attributes

|`BINARY_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.BINARY`.

|`BOOLEAN_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.BOOLEAN`.

|`DATE_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.DATE`.

|`DOUBLE_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.DOUBLE`.

|`FLOAT_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.FLOAT`.

|`GEO_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.GEOMETRY`.

|`INTEGER_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.INTEGER`.

|`LONG_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.LONG`.

|`OBJECT_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.OBJECT`.

|`SHORT_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.SHORT`.

|`STRING_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.STRING`.

|`XML_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.XML`.

|===

=== Extending Catalog Framework

This section describes the core components of the Catalog app and Catalog Framework. 
The Catalog Framework wires all Catalog components together.

It is responsible for routing Catalog requests and responses to the appropriate target. 

Endpoints send Catalog requests to the Catalog Framework.
The Catalog Framework then invokes Catalog Plugins, Transformers, and Resource Components as needed before sending requests to the intended destination, such as one or more Sources. 

The Catalog Framework functions as the routing mechanisms between all catalog components.
It decouples clients from service implementations and provides integration points for Catalog Plugins and convenience methods for Endpoint developers.

[ditaa, catalog_architecture_framework, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |c369               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Included Catalog Frameworks

===== Catalog API

The Catalog API is an OSGi bundle (`catalog-core-api`) that contains the Java interfaces for the Catalog components and implementation classes for the Catalog Framework, Operations, and Data components.

===== Standard Catalog Framework

The Standard Catalog Framework provides the reference implementation of a Catalog Framework that implements all requirements of the ${ddf-catalog}API. 
`CatalogFrameworkImpl` is the implementation of the ${branding} Standard Catalog Framework.

===== Installing and Uninstalling

The Standard Catalog Framework is bundled as the `catalog-core-standardframework` feature and can be installed and uninstalled using the normal processes described in Configuration.

When this feature is installed, the Catalog Fanout Framework App feature `catalog-core-fanoutframework` should be uninstalled, as both catalog frameworks should not be installed simultaneously.

===== Configuring

====== Configurable Properties

.Catalog Standard Framework
[cols="2,1,3,1,1", options="header"]
|===

|Property
|Type
|Description
|Default Value
|Required

|`fanoutEnabled`
|Boolean
|When enabled the Framework acts as a proxy, federating requests to all available sources. All requests are executed as federated queries and resource retrievals, allowing the framework to be the sole component exposing the functionality of all of its Federated Sources.
|false
|yes

|`productCacheDirectory`
|String
|Directory where retrieved products will be cached for faster, future retrieval. If a directory path is specified with directories that do not exist, Catalog Framework will attempt to create those directories. Out of the box (without configuration), the product cache directory is `<INSTALL_DIR>/data/product-cache`. If a relative path is provided it will be relative to the `<INSTALL_DIR>`.

It is recommended to enter an absolute directory path such as `/opt/product-cache`in Linux or `C:\product-cache` in Windows."
|`(empty)`
|no

|`cacheEnabled`
|Boolean
|Check to enable caching of retrieved products to provide faster retrieval for subsequent requests for the same product.
|false
|no

|`delayBetweenRetryAttempts`
|Integer
|The time to wait (in seconds) between each attempt to retry retrieving a product from the Source.
|10
|no

|`maxRetryAttempts`
|Integer
|The maximum number of attempts to try and retrieve a product from the Source.
|3
|no

|`cachingMonitorPeriod`
|Integer
|The number of seconds allowed for no data to be read from the product data before determining that the network connection to the Source where the product is located is considered to be down.
|5
|no

|`cacheWhenCanceled`
|Boolean
|Check to enable caching of retrieved products even if client cancels the download.
|false
|no

|===

[cols="2*", options="header"]
|===

|Managed Service PID
|`${ddf-branding}.catalog.CatalogFrameworkImpl`
|Managed Service Factory PID
|N/A
|===

===== Using

The Standard Catalog Framework is the core class of ${branding}.
It provides the methods for query, create, update, delete, and resource retrieval (QCRUD) operations on the `Sources`.
By contrast, the Fanout Catalog Framework only allows for query and resource retrieval operations, no catalog modifications, and all queries are enterprise-wide.

Use this framework if:

* access to a catalog provider to create, update, and delete catalog entries are required.
* queries to specific sites are required.
* queries to only the local provider are required.

It is possible to have only remote Sources configured with no local `CatalogProvider` configured and be able to execute queries to specific remote sources by specifying the site name(s) in the query request.

The Standard Catalog Framework also maintains a list of `ResourceReaders` for resource retrieval operations.
A resource reader is matched to the scheme (i.e., protocol, such as `file://`) in the URI of the resource specified in the request to be retrieved.

Site information about the catalog provider and/or any federated source(s) can be retrieved using the Standard Catalog Framework.
Site information includes the source's name, version, availability, and the list of unique content types currently stored in the source (e.g., NITF).
If no local catalog provider is configured, the site information returned includes site info for the catalog framework with no content types included.

===== Implementation Details

====== Exported Services

[cols="3,1,2", options="header"]
|===

|Registered Interface
|Service Property
|Value

|`${ddf-branding}.catalog.federation.FederationStrategy`
|shortname
|sorted

|`org.osgi.service.event.EventHandler`
|event.topics
|`${ddf-branding}/catalog/event/CREATED`, `${ddf-branding}/catalog/event/UPDATED`, d`df/catalog/event/DELETED`

|`${ddf-branding}.catalog.CatalogFramework`
|
|

|`${ddf-branding}.catalog.event.EventProcessor`
|
|

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|
|

|===

===== Imported Services

[cols="3,1,1" options="header"]
|===

|Registered Interface
|Availability
|Multiple

|`${ddf-branding}.catalog.plugin.PostFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreDeliveryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreSubscriptionPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PolicyPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.AccessPlugin`
|optional
|true

|`${ddf-branding}.catalog.resource.ResourceReader`
|optional
|true

|`${ddf-branding}.catalog.source.CatalogProvider`
|optional
|true

|`${ddf-branding}.catalog.source.ConnectedSource`
|optional
|true

|`${ddf-branding}.catalog.source.FederatedSource`
|optional
|true

|`${ddf-branding}.cache.CacheManager`
| 
|false

|`org.osgi.service.event.EventAdmin`
| 
|false

|===

==== Known Issues

None

=== Catalog Fanout Framework 

The Fanout Catalog Framework (`fanout-catalogframework` bundle) provides an implementation of the Catalog Framework that acts as a proxy, federating requests to all available sources. 
All requests are executed as federated queries and resource retrievals, allowing the fanout site to be the sole site exposing the functionality of all of its Federated Sources.
The Fanout Catalog Framework is the implementation of the Fanout Catalog Framework.

The Fanout Catalog Framework provides the capability to configure ${branding} to be a fanout proxy to other federated sources within the enterprise.
The Fanout Catalog Framework has no catalog provider configured for it, so it does not allow catalog modifications to take place.
Therefore, create, update, and delete operations are not supported.

.Catalog Fanout Framework
[ditaa,query-flow,png, ${image-width}]
....
           /------\
           |Client|
           |cDEF  |
           \------/
              ^
              |
+-------------|------------------------------------------------------------\
|DDF          |                                                       cCCC |
|             v                                                            |
|         /--------\   /-----------------\   /-------------------\         |
|         |Endpoint|<->|Catalog Framework|<->|Federation Strategy|         |
|         | cDEF   |   | cDEF            |   | cDEF              |         |
|         \--------/   \-----------------/   \-------------------/         |
|                                                     ^ ^                  |
|                                                     | |                  |
|                                          /----------/ \---------\        |
|                                          |                      |        |
| +----------------------------------------|----------------------|------+ |
| |Enterprise Query c369                   v                      v      | |
| |+--------------------------------------------+ +---------------------+| |
| ||Local Query                                 | |Federated Query      || |
| ||/------------------\ /---------------------\| |/-------------------\|| |
| ||| Catalog Provider | | Connected Source(s) || ||Federated Source(s)||| |
| |||  cDEF            | |  cDEF               || || cDEF              ||| |
| ||\------------------/ \---------------------/| |\-------------------/|| |
| |+-------^----------------------^-------------+ +----^----------^-----+| |
| +--------|----------------------|--------------------|----------|------+ |
\----------|----------------------|--------------------|----------|--------/
           |                      |                    |          \-------------------\
           |                      |                    |                              |
           v                      v                    v                              v
/=-------------------\ /----------------------\ /---------=------------\     /----------------------\
|Internal Data Source| |External Data Source 1| |External Data Source 3| ... |External Data Source N|
\--------------------/ \--------------------=-/ \----------------------/     \-------=--------------/
....

In addition, the Fanout Catalog Framework provides the following benefits:

* Backwards compatibility (e.g., federating with older versions) with existing older versions of ${branding}.
* A single node being exposed from an enterprise, thus hiding the enterprise from an external client.
* Ensures all queries and resource retrievals are federated.

===== Installing and Uninstalling

The Fanout Catalog Framework is bundled as the `catalog-core-fanoutframework` feature and can be installed and uninstalled using the normal processes described in Configuration.

[WARNING]
====
When this feature is installed, the Standard Catalog Framework feature `catalog-core-standardframework` should be uninstalled, as both catalog frameworks should not be installed simultaneously.
====

==== Configuring

The Fanout Catalog Framework can be configured using the normal processes described in Configuring ${branding}.

The configurable properties for the Fanout Catalog Framework are accessed from the Catalog Fanout Framework configuration in the Admin Console.

===== Configurable Properties

[cols="1,2,1,3,1,1" options="header"]
|===

|Title
|Property
|Type
|Description
|Default Value
|Required

|Default Timeout
(in milliseconds)
|`defaultTimeout`
|Integer
|The maximum amount of time to wait for a response from the Sources.
|60000
|yes

|Product Cache Directory
|`productCacheDirectory`
|String
|Directory where retrieved products will be cached for faster, future retrieval. If a directory path is specified with directories that do not exist, Catalog Framework will attempt to create those directories. Out of the box (without configuration), the product cache directory is `<INSTALL_DIR>/data/product-cache`. If a relative path is provided, it will be relative to the `<INSTALL_DIR>`.

It is recommended to enter an absolute directory path, such as `/opt/product-cache` in Linux or `C:\product-cache` in Windows.
|(empty)
|no

|Enable Product Caching
|`cacheEnabled`
|Boolean
|Check to enable caching of retrieved products to provide faster retrieval for subsequent requests for the same product.
|false
|no

|Delay (in seconds) between product retrieval retry attempts
|`delayBetweenRetryAttempts`
|Integer
|The time to wait (in seconds) between attempting to retry retrieving a product.
|10
|no

|Max product retrieval retry attempts
|`maxRetryAttempts`
|Integer
|The maximum number of attempts to retry retrieving a product.
|3
|no

|Caching Monitor Period
|`cachingMonitorPeriod`
|Integer
|How many seconds to wait and not receive product data before retrying to retrieve a product.
|5
|no

|Always Cache Product
|`cacheWhenCanceled`
|Boolean
|Check to enable caching of retrieved products, even if client cancels the download.
|false
|no

|===

[cols="2*" options="header"]
|===
|Managed Service PID
|`${ddf-branding}.catalog.impl.service.fanout.FanoutCatalogFramework`
|Managed Service Factory PID
|N/A
|===

===== Using

The Fanout Catalog Framework is a core class of ${branding} when configured as a fanout proxy.
It provides the methods for query and resource retrieval operations on the Sources, where all operations are enterprise-wide operations.
By contrast, the Standard Catalog Framework supports create/update/delete operations of metacards, in addition to the query and resource retrieval operations.

Use the Fanout Catalog Framework if:

* exposing a single node for enterprise access and hiding the details of the enterprise, such as federate source's names, is desired.
* access to individual federated sources is not required.
* access to a catalog provider to create, update, and delete metacards is not required.

The Fanout Catalog Framework also maintains a list of `ResourceReaders` for resource retrieval operations.
A resource reader is matched to the scheme (i.e., protocol, such as `file://`) in the URI of the resource specified in the request to be retrieved.

Site information about the fanout configuration can be retrieved using the Fanout Catalog Framework.
Site information includes the source's name, version, availability, and the list of unique content types currently stored in the source (e.g., NITF).
Details of the individual federated sources is not included, only the fanout catalog framework.

===== Implementation Details

====== Exported Services

[cols="3*" options="header"]
|===
|Registered Interface
|Service Property
|Value

|`${ddf-branding}.catalog.federation.FederationStrategy`
|shortname
|sorted

|`org.osgi.service.event.EventHandler`
|event.topics
|`${ddf-branding}/catalog/event/CREATED`, `${ddf-branding}/catalog/event/UPDATED`, `${ddf-branding}/catalog/event/DELETED`

|`${ddf-branding}.catalog.CatalogFramework`
|
|

|`${ddf-branding}.catalog.event.EventProcessor`
|
| 

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|
|

|===

===== Imported Services

[cols="3*" options="header"]
|===

|Registered Interface
|Availability
|Multiple

|`${ddf-branding}.cache.CacheManager`
|
|false

|`${ddf-branding}.catalog.plugin.PostFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreDeliveryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreSubscriptionPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PolicyPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.AccessPlugin`
|optional
|true

|`${ddf-branding}.catalog.resource.ResourceReader`
|optional
|true

|`${ddf-branding}.catalog.source.ConnectedSource`
|optional
|true

|`${ddf-branding}.catalog.source.FederatedSource`
|optional
|true

|`org.osgi.service.event.EventAdmin`
| 
|false

|===

==== Known Issues

None

==== Catalog Framework Camel Component

The catalog framework camel component supports creating, updating, and deleting metacards using the Catalog Framework from a Camel route.

===== URI Format

----
catalog:framework
----

===== Message Headers

====== Catalog Framework Producer

[cols="1,5" options="header"]
|===
|Header
|Description

|operation
|the operation to perform using the catalog framework (possible values are CREATE \| UPDATE \| DELETE)
|===

===== Sending Messages to Catalog Framework Endpoint

====== Catalog Framework Producer

In Producer mode, the component provides the ability to provide different inputs and have the Catalog framework perform different operations based upon the header values.  

For the CREATE and UPDATE operation, the message body can contain a list of metacards or a single metacard object. 

For the DELETE operation, the message body can contain a list of strings or a single string object.
The string objects represent the IDs of metacards to be deleted. 
The exchange's "in" message will be set with the affected metacards.
In the case of a CREATE, it will be updated with the created metacards.
In the case of the UPDATE, it will be updated with the updated metacards and with the DELETE it will contain the deleted metacards.

[cols="2,2,3" options="header"]
|===
|Header
|Message Body (Input)
|Exchange Modification (Output)

|operation = CREATE
|List<Metacard> or Metacard
|exchange.getIn().getBody() updated with List of Metacards created

|operation = UPDATE
|List<Metacard> or Metacard
|exchange.getIn().getBody() updated with List of Metacards updated

|operation = DELETE
|List<String> or String (representing metacard IDs)
|exchange.getIn().getBody() updated with List of Metacards deleted

|===

====== Samples

This example demonstrates:

. Reading in some sample data from the file system.
. Using a Java bean to convert the data into a metacard.
. Setting a header value on the Exchange.
. Sending the Metacard to the Catalog Framework component for ingestion.

[source,xml,linenums]
----
<route>
 <from uri="file:data/sampleData?noop=true“/>
    <bean ref="sampleDataToMetacardConverter" method="covertToMetacard"/>\
   <setHeader headerName="operation">
  <constant>CREATE</constant>
 </setHeader>
    <to uri="catalog:framework"/>
</route>
----


==== Working with the Catalog Framework

===== Catalog Framework Reference

The Catalog Framework can be requested from the OSGi registry.

.Blueprint Service Reference
[source,xml]
----
<reference id="catalogFramework" interface="${ddf-branding}.catalog.CatalogFramework" />
----

===== Methods

====== Create, Update, and Delete

Create, Update, and Delete (CUD) methods add, change, or remove stored metadata in the local Catalog Provider.

.Create, Update, Delete Methods
[source,java,linenums]
----
public CreateResponse create(CreateRequest createRequest) throws IngestException, SourceUnavailableException;
public UpdateResponse update(UpdateRequest updateRequest) throws IngestException, SourceUnavailableException;
public DeleteResponse delete(DeleteRequest deleteRequest) throws IngestException, SourceUnavailableException;
----

CUD operations process `PolicyPlugin`, `AccessPlugin`, and `PreIngestPlugin` instances before execution and `PostIngestPlugin` instances after execution.

====== Query

Query methods search metadata from available Sources based on the `QueryRequest` properties and Federation Strategy.
Sources could include Catalog Provider, Connected Sources, and Federated Sources.

.Query Methods
[source,java,linenums]
----
public QueryResponse query(QueryRequest query) throws UnsupportedQueryException,SourceUnavailableException, FederationException;
public QueryResponse query(QueryRequest queryRequest, FederationStrategy strategy) throws SourceUnavailableException, UnsupportedQueryException, FederationException;
----
Query requests process  `PolicyPlugin`, `AccessPlugin`, and `PreQueryPlugin` instances before execution and  `PolicyPlugin`, `AccessPlugin`, and `PostQueryPlugin` instances after execution.

====== Resources

Resource methods retrieve products from Sources.

.Resource Methods
[source,java,linenums]
----
public ResourceResponse getEnterpriseResource(ResourceRequest request) throwsIOException, ResourceNotFoundException, ResourceNotSupportedException;
public ResourceResponse getLocalResource(ResourceRequest request) throws IOException, ResourceNotFoundException, ResourceNotSupportedException;
public ResourceResponse getResource(ResourceRequest request, String resourceSiteName) throws IOException, ResourceNotFoundException, ResourceNotSupportedException;
----
Resource requests process `PreResourcePlugin`s before execution and `PostResourcePlugin`s after execution.

====== Sources

Source methods can get a list of Source identifiers or request descriptions about Sources.

.Source Methods
[source,java,linenums]
----
public Set<String> getSourceIds();
public SourceInfoResponse getSourceInfo(SourceInfoRequest sourceInfoRequest) throws SourceUnavailableException;
----

====== Transforms

Transform methods provide convenience methods for using Metacard Transformers and Query Response Transformers.

.Transform Methods
[source,java,linenums]
----
// Metacard Transformer
public BinaryContent transform(Metacard metacard, String transformerId, Map<String,Serializable> requestProperties) throws CatalogTransformerException;

// Query Response Transformer
public BinaryContent transform(SourceResponse response, String transformerId, Map<String, Serializable> requestProperties) throws CatalogTransformerException;
----

==== Developing Complementary Frameworks

${branding} and the underlying OSGi technology can serve as a robust infrastructure for developing frameworks that complement the ${ddf-catalog}.

Recommendations for Framework Development

. Provide extensibility similar to that of the ${ddf-catalog}.
.. Provide a stable API with interfaces and simple implementations (refer to `http://www.ibm.com/developerworks/websphere/techjournal/1007_charters/1007_charters.html`).
. Make use of the ${ddf-catalog} wherever possible to store, search, and transform information.
. Utilize OSGi standards wherever possible.
.. ConfigurationAdmin
.. MetaType
. Utilize the sub-frameworks available in ${branding}.
.. Karaf
.. CXF
.. PAX Web and Jetty

==== Developing Console Commands

===== Console Commands

${branding} supports development of custom console commands.

${branding} includes custom commands for working with the Catalog, as described in the <<managing.adoc#_console_commands, Managing Console Commands>> section.

=== Extending Sources

==== Existing Source Types

=





==== Developing a Filter Delegate

Filter Delegates help reduce the complexity of parsing OGC Filters.
The reference Filter Adapter implementation contains the necessary boilerplate visitor code and input normalization to handle commonly supported OGC Filters.

===== Creating a New Filter Delegate

A Filter Delegate contains the logic that converts normalized filter input into a form that the targeted data source can handle.
Delegate methods will be called in a depth first order as the Filter Adapter visits filter nodes.

===== Implementing the Filter Delegate

. Create a Java class extending `FilterDelegate`. +
`public class ExampleDelegate extends ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> {`
. `FilterDelegate` will throw an appropriate exception for all methods not implemented.  Refer to the ${branding} JavaDoc for more details about what is expected of each `FilterDelegate` method.

[NOTE]
====
A code example of a Filter Delegate can be found in `${ddf-branding}.catalog.filter.proxy.adapter.test` of the `filter-proxy` bundle.
====

===== Throwing Exceptions

Filter delegate methods can throw `UnsupportedOperationException` run-time exceptions.
The `GeotoolsFilterAdapterImpl` will catch and re-throw these exceptions as `UnsupportedQueryExceptions`.

===== Using the Filter Adapter

The FilterAdapter can be requested from the OSGi registry.

[source,xml]
----
<reference id="filterAdapter" interface="${ddf-branding}.catalog.filter.FilterAdapter" />
----

The Query in a QueryRequest implements the Filter interface.
The Query can be passed to a `FilterAdapter` and `FilterDelegate` to process the Filter.

[source,java,linenums]
----
@Override
public ${ddf-branding}.catalog.operation.QueryResponse query(${ddf-branding}.catalog.operation.QueryRequest queryRequest)
    throws ${ddf-branding}.catalog.source.UnsupportedQueryException {

    ${ddf-branding}.catalog.operation.Query query = queryRequest.getQuery();

    ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> delegate = new ExampleDelegate();

    // ${ddf-branding}.catalog.filter.FilterAdapter adapter injected via Blueprint
    ExampleReturnObjectType result = adapter.adapt(query, delegate);
}
----

Import the ${ddf-catalog} API Filter package and the reference implementation package of the Filter Adapter in the bundle manifest  (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.filter, ${ddf-branding}.catalog.source`

===== Filter Support

Not all OGC Filters are exposed at this time.
If demand for further OGC Filter functionality is requested, it can be added to the Filter Adapter and Delegate so sources can support more complex filters.
The following OGC Filter types are currently available:

[cols="1" options="header"]
|===
|Logical
|And
|Or
|Not
|Include
|Exclude
|===

[cols="1" options="header"]
|===
|Property Comparison
|`PropertyIsBetween`
|`PropertyIsEqualTo`
|`PropertyIsGreaterThan`
|`PropertyIsGreaterThanOrEqualTo`
|`PropertyIsLessThan`
|`PropertyIsLessThanOrEqualTo`
|`PropertyIsLike`
|`PropertyIsNotEqualTo`
|`PropertyIsNull`
|===

[cols="2,5" options="header"]
|===
|`Spatial`
|Definition

|`Beyond`
|True if the geometry being tested is beyond the stated distance of the geometry provided.

|`Contains`
|True if the second geometry is wholly inside the first geometry.

|`Crosses`
|True if the intersection of the two geometries results in a value whose dimension is less than the geometries and the maximum dimension of the intersection value includes points interior to both the geometries, and the intersection value is not equal to either of the geometries.

|`Disjoint`
|True if the two geometries do not touch or intersect.

|`DWithin`
|True if the geometry being tested is within the stated distance of the geometry provided.

|`Intersects`
|True if the two geometries intersect. This is a convenience method as you could always ask for Not Disjoint(A,B) to get the same result.

|`Overlaps`
|True if the intersection of the geometries results in a value of the same dimension as the geometries that is different from both of the geometries.

|`Touches`
|True if and only if the only common points of the two geometries are in the union of the boundaries of the geometries.

|`Within`
|True if the first geometry is wholly inside the second geometry.
|===

[cols="1" options="header"]
|===
|Temporal
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/After.html[After]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/Before.html[Before]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/During.html[During]
|===


==== Catalog Framework

The `CatalogFramework` provides convenient methods to transform `Metacards` and `QueryResponses` using a reference to the `CatalogFramework`.
See Working with the Catalog Framework for more details on the method signatures.
It is easy to execute the convenience `transform` methods on the `CatalogFramework` instance.

.Query Response Transform Example
[source,java,linenums]
----
// inject CatalogFramework instance or retrieve an instance
private CatalogFramework catalogFramework;

public RSSEndpoint(CatalogFramework catalogFramework)
{
     this.catalogFramework = catalogFramework ;
     // implementation
}

 // Other implementation details ...

private void convert(QueryResponse queryResponse ) {
    // ...
    String transformerId = "rss";

    BinaryContent content = catalogFramework.transform(queryResponse, transformerId, null);

    // ...

}
----

[cols="2,5" options="header"]
|===
|Line #
|Action
|4
|`CatalogFramework` is injected, possibly by dependency injection framework.

|16
|`queryResponse` is transformed into the RSS format, which is stored in the `BinaryContent` instance
|===

==== Dependency Injection
Using Blueprint or another injection framework, transformers can be injected from the OSGi Service Registry.

.Blueprint Service Reference
[source,xml]
----
<reference id="[[Reference Id]]" interface="${ddf-branding}.catalog.transform.[[Transformer Interface Name]]" filter="(shortname=[[Transformer Identifier]])" />
----

Each transformer has one or more `transform` methods that can be used to get the desired output.

.Input Transformer Example
[source,java,linenums]
----
${ddf-branding}.catalog.transform.InputTransformer inputTransformer = retrieveInjectedInstance() ;

Metacard entry = inputTransformer.transform(messageInputStream);
----

.Metacard Transformer Example
[source,java,linenums]
----
${ddf-branding}.catalog.transform.MetacardTransformer metacardTransformer = retrieveInjectedInstance() ;

BinaryContent content = metacardTransformer.transform(metacard, arguments);
----

.Query Response Transformer Example
[source,java,linenums]
----
${ddf-branding}.catalog.transform.QueryResponseTransformer queryResponseTransformer = retrieveInjectedInstance() ;

BinaryContent content = queryResponseTransformer.transform(sourceSesponse, arguments);
----

==== OSGi Service Registry

[IMPORTANT]
====
In the vast majority of cases, working with the OSGi Service Reference directly should be avoided.
Instead, dependencies should be injected via a dependency injection framework like Blueprint.
====

Transformers are registered with the OSGi Service Registry.
Using a `BundleContext` and a filter, references to a registered service can be retrieved.

.OSGi Service Registry Reference Example
[source,java,linenums]
----
ServiceReference[] refs =
    bundleContext.getServiceReferences(${ddf-branding}.catalog.transform.InputTransformer.class.getName(),"(shortname=" + transformerId + ")");
InputTransformer inputTransformer = (InputTransformer) context.getService(refs[0]);
Metacard entry = inputTransformer.transform(messageInputStream);
----

==== Included Input Transformers



=



=

=


====== Package Details

_Feature Information_

N/A

_Included Bundles_

N/A

_Services_

_Exported Services_

.${ddf-branding}.catalog.transform.InputTransformer
[cols="2"]
|===

|mime-type
|application/json

|id
|geojson

|===

====== Implementation Details
.Exported Services
[cols="3"]
|===

|Registered Interface
|Service Property
|Value

|`${ddf-branding}.catalog.transform.InputTransformer`
|mime-type
|application/json

|
|id
|geojson

|===


==== Included Metacard InputTransformers

A metacard transformer transforms a metacard into other data formats.

=





==== Developing a Metacard Transformer

In general, a `MetacardTransformer` is used to transform a `Metacard` into some desired format useful to the end user or as input to another process.
Programmatically, a `MetacardTransformer` transforms a `Metacard` into a `BinaryContent` instance, which contains the translated `Metacard` into the desired final format.
Metacard transformers can be used through the Catalog Framework `transform` convenience method or requested from the OSGi Service Registry by endpoints or other bundles.

===== Create a New Metacard Transformer
. Create a new Java class that implements `${ddf-branding}.catalog.transform.MetacardTransformer`. +
`public class SampleMetacardTransformer implements ${ddf-branding}.catalog.transform.MetacardTransformer`
. Implement the transform method. +
`public BinaryContent transform(Metacard metacard, Map<String, Serializable> arguments) throws CatalogTransformerException`
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.transform`
. Create an OSGi descriptor file to communicate with the OSGi Service registry (described in the Working with OSGi section). Export the service to the OSGi registry and declare service properties.

.Blueprint descriptor example
[source,xml,linenums]
----
...
<service ref="[[SampleMetacardTransformer]]" interface="${ddf-branding}.catalog.transform.MetacardTransformer">
    <service-properties>
        <entry key="shortname" value="[[sampletransform]]" />
        <entry key="title" value="[[Sample Metacard Transformer]]" />
        <entry key="description" value="[[A new transformer for metacards.]]" />
    </service-properties>
</service>
...
----

Deploy OSGi Bundle to OSGi runtime.

===== Variable Descriptions

.Blueprint Service properties
[cols="3" options="header"]
|===
|Key
|Description of Value
|Example

|`shortname`
|(Required) An abbreviation for the return type of the BinaryContent being sent to the user.
|atom

|`title`
|(Optional) A user-readable title that describes (in greater detail than the shortname) the service.
|Atom Entry Transformer Service

|`description`
|(Optional) A short, human-readable description that describes the functionality of the service and the output.
|This service converts a single metacard xml document to an atom entry element.

|===


=
=
=



=== Extending Federation

Federation provides the capability to extend the ${branding} enterprise to include Remote Sources, which may include other instances of ${branding}. 
The Catalog handles all aspects of federated queries as they are sent to the Catalog Provider and Remote Sources, processed, and the query results are returned.
Queries can be scoped to include only the local Catalog Provider (and any Connected Sources), only specific Federated Sources, or the
entire enterprise (which includes all local and Remote Sources).
If the query is supposed to be federated, the Catalog Framework passes the query to a Federation Strategy, which is responsible for querying each federated source that is specified.
The Catalog Framework is also responsible for receiving the query results from each federated source and returning them to the client in the order specified by the particular federation strategy used.
After the federation strategy handles the results, the Catalog returns them to the client through the Endpoint.
Query results returned from a federated query are a list of metacards.
The source ID in each metacard identifies the Source from which the metacard originated.

The Catalog normalizes the incoming query into an OGC Filter format.
When the query is disseminated by the Catalog Framework to the sources, each source is responsible for denormalizing the OGC Filter formatted query into the format understood by the external store that the source is acting as a proxy.
This normalization/denormalization is what allows any endpoint to interface with any type of source.
For example, a query received by the OpenSearch Endpoint can be executed against an OpenSearch Source.

.Federation Architecture
[ditaa, catalog_architecture_federation, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |c369        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

.Federation
[ditaa, federation, png, ${image-width}]
....
           /------\
           |Client|
           |cDEF  |
           \------/
              ^
              |
+-------------|------------------------------------------------------------\
|DDF          |                                                       cCCC |
|             v                                                            |
|         /--------\   /-----------------\   /-------------------\         |
|         |Endpoint|<->|Catalog Framework|<->|Federation Strategy|         |
|         | cDEF   |   | cDEF            |   | cDEF              |         |
|         \--------/   \-----------------/   \-------------------/         |
|                                                     ^ ^                  |
|                                                     | |                  |
|                                          /----------/ \---------\        |
|                                          |                      |        |
| +----------------------------------------|----------------------|------+ |
| |Enterprise Query                        v                      v      | |
| |+--------------------------------------------+ +---------------------+| |
| ||Local Query                                 | |Federated Query      || |
| ||/------------------\ /---------------------\| |/-------------------\|| |
| ||| Catalog Provider | | Connected Source(s) || ||Federated Source(s)||| |
| |||  cDEF            | |  cDEF               || || cDEF              ||| |
| ||\------------------/ \---------------------/| |\-------------------/|| |
| |+-------^----------------------^-------------+ +----^----------^-----+| |
| +--------|----------------------|--------------------|----------|------+ |
\----------|----------------------|--------------------|----------|--------/
           |                      |                    |          \-------------------\
           |                      |                    |                              |
           v                      v                    v                              v
/=-------------------\ /----------------------\ /---------=------------\     /----------------------\
|  Oracle Database   | |       Source A       | |       Source B       | ... |       Source X       |
\--------------------/ \--------------------=-/ \----------------------/     \-------=--------------/
....

==== Federation Strategy

A federation strategy federates a query to all of the Remote Sources in the query's list, processes the results in a unique way, then returns the results to the client. 
For example, implementations can choose to block until all results return then perform a mass sort or return the results back to the client as soon as they are received back from a Federated Source.

===== Usage

An endpoint can optionally specify the federation strategy to use when it invokes the query operation.
Otherwise, the Catalog provides a default federation strategy that will be used.

===== Catalog Federation Strategy [[catalogFederationStrategy]]

The Catalog Federation Strategy is the default federation strategy and is based on sorting metacards by the sorting parameter specified in the federated query.

The possible sorting values are:

* metacard's effective date/time
* temporal data in the query result
* distance data in the query result
* relevance of the query result

The supported sorting orders are ascending and descending.

The default sorting value/order automatically used is relevance descending.

[WARNING]
====
The Catalog Federation Strategy expects the results returned from the Source to be sorted based on whatever sorting criteria were specified.
If a metadata record in the query results contains null values for the sorting criteria elements, the Catalog Federation Strategy expects that result to come at the end of the result list.
====

===== Configuration

The Catalog Federation Strategy configuration can be found in the admin console under *Configuration -> Catalog Federation Strategy*.

[cols="1,1,4a,1,1" options="header"]
|===

|Property
|Type
|Description
|Default Value
|Required

|`maxStartIndex`
|Integer
|The maximum query offset number (any number from 1 to unlimited). Setting the number too high would allow offset queries that could result in an out of memory error because the ${branding} will cycle through all records in memory. Things to consider when setting this value are:

* How much memory is allocated to the ${branding} Server
* How many sites are being federated with.

|50000
|yes

|`expirationIntervalInMinutes`
|Long
|Interval that Solr Cache checks for expired documents to remove.
|10
|yes

|`expirationAgeInMinutes`
|Long
|The number of minutes a document will remain in the cache before it will expire. Default is 7 days.
|10080
|yes

|`url`
|String
|HTTP URL of Solr Server
|${secure_url}/solr
|yes

|`cachingEverything`
|Boolean
|Cache all results unless configured as native
|false
|yes

|===

[cols="2" options="header"]
|===

|Managed Service PID
|`${ddf-branding}.catalog.federation.impl.CachingFederationStrategy`

|Managed Service Factory PID
|N/A
|===

=== Extending Eventing

The Eventing capability of the Catalog allows endpoints (and thus external users) to create a "standing query" and be notified when a matching metacard is created, updated, or deleted.

Notably, the Catalog allows event evaluation on both the previous value (if available) and new value of a Metacard when an update occurs.

To better understand why this would be useful, suppose that there has been increased pirating activity off the coast of Somalia. 
Because of these events, a group of intelligence analysts is interested in determining the reason for the heightened activity and discovering its cause.
To do this, analysts need to monitor interesting events occurring in that area. 
Without ${branding} Eventing, the analysts would need to repeatedly query for any records of events or intelligence gathered in that area. 
Analysts would have to monitor changes or anything of interest. 
However, with ${branding} Eventing, the analysts can create a subscription indicating criteria for the types of intelligence of interest. 
In this scenario, analysts could specify interest in metacards added, updated, or deleted that describe data obtained around the coast of Somalia. 
Through this subscription, ${branding} will send event notifications back to the team of analysts containing metadata of interest. 
Furthermore, they could filter the records not only spatially, but by any other criteria that would zero in on the most interesting records. 
For example, a fishing company that has operated ships peacefully in the same region for a long time may not be interesting. 
To exclude metadata about that company, analysts may add contextual criteria indicating to return only records containing the keyword "pirate." 
With the subscription in place, analysts will only be notified of metadata related to the pirating activity, giving them better situational awareness.

The key components of ${branding} Eventing include:

* Subscription
* Delivery Method
* Event Processor

After reading this section, you will be able to:

* Create new subscriptions
* Register subscriptions
* Perform operations on event notification
* Remove a subscription

.Eventing Architecture
[ditaa, catalog_architecture_eventing, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |c369   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Subscription

Subscriptions represent "standing queries" in the Catalog.
Like a query, subscriptions are based on the OGC Filter specification.

===== Subscription Lifecycle

====== Creation

* Subscriptions are created directly with the Event Processor or declaratively through use of the Whiteboard Design Pattern.
* The Event Processor will invoke each Pre-Subscription Plugin and, if the subscription is not rejected, the subscription will be activated.

====== Evaluation

* When a metacard matching the subscription is created, updated, or deleted in any Source, each Pre-Delivery Plugin will be invoked.

* If the delivery is not rejected, the associated Delivery Method callback will be invoked.

====== Update Evaluation

Notably, the Catalog allows event evaluation on both the previous value (if available) and new value of a Metacard when an update occurs.

====== Durability

Subscription durability is not provided by the Event Processor.
Thus, all subscriptions are transient and will not be recreated in the event of a system restart.
It is the responsibility of Endpoints using subscriptions to persist and re-establish the subscription on startup.
This decision was made for the sake of simplicity, flexibility, and the inability of the Event Processor to recreate a fully-configured Delivery Method without being overly restrictive.

[IMPORTANT]
====
*Subscriptions are not persisted by the Catalog itself.* +
Subscriptions must be explicitly persisted by an endpoint and are not persisted by the Catalog.
The Catalog Framework, or more specifically the Event Processor itself, does not persist subscriptions.
Certain endpoints, however, can persist the subscriptions on their own and recreate them on system startup.
====

====== Creating a Subscription

Currently, the Catalog reference implementation does not contain a subscription endpoint.
Nevertheless, an endpoint that exposes a web service interface to create, update, and delete subscriptions would provide a client's subscription's filtering criteria to be used by Catalog's Event Processor to determine which create, update, and delete events are of interest to the client.
The endpoint client also provides the callback URL of the event consumer to be called when an event matching the subscription's criteria is found.
This callback to the event consumer is made by a Delivery Method implementation that the client provides when the subscription is created. 
Whenever an event occurs in the Catalog matching the subscription, the Delivery Method implementation will be called by the Event Processor. 
The Delivery Method will, in turn, send the event notification out to the event consumer. 
As part of the subscription creation process, the Catalog verifies that the event consumer at the specified callback URL is available to receive callbacks.
Therefore, the client must ensure the event consumer is running prior to creating the subscription.
The Catalog completes the subscription creation by executing any pre-subscription Catalog Plugins, and then registering the subscription with the OSGi Service Registry.
The Catalog does not persist subscriptions by default.

===== Delivery Method

A Delivery Method provides the operation (created, updated, deleted) for how an event's metacard can be delivered.

A Delivery Method is associated with a subscription and contains the callback URL of the event consumer to be notified of events.
The Delivery Method encapsulates the operations to be invoked by the Event Processor when an event matches the criteria for the subscription.
The Delivery Method's operations are responsible for invoking the corresponding operations on the event consumer associated with the callback URL.

===== Event Processor

The Event Processor provides an engine that creates, updates, and deletes subscriptions for event notification.
These subscriptions optionally specify a filter criteria so that only events of interest to the subscriber are posted for notification.

An internal subscription tracker monitors the OSGi registry, looking for subscriptions to be added (or deleted).
When it detects a subscription being added, it informs the Event Processor, which sets up the subscription's filtering and is responsible for posting event notifications to the subscriber when events satisfying their criteria are met.

===== Event Processing and Notification

As metacards are created, updated, and deleted, the Catalog's Event Processor is invoked (as a post-ingest plugin) for each of these events.
TheEvent Processor applies the filter criteria for each registered subscription to each of these ingest events to determine if they match the criteria.
If an event matches a subscription's criteria, any pre-delivery plugins that are installed are invoked, the subscription's Delivery Method is retrieved, and its operation corresponding to the type of ingest event is invoked. 
For example, the DeliveryMethod's `created()` function is called when a metacard is created.
The Delivery Method's operations subsequently invoke the corresponding operation in the client's event consumer service, which is specified by the callback URL provided when the Delivery Method was created.

===== Standard Event Processor

The Standard Event Processor is an implementation of the Event Processor and provides the ability to create/delete subscriptions.
Events are generated by the ${ddf-catalog}Framework as metacards are created/updated/deleted and the Standard Event Processor is called since it is also a Post-Ingest Plugin.
The Standard Event Processor checks each event against each subscription's criteria.

When an event matches a subscription's criteria the Standard Event Processor:

* invokes each pre-delivery plugin on the metacard in the event
* invokes the Delivery Method's operation corresponding to the type of event being processed, e.g., created operation for the creation of a metacard

===== Installing and Uninstalling

The StandardEvent Processor is automatically installed/uninstalled when the 
Standard Catalog Framework is installed/uninstalled.

===== Known Issues

The Standard Event processor currently broadcasts federated events and should not.
It should only broadcast events that were generated locally, all other events should be dropped.

==== Fanout Event Processor

The Fanout Event Processor is used when ${branding} is configured as a fanout proxy.
The only difference between the Fanout Event Processor and the Standard Event Processor is that the source ID in the metacard of each event is overridden with the fanout's source ID.
This is done to hide the source names of the Remote Sources in the fanout's enterprise.
Otherwise, the Fanout Event Processor functions exactly like the Standard Event Processor. 

===== Installing and Uninstalling

The Fanout Event Processor is automatically installed/uninstalled when the Catalog Fanout Framework App is installed/uninstalled.

===== Known Issues

None

==== Working with Subscriptions

===== Creating a Subscription

====== Using ${branding} Implementation

If applicable, the implementation of `Subscription` that comes with ${branding} should be used.
It is available at `${ddf-branding}.catalog.event.impl.SubscriptionImpl` and offers a constructor that takes in all of the necessary objects.
Specifically, all that is needed is a `Filter`, `DeliveryMethod`, `Set<String>` of source IDs, and a `boolean` for enterprise.

The following is an example code stub showing how to create a new instance of Subscription using the ${branding} implementation. 

[source,java,linenums]
----
// Create a new filter using an imported FilterBuilder
Filter filter = filterBuilder.attribute(Metacard.ANY_TEXT).like().text("*");
 
// Create a implementation of Delivery Method
DeliveryMethod deliveryMethod = new MyCustomDeliveryMethod();
 
// Create a set of source ids
// This set is empty as the subscription is not specific to any sources
Set<String> sourceIds = new HashSet<String>();
 
// Set the isEnterprise boolean value
// This subscription example should notifications from all sources (not just local)
boolean isEnterprise = true;

Subscription subscription = new SubscriptionImpl(filter, deliveryMethod, sourceIds,isEnterprise);
----

====== Creating a Custom Implementation

To create a subscription in ${branding} the developer needs to implement the `${ddf-branding}.catalog.event.Subscription` interface. 
This interface extends `org.opengis.filter.Filter` in order to represent the subscription's filter criteria. 
Furthermore, the `Subscription` interface contains a `DeliveryMethod` implementation.  

When implementing `Subscription`, the developer will need to override the methods `accept` and `evaluate` from the `Filter`. 
The `accept` method allows the visitor pattern to be applied to the `Subscription`. 
A `FilterVisitor` can be passed into this method in order to process the `Subscription's Filter`.
In ${branding}, this method is used to convert the `Subscription's Filter` into a predicate format that is understood by the Event Processor. 
The second method inherited from `Filter` is `evaluate`. 
This method is used to evaluate an object against the `Filter`'s criteria in order to determine if it matches the criteria. 

[TIP]
====
The functionality of these overridden methods is typically delegated to the `Filter` implementation that the `Subscription` is using.
====

The developer must also define `getDeliveryMethod`. 
This class is called when the an event occurs that matches the filter of the subscription.

The other two methods required because `Subscription` implements `Federatable` are `isEnterprise` and `getSourceIds`, which indicate that the subscription should watch for events occurring on all sources in the enterprise or on specified sources. 

The following is an implementation stub of `Subscription` that comes with ${branding} and is available at `${ddf-branding}.catalog.event.impl.SubscriptionImpl`.

.SubscriptionImpl
[source,java,linenums]
----
public class SubscriptionImpl implements Subscription {
    private Filter filter;

    private DeliveryMethod dm;

    private Set<String> sourceIds;

    private boolean enterprise;

    public SubscriptionImpl(Filter filter, DeliveryMethod dm, Set<String> sourceIds,
            boolean enterprise) {
        this.filter = filter;
        this.dm = dm;
        this.sourceIds = sourceIds;
        this.enterprise = enterprise;
    }

    @Override
    public boolean evaluate(Object object) {
        return filter.evaluate(object);
    }

    @Override
    public Object accept(FilterVisitor visitor, Object extraData) {
        return filter.accept(visitor, extraData);
    }

    @Override
    public Set<String> getSourceIds() {
        return sourceIds;
    }

    @Override
    public boolean isEnterprise() {
        return enterprise;
    }

    @Override
    public DeliveryMethod getDeliveryMethod() {
        return dm;
    }
}
----

==== Registering a Subscription

Once a `Subscription` is created, it needs to be registered in the OSGi Service Registry as a `${ddf-branding}.catalog.event.Subscription` service. 
This is necessary for the `Subscription` to be discovered by the Event Processor. 
Typically, this is done in code after the `Subscription` is instantiated. 
When the `Subscription` is registered, a unique ID will need to be specified using the key `subscription-id`.
This will be used to delete the `Subscription` from the OSGi Service Registry. 
Furthermore, the `ServiceRegistration`, which is the return value from registering a `Subscription`, should be monitored in order to remove the `Subscription` later.
The following code shows how to correctly register a `Subscription` implementation in the registry using the above `SubscriptionImpl` for clarity:

.Registering a Subscription
[source,java,linenums]
----
// Map to keep track of registered Subscriptions.  Used for unregistering Subscriptions.
Map<String, ServiceRegistration<Subscription>> subscriptions = new HashMap<String, ServiceRegistration<Subscription>>();

// New subscription using the ${branding} Implementation of subscription
Subscription subscription = new SubscriptionImpl(filter, deliveryMethod, sourceIds,isEnterprise);

// Specify the subscription-id to uniquely identify the Subscription
String subscriptionId = "0123456789abcdef0123456789abcdef";
Dictionary<String, String> properties = new Hashtable<String, String>();
properties.put("subscription-id", subscriptionId);

// Service registration requires an instance of the OSGi bundle context
// Register subscription and keep track of the service registration
ServiceRegistration<Subscription> serviceRegistration = context.registerService(${ddf-branding}.catalog.event.Subscription.class, subscription, properties );
subscriptions.put(subscriptionId, serviceRegistration);
----

==== Creating a Delivery Method

The Event Processor obtains the subscription's `DeliveryMethod` and invokes one of its four methods when an event occurs. 
The `DeliveryMethod` then handles that invocation and communicates an event to a specified consumer service outside of ${branding}.

The Event Processor calls the `DeliveryMethod`'s`created` method when a new metacard matching the filter criteria is added to the Catalog. 
It calls the `deleted` method when a metacard that matched the filter criteria is removed from the Catalog. 
`updatedHit` is called when a metacard is updated and the new metacard matches the subscription. 
`updatedMiss` is different in that it is only called if the old metacard matched the filter but the new metacard no longer does. 
An example of this would be if the filter contains spatial criteria consisting of Arizona. 
If a plane is flying over Arizona, the Event Processor will repeatedly call `updatedHit` as the plane flies from one side to the other while updating its position in the Catalog.
This happens because the updated records continually match the specified criteria. 
If the plane crosses into New Mexico, the previous metacard will have matched the filter, but the new metacard will not. 
Thus, `updatedMiss` gets called.  

The following is an implementation stub for `DeliveryMethod`:

.DeliveryMethodImpl
[source,java,linenums]
----
public class DeliveryMethodImpl implements DeliveryMethod {

    @Override
    public void created(Metacard newMetacard) {
        // Perform custom code on create
    }

    @Override
    public void updatedHit(Metacard newMetacard, Metacard oldMetacard) {
		// Perform custom code on update (where both new and old metacards matched filter)
    }

    @Override
    public void updatedMiss(Metacard newMetacard, Metacard oldMetacard) {
		// Perform custom code on update (where one of the two metacards did not match the filter)
    }

    @Override
    public void deleted(Metacard oldMetacard) {
     // Perform custom code on delete
    }
}
----

==== Deleting a Subscription

To remove a subscription from ${branding}, the subscription ID is required.
Once this is provided, the `ServiceRegistration` for the indicated `Subscription` should be obtained from the `Subscriptions` Map.
Then the `Subscription` can be removed by unregistering the service.
The following code demonstrates how this is done:

.Delete Subscription
[source,java,linenums]
----
String subscriptionId = "0123456789abcdef0123456789abcdef";

//Obtain service registration from subscriptions Map based on subscription ID
ServiceRegistration<Subscription> sr = subscriptions.get(subscriptionId);

//Unregister Subscription from OSGi Service Registry
sr.unregister();

//Remove Subscription from Map keeping track of registered Subscriptions.
subscriptions.remove(subscriptionId);
----

=== Extending Resource Components

Resource components are used when working with resources, i.e., the data that is represented by the cataloged metadata.

A resource is a URI-addressable entity that is represented by a metacard. Resources may also be known as products or data.

Resources may exist either locally or on a remote data store.

Examples of resources include:

* NITF image
* MPEG video
* Live video stream
* Audio recording
* Document

A resource object in ${branding} contains an `InputStream` with the binary data of the resource. 
It describes that resource with a name, which could be a file name, URI, or another identifier. 
It also contains a mime type or content type that a client can use to interpret the binary data.  

.Resources Architecture
[ditaa, catalog_architecture_resources, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |c369   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Resource Readers

A resource reader retrieves resources associated with metacards via URIs.
Each resource reader must know how to interpret the resource's URI and how to interact with the data store to retrieve the resource.

There can be multiple resource readers in a Catalog instance.
The `Catalog Framework` selects the appropriate resource reader based on the scheme of the resource's URI. 

In order to make a resource reader available to the Catalog Framework, it must be exported to the OSGi Service Registry as a `${ddf-branding}.catalog.resource.ResourceReader`. 

===== URL Resource Reader

The `URLResourceReader` is an implementation of `ResourceReader` which is included in the ${branding} Catalog. 
It obtains a resource given an http, https, or file-based URL. 
The `URLResourceReader` will connect to the provided Resource URL and read the resource's bytes into an `InputStream`.  

[WARNING]
====
When a resource linked using a file-based URL is in the product cache, the `URLResourceReader`&#8217;s rootResourceDirectories is not checked when downloading the product.
It is downloaded from the product cache which bypasses the `URLResourceReader`.
For example, if path `/my/valid/path` is configured in the `URLResourceReader`&#8217;s rootResourceDirectories and one downloads the product with resource-uri `file:///my/valid/path/product.txt` and then one removes `/my/valid/path` from the `URLResourceReader`&#8217;s `rootResourceDirectories` configuration, the product will still be accessible via the product cache.
====

===== Installing and Uninstalling

`URLResourceReader` is installed by default with the ${branding} Catalog.

===== Configuring

====== Configurable Properties

_URL Resource Reader_

[cols="1,1,3,1,1", options="header"]
|===

|Property
|Type
|Description
|Default Value
|Required

|`rootResourceDirectories`
|String array
|Specifies the only directories the `URLResourceReader` has access to when attempting to download resources linked using file-based URLs (i.e. the metacard attribute resource-uri uses the file URI scheme). This property is used to restrict the `URLResourceReader`&#8217;s access to the file system. The `URLResourceReader` can be given full access to the file system by setting the `rootResourceDirectories` property to the root directory (e.g. `/`), but this configuration is not recommended.
|<${ddf-branding}.home>/data/products
|yes

|===

===== Using

`URLResourceReader` will be used by the Catalog Framework to obtain a resource whose metacard is cataloged in the local data store.
This particular `ResourceReader` will be chosen by the `CatalogFramework` if the requested resource's URL has a protocol of `http`, `https`, or `file`.  

For example, requesting a resource with the following URL will make the Catalog Framework invoke the `URLResourceReader` to retrieve the product.

.Example
[source,http]
----
file:///home/users/${ddf-branding}_user/data/example.txt
----

If a resource was requested with the URL `udp://123.45.67.89:80/SampleResourceStream`, the `URLResourceReader` would _not_ be invoked.

===== Implementation Details

Supported Schemes:

* http
* https
* file

[NOTE]
====
If a file-based URL is passed to the `URLResourceReader`, that file path needs to be accessible by the ${branding} instance.
====

===== Known Issues

None

==== Developing a Resource Reader

A `ResourceReader` is a class that retrieves a resource or product from a native/external source and returns it to ${branding}.
A simple example is that of a File `ResourceReader`.
It takes a file from the local file system and passes it back to ${branding}.
New implementations can be created in order to support obtaining Resources from various Resource data stores. 

===== Create a New ResourceReader

Complete the following procedure to create a `ResourceReader`.

. Create a Java class that implements the `${ddf-branding}.catalog.resource.ResourceReader` interface.
. Deploy the OSGi bundled packaged service to the ${branding} run-time.

===== Implementing the ResourceReader Interface

[source,java,linenums]
----
public class TestResourceReader implements ${ddf-branding}.catalog.resource.ResourceReader
----

`ResourceReader` has a couple of key methods where most of the work is performed.

[NOTE]
====
*URI* +
It is recommended to become familiar with the Java API URI class in order to properly build a `ResourceReader`. 
Furthermore, a URI should be used according to its http://www.w3.org/Addressing/URL/uri-spec.html[specification].
====

===== retrieveResource

[source,java,linenums]
----
public ResourceResponse retrieveResource( URI uri, Map<String, Serializable> arguments )throws IOException, ResourceNotFoundException, ResourceNotSupportedException;
----

This method is the main entry to the `ResourceReader`.
It is used to retrieve a `Resource` and send it back to the caller (generally the `CatalogFramework`).
Information needed to obtain the entry is contained in the `URI` reference.
The URI Scheme will need to match a scheme specified in the `getSupportedSchemes` method.
This is how the CatalogFramework determines which `ResourceReader` implementation to use. 
If there are multiple `ResourceReaders` supporting the same scheme, these `ResourceReaders` will be invoked iteratively. 
Invocation of the `ResourceReaders` stops once one of them returns a `Resource`.

Arguments are also passed in.
These can be used by the `ResourceReader` to perform additional operations on the resource.

An example of how `URLResourceReader` (located in the source code at `/trunk/${ddf-branding}/catalog/resource/URLResourceReader.java`) implements the `getResource` method.
This `ResourceReader` simply reads a file from a URI.

[NOTE]
====
The `Map<String, Serializable> arguments` parameter is passed in to support any options or additional information associated with retrieving the resource.
====

===== Implement `retrieveResource()`

. Define supported schemes (e.g., file, http, etc.).
. Check if the incoming URI matches a supported scheme. If it does not, throw `ResourceNotSupportedException`.

.Example:
[source,java,linenums]
----
if ( !uri.getScheme().equals("http") )
 {
   throw new ResourceNotSupportedException("Unsupported scheme received, was expecting http")
 }
----

. Implement the business logic.
. For example, the `URLResourceReader` will obtain the resource through a connection:

[source,java,linenums]
----
URL url = uri.toURL();
URLConnection conn = url.openConnection();
String mimeType = conn.getContentType();
if ( mimeType == null ) {
    mimeType = URLConnection.guessContentTypeFromName( url.getFile() );
}
InputStream is = conn.getInputStream();
----

[NOTE]
====
The `Resource` needs to be accessible from the ${branding} installation (see the rootResourceDirectories property of the `URLResourceReader`). 
This includes being able to find a file locally or reach out to a remote URI. 
This may require Internet access, and ${branding} may need to be configured to use a proxy (`http.proxyHost` and `http.proxyPort` can be added to the system properties on the command line script).
====

. Return `Resource` in `ResourceResponse`.

For example:
[source,java,linenums]
----
return ResourceResponseImpl( new ResourceImpl( new BufferedInputStream( is ), new MimeType( mimeType ), url.getFile() ) );
----

If the Resource cannot be found, throw a `ResourceNotFoundException`.  

===== `getSupportedSchemes`

[source,java]
----
public Set<String> getSupportedSchemes();
----

This method lets the `ResourceReader` inform the CatalogFramework about the type of URI scheme that it accepts and should be passed.
For single-use ResourceReaders (like a URLResourceReader), there may be only one scheme that it can accept while others may understand more than one.
A ResourceReader must, at minimum, accept one qualifier. 
As mentioned before, this method is used by the `CatalogFramework` to determine which `ResourceReader` to invoke. 

[NOTE]
====
*`ResourceReader` extends `Describable`* +
Additionally, there are other methods that are used to uniquely describe a `ResourceReader`.
 The `describe` methods are straight-forward and can be implemented with guidance from the Javadoc.
====

===== Export to OSGi Service Registry

In order for the `ResourceReader` to be used by the `CatalogFramework`, it should be exported to the OSGi Service Registry as a `${ddf-branding}.catalog.resource.ResourceReader`.

See the XML below for an example:

.Blueprint example
[source,xml,linenums]
----
<bean id="[[customResourceReaderId]]" class="[[example.resource.reader.impl.CustomResourceReader]]" />
<service ref="[[customResourceReaderId]]" interface="${ddf-branding}.catalog.source.ResourceReader" />
----

==== Resource Writers

A resource writer stores a resource and produces a URI that can be used to retrieve the resource at a later time.
The resource URI uniquely locates and identifies the resource.
Resource writers can interact with an underlying data store and store the resource in the proper place.
Each implementation can do this differently, providing flexibility in the data stores used to persist the resources.

===== Examples

The Catalog reference implementation currently does not include any resource writers out of the box.

==== Developing a Resource Writer

A `ResourceWriter` is an object used to store or delete a `Resource`. 
`ResourceWriter` objects should be registered within the OSGi Service Registry, so clients can retrieve an instance when clients need to store a `Resource`. 

===== Create a New `ResourceWriter`

Complete the following procedure to create a `ResourceWriter`.

. Create a Java class that implements the `${ddf-branding}.catalog.resource.ResourceWriter` interface.

.ResourceWriter Implementation Skeleton
[source,java,linenums]
----
import java.io.IOException;
import java.net.URI;
import java.util.Map;
import ${ddf-branding}.catalog.resource.Resource;
import ${ddf-branding}.catalog.resource.ResourceNotFoundException;
import ${ddf-branding}.catalog.resource.ResourceNotSupportedException;
import ${ddf-branding}.catalog.resource.ResourceWriter;

public class SampleResourceWriter implements ResourceWriter {

	@Override
	public void deleteResource(URI uri, Map<String, Object> arguments) throws ResourceNotFoundException, IOException {
	   // WRITE IMPLEMENTATION
	 }

	@Override
	public URI storeResource(Resource resource, Map<String, Object> arguments)throws ResourceNotSupportedException, IOException {
	   // WRITE IMPLEMENTATION
	   return null;
	}

	@Override
	public URI storeResource(Resource resource, String id, Map<String, Object> arguments) throws ResourceNotSupportedException, IOException {
	   // WRITE IMPLEMENTATION
	   return null;
	}

}
----
. Register the implementation as a Service in the OSGi Service Registry.

.Blueprint Service Registration Example
[source,xml,linenums]
----
...
<service ref="[[ResourceWriterReference]]" interface="${ddf-branding}.catalog.resource.ResourceWriter" />
...
----

. Deploy the OSGi bundled packaged service to the ${branding} run-time (Refer to the Working with OSGi - Bundles section.)

[TIP]
====
*ResourceWriter Javadoc* +
Refer to the ${ddf-catalog} API Javadoc for more information about the methods required for implementing the interface. 
====

==== Developing a Registry Client

Registry Clients create Federated Sources using the OSGi Configuration Admin.
Developers should reference an individual `Source`'s (Federated, Connected, or Catalog Provider) documentation for the Configuration properties (such as a Factory PID, addresses, intervals, etc) necessary to establish that `Source` in the framework. 

===== Example

.Creating a Source Configuration
[source,java,linenums]
----
org.osgi.service.cm.ConfigurationAdmin configurationAdmin = getConfigurationAdmin() ;
org.osgi.service.cm.Configuration currentConfiguration = configurationAdmin.createFactoryConfiguration(getFactoryPid(), null);
Dictionary properties = new Dictionary() ;
properties.put(QUERY_ADDRESS_PROPERTY,queryAddress);
currentConfiguration.update( properties );
----

Note that the `QUERY_ADDRESS_PROPERTY` is specific to this Configuration and might not be required for every `Source`.
The properties necessary for creating a Configuration are different for every `Source`. 

==== Working with Resources

===== Metacards and Resources

Metacards are used to describe a resource through metadata. 
This metadata includes the time the resource was created, the location where the resource was created, etc. 
A ${branding} `Metacard` contains the `getResourceUri` method, which is used to locate and retrieve its corresponding resource.

===== Retrieve Resource

When a client attempts to retrieve a resource, it must provide a metacard ID or URI corresponding to a unique resource. 
As mentioned above, the resource URI is obtained from a `Metacard`'s `getResourceUri` method. 
The `CatalogFramework` has three methods that can be used by clients to obtain a resource: `getEnterpriseResource`, `getResource`, and `getLocalResource`.
The `getEnterpriseResource` method invokes the `retrieveResource` method on a local `ResourceReader` as well as all the `Federated` and `Connected` Sources inthe ${branding} enterprise. 
The second method, `getResource`, takes in a source ID as a parameter and only invokes `retrieveResource` on the specified `Source`. 
The third method invokes `retrieveResource` on a local `ResourceReader`. 

The parameter for each of these methods in the `CatalogFramework` is a 	`ResourceRequest`. 
${branding} includes two implementations of `ResourceRequest`: `ResourceRequestById` and `ResourceRequestByProductUri`. 
Since these implementations extend `OperationImpl`, they can pass a `Map` of generic properties through the `CatalogFramework` to customize how the resource request is carried out. 
One example of this is explained in the Options section below. 
The following is a basic example of how to create a `ResourceRequest` and invoke the `CatalogFramework` resource retrieval methods to process the request.   

.Retrieve Resource Example
[source,java,linenums]
----
Map<String, Serializable> properties = new HashMap<String, Serializable>();
properties.put("PropertyKey1", "propertyA"); //properties to customize Resource retrieval
ResourceRequestById resourceRequest = new ResourceRequestById("0123456789abcdef0123456789abcdef", properties); //object containing ID of Resource to be retrieved
String sourceName = "LOCAL_SOURCE"; //the Source ID or name of the local Catalog or a Federated Source
ResourceResponse resourceResponse; //object containing the retrieved Resource and the request that was made to get it.
resourceResponse = catalogFramework.getResource(resourceRequest, sourceName); //Source-based retrieve Resource request
Resource resource = resourceResponse.getResource(); //actual Resource object containing InputStream, mime type, and Resource name
----

`${ddf-branding}.catalog.resource.ResourceReader` instances can be discovered via the OSGi Service Registry.
The system can contain multiple `ResourceReaders`. 
The `CatalogFramework` determines which one to call based on the scheme of the resource's URI and what schemes the `ResourceReader` supports. 
The supported schemes are obtained by a `ResourceReader`'s `getSupportedSchemes` method. 
As an example, one `ResourceReader` may know how to handle file-based URIs with the scheme 	`file`, whereas another `ResourceReader` may support HTTP-based URIs with the scheme `http`.

The `ResourceReader` or `Source` is responsible for locating the resource, reading its bytes, adding the binary data to a `Resource` implementation, then returning that `Resource` in a `ResourceResponse`. 
The `ResourceReader` or `Source` is also responsible for determining the `Resource`'s name and mime type, which it sends back in the `Resource` implementation.  
 

===== Options

Options can be specified on a retrieve resource request made through any of the supporting endpoint. 
To specify an option for a retrieve resource request, the endpoint needs to first instantiate a `ResourceRequestByProductUri` or a `ResourceRequestById`. 
Both of these `ResourceRequest` implementations allow a `Map` of properties to be specified. 
Put the specified option into the `Map` under the key `RESOURCE_OPTION`.  

.Retrieve Resource with Options
[source,java,linenums]
----
Map<String, Serializable> properties = new HashMap<String, Serializable>();
properties.put("RESOURCE_OPTION", "OptionA");
ResourceRequestById resourceRequest = new ResourceRequestById("0123456789abcdef0123456789abcdef", properties);
----

Depending on the support that the `ResourceReader` or `Source` provides for options, the `properties``Map` will be checked for the `RESOURCE_OPTION` entry. 
If that entry is found, the option will be handled; however, the `ResourceReader` or `Source` supports options. 
If the `ResourceReader` or `Source` does not support options, that entry will be ignored.

A new `ResourceReader` or `Source` implementation can be created to support options in a way that is most appropriate. 
Since the option is passed through the catalog framework as a property, the `ResourceReader` or `Source` will have access to that option as long as the endpoint supports options.       

===== Store Resource

Resources are saved using a `ResourceWriter`. 
`${ddf-branding}.catalog.resource.ResourceWriter` instances can be discovered via the OSGi Service Registry.
Once retrieved, the `ResourceWriter` instance provides clients a way to store resources and get a corresponding URI that can be used to subsequently retrieve the resource via a `ResourceReader`. 
Simply invoke either of the `storeResource` methods with a resource and any potential arguments.
 
The `ResourceWriter` implementation is responsible for determining where the resource is saved and how it is saved. 
This allows flexibility for a resource to be saved in any one of  a variety of data stores or file systems. 
The following is an example of how to use a generic implementation of `ResourceWriter`.

[source,java,linenums]
----
InputStream inputStream = <Video_Input_Stream>; //InputStream of raw Resource data
MimeType mimeType = new MimeType("video/mpeg"); //Mime Type or content type of Resource
String name = "Facility_Video";  //Descriptive Resource name
Resource resource = new ResourceImpl(inputStream, mimeType, name);
Map<String, Object> optionalArguments = new HashMap<String, Object>();
ResourceWriter writer = new ResourceWriterImpl();
URI resourceUri; //URI that can be used to retrieve Resource
resourceUri = writer.storeResource(resource, optionalArguments); //Null can be passed in here
----

===== BinaryContent

`BinaryContent` is an object used as a container to store translated or transformed ${branding} components. 
`Resource` extends `BinaryContent` andincludes a `getName` method.  `
BinaryContent` has methods to get the `InputStream`, `byte` array, MIME type, and size of the represented binary data.
An implementation of `BinaryContent` (`BinaryContentImpl`) can be found in the Catalog API in the `${ddf-branding}.catalog.data` package.

====== Additional Information

* URI on Wikipedia (http://en.wikipedia.org/wiki/Uniform_resource_identifier)
* URI Javadoc (http://docs.oracle.com/javase/6/docs/api/java/net/URI.html)
