
The ${ddf-catalog} provides a framework for storing, searching, processing, and transforming information.
Clients typically perform query, create, read, update, and delete (QCRUD) operations against the Catalog.  
At the core of the Catalog functionality is the Catalog Framework, which routes all requests and responses through the system, invoking additional processing per the system configuration.

This guide supports developers creating extensions of the existing framework.

=== Whitelist

The following packages have been exported by the ${ddf-catalog} application and are approved for use by third parties:

* `${ddf-branding-lowercase}.camel.component.catalog`
* `${ddf-branding-lowercase}.catalog`
* `${ddf-branding-lowercase}.catalog.cache`
* `${ddf-branding-lowercase}.catalog.data`
* `${ddf-branding-lowercase}.catalog.data.metacardtype`
* `${ddf-branding-lowercase}.catalog.event`
* `${ddf-branding-lowercase}.catalog.federation`
* `${ddf-branding-lowercase}.catalog.federation.impl`
* `${ddf-branding-lowercase}.catalog.filter`
* `${ddf-branding-lowercase}.catalog.filter.delegate`
* `${ddf-branding-lowercase}.catalog.impl.filter`
* `${ddf-branding-lowercase}.catalog.operation`
* `${ddf-branding-lowercase}.catalog.plugin`
* `${ddf-branding-lowercase}.catalog.plugin.groomer`
* `${ddf-branding-lowercase}.catalog.pubsub`
* `${ddf-branding-lowercase}.catalog.pubsub.tracker`
* `${ddf-branding-lowercase}.catalog.resource`
* `${ddf-branding-lowercase}.catalog.resource.data`
* `${ddf-branding-lowercase}.catalog.resource.impl`
* `${ddf-branding-lowercase}.catalog.resourceretriever`
* `${ddf-branding-lowercase}.catalog.service`
* `${ddf-branding-lowercase}.catalog.source`
* `${ddf-branding-lowercase}.catalog.transform`
* `${ddf-branding-lowercase}.catalog.transformer.api`
* `${ddf-branding-lowercase}.catalog.transformer.metacard.geojson`
* `${ddf-branding-lowercase}.catalog.util`
* `${ddf-branding-lowercase}.catalog.validation`
* `${ddf-branding-lowercase}.common`
* `${ddf-branding-lowercase}.geo.formatter`
* `${ddf-branding-lowercase}.util`
* `org.codice.${ddf-branding-lowercase}.endpoints`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest`
* `org.codice.${ddf-branding-lowercase}.endpoints.rest.action`
* `org.codice.${ddf-branding-lowercase}.opensearch.query`
* `org.codice.${ddf-branding-lowercase}.opensearch.query.filter`

=== Catalog Architecture

.Catalog Architecture
[ditaa,catalog_architecture]
....

                /-=-----------------\
                |      Clients      |
                \-------------------/
                          |
                          v
                /-------------------\
                |cDEFEndpoints      |
                +------------+------+
                |cDEF        |cDEF  |
                | Operations | Data |
/---------------+------------+------+------------+---------\    +--------+
|cDEF           |cDEF               |cDEF        |cDEF     |<-> |        |
|  Transformers |                   | Federation | Sources |    |External|
+---------------+ Catalog Framework +------------+---------+<-> |  Data  |
|cDEF           |                   |cDEF   Eventing       |    |Holdings|
|   Catalog     |                   +------------+---------+<-> |    {s} |
|   Plugins     |                   |cDEF   Resources      |    +------=-+
\---------------+-------------------+----------------------/
                |cDEF               |
                | Catalog Provider  |
                \-------------------/
                          ^
                          |
                          v                         Legend
                  +---------------+                /---------------------\
                  |{s}            |                |cDEF ${ddf-branding} Component   |
                  |  Data Store   |                \---------------------/
                  |               |                /---------------------\
                  +------------=--+                | External Component  |
                                                   \--------------------=/

....

=== Catalog Application Services

As an OSGi system, ${branding} does Intra-module conversations via services. 
The following summarizes ${branding} internal services within the Catalog application.

==== Catalog Framework

The `CatalogFramework` is the routing mechanism between catalog components that provides integration points for the Catalog Plugins.
An endpoint invokes the active Catalog Framework, which calls any configured Pre-query or Pre-ingest plug-ins.
The selected federation strategy calls the active Catalog Provider and any connected or federated sources.
Then, any Post-query or Post-ingest plug-ins are invoked.
Finally, the appropriate response is returned to the calling endpoint.

==== Sources

A source is a system consisting of a catalog containing Metacards.

==== CatalogProvider

The Catalog Provider is an API is used to interact with data providers, such as files systems or databases, to query, create, update, or delete data.
The provider also translates between ${branding} objects and native data formats.

==== `ConnectedSource`

A Connected Source is a local or remote source that is always included in every local and enterprise query, but is hidden from being queried individually.

==== `FederatedSource`

A Federated Source is a remote source that can be optionally included or excluded from queries.

==== Plugins

Plugins are additional tools to use to add additional business logic at certain points, depending on the type of plugin.
Plugins can be designed to run before or after certain processes.
They are often used for validation, optimization, or logging.

===== "Pre-" Plugins

These plugins are executed before an action is taken.
[cols="2*", options="header"]
|===

|Plugin
|Description

|Pre-IngestPlugin
|Performs any changes to a resource prior to ingesting it.

|Pre-Query Plugin
|Performs any changes to query before executing.

|Pre-Resource Plugin
|Performs any changes to a resource associated with a metacard prior to download.

|Pre-Subscription Plugin 
|Performs any changes before creating a subscription.

|Pre-Delivery Plugin
|Performs any changes before delivered a subscribed event.

|===

===== “Post-“ Plugins

[cols="2*", options="header"]
|===

|Plugin
|Description

|Post-Ingest Plugin
|Performs actions after ingest is completed.

|Post-Query Plugin
|Performs any changes to response after query completes.

|Post-Get Resource Plugin   
|performs any changes to a resource after download

|===

==== Transformers

Transformers are used to alter the format of a resource or its metadata to or from the catalog’s metacard format

[cols="2*", options="header"]
|===

|Transformer
|Description

|Input Transformers
|create metacards from input.

|Metacard Transformers
|translates a metacard from catalog metadata to a specific data format.

|Query Response Transformers
|translates a list of Result objects to a desired format.

|===

=== Catalog Development Fundamentals

This section introduces the fundamentals of working with the Catalog API the OGC Filter for Queries.

==== Simple Catalog API Implementations

The Catalog API implementations, which are denoted with the suffix of `Impl` on the Java file names, have multiple purposes and uses.

* First, they provide a good starting point for other developers to extend functionality in the framework. For instance, extending the `MetacardImpl` allows developers to focus less on the inner workings of ${branding} and more on the developer's intended purposes and objectives. 

* Second, the Catalog API Implementations display the proper usage of an interface and an interface's intentions. Also, they are good code examples for future implementations. If a developer does not want to extend the simple implementations, the developer can at least have a working code reference to base future development.

==== Use of the Whiteboard Design Pattern

The ${ddf-catalog} makes extensive use of the Whiteboard Design Pattern.
Catalog Components are registered as services in the OSGi Service Registry, and the Catalog Framework or any other clients tracking the OSGi Service Registry are automatically notified by the OSGi Framework of additions and removals of relevant services.

The Whiteboard Design Pattern is a common OSGi technique that is derived from a technical whitepaper provided by the OSGi Alliance in 2004.
It is recommended to use the Whiteboard pattern over the Listener pattern in OSGi because it provides less complexity in code (both on the client and server sides), fewer deadlock possibilities than the Listener pattern, and closely models the intended usage of the OSGi framework.

==== Working with Queries

Clients use `${ddf-branding}.catalog.operation.Query` objects to describe which metacards are needed from Sources. 
Query objects have two major components:

* Filter 
* Query Options

A Source uses the Filter criteria constraints to find the requested set of metacards within its domain of metacards.
The Query Options are used to further restrict the Filter's set of requested metacards.

===== Query Options
[cols="2*", options="header"]
|===
|Option
|Description

|`StartIndex`
|1-based index that states which metacard the Source should return first out of the requested metacards.

|`PageSize`
|Represents the maximum amount of metacards the Source should return.

|`SortBy`
|Determines how the results are sorted and on which property.

|`RequestsTotalResultsCount`
|Determines whether the total number of results should be returned.

|`TimeoutMillis`
|The amount of time in milliseconds before the query is to be abandoned.

|===

===== Creating a query
The easiest way to create a Query is to use `${ddf-branding}.catalog.operation.QueryImpl` object.
It is first necessary to create an OGC Filter object then set the Query Options after `QueryImpl` has been constructed.

.QueryImpl Example 1
[source,java,linenums]
----
/*
  Builds a query that requests a total results count and
  that the first record to be returned is the second record found from
  the requested set of metacards.
 */

 String property = ...;

 String value = ...;

 org.geotools.filter.FilterFactoryImpl filterFactory = new FilterFactoryImpl() ;

 QueryImpl query = new QueryImpl( filterFactory.equals(filterFactory.property(property),

filterFactory.literal(value))) ;

 query.setStartIndex(2) ;

 query.setRequestsTotalResultsCount(true);
----

===== Evaluating a query

Every Source must be able to evaluate a Query object.
Nevertheless, each Source could evaluate the Query differently depending on what that Source supports as to properties and query capabilities.
For instance, a common property all Sources understand is id, but a Source could possibly store frequency values under the property name "frequency."
Some Sources may not support frequency property inquiries and will
throw an error stating it cannot interpret the property.
In addition, some Sources might be able to handle spatial operations, while others might not.
A developer should consult a Source's documentation for the limitations, capabilities, and properties that a Source can support.

=== Working with Filters

An OGC Filter is a Open Geospatial Consortium (OGC) standard (
http://www.opengeospatial.org/standards/filter
) that describes a query expression
in terms of Extensible Markup Language (XML) and key-value pairs (KVP). The ${ddf-catalog} Framework does not use the XML representation of
the OGC Filter standard. ${branding} instead utilizes the Java implementation provided by GeoTools (
http://geotools.org/
). GeoTools provides Java
equivalent classes for OGC Filter XML elements. GeoTools originally provided the standard Java classes for the OGC Filter Encoding 1.0 under the
package name 
`org.opengis.filter`. The same package name is used today and is currently used by ${branding}.  Java developers do not parse or
view the XML representation of a 
Filter
 in ${branding}. Instead, developers use only the Java objects to complete query tasks.

Note that the ${ddf-branding}.catalog.operation.Query interface extends the org.opengis.filter.Filter interface, which means that a Query object is an OGC Java Filter with Query Options.

.A Query is an OGC Filter
[source,java]
----
public interface Query extends Filter
----

==== Using Filters

==== FilterBuilder API

To abstract developers from the complexities of working with the Filter interface directly and implementing the ${branding} Profile of the Filter specification, the ${ddf-catalog} includes an API, primarily in `${ddf-branding}.filter`, to build Filters using a fluent API.

To use the FilterBuilder API, an instance of `${ddf-branding}.filter.FilterBuilder` should be used via the OSGi registry.
Typically, this will be injected via a dependency injection framework.
Once an instance of `FilterBuilder` is available, methods can be called to create and combine Filters.

[TIP]
====
The fluent API is best accessed using an IDE that supports code-completion.  For additional details, refer to the Catalog API Javadoc.
====

==== Boolean Operators

`FilterBuilder.allOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean AND), either from a List or Array of Filter instances.

`FilterBuilder.anyOf(Filter ...)`:: creates a new Filter that requires all provided Filters are satisfied (Boolean OR), either from a List or Array of Filter instances.

`FilterBuilder.not(Filter filter)`:: creates a new Filter that requires the provided Filter must not be match (Boolean NOT).

===== Attribute

`FilterBuilder.attribute(String attributeName)`:: begins a fluent API for creating an Attribute-based Filter, i.e., a Filter that matches on Metacards with Attributes of a particular value.

===== XPath

`FilterBuilder.xpath(String xpath)`:: begins a fluent API for creating an XPath-based Filter, i.e., a Filter that matches on Metacards with Attributes of type XML that match when evaluating a provided XPath selector.

===== Contextual Operators

[source,java,linenums]
----
FilterBuilder.attribute(attributeName).is().like().text(String contextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().caseSensitiveText(StringcaseSensitiveContextualSearchPhrase);
FilterBuilder.attribute(attributeName).is().like().fuzzyText(String fuzzySearchPhrase);
----

===== Directly Implementing the Filter (Advanced)
[WARNING]
====
Implementing the Filter interface directly is only for extremely advanced use cases and is highly discouraged.
Instead, use of the ${branding}-specific `FilterBuilder` API is recommended.
====

Developers create a `Filter` object in order to filter or constrain the amount of records returned from a `Source`.
The OGC Filter Specification has several types of filters that can be combined in a tree-like structure to describe the set of metacards that should be returned. 

===== Categories of Filters

* Comparison Operators
* Logical Operators
* Expressions
* Literals
* Functions
* Spatial Operators
* Temporal Operators

===== Units of Measure

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 09-026r1] and http://www.opengeospatial.org/standards/filter[OGC Filter Specifications: 04-095], units of measure can be expressed as a URI.
To fulfill that requirement, ${branding} utilizes the GeoTools class `org.geotools.styling.UomOgcMapping` for spatial filters requiring a standard for units of measure for scalar distances.
Essentially, the `UomOgcMapping` maps the http://www.opengeospatial.org/standards/symbol[OGC Symbology Encoding] standard URIs to Java Units.
This class provides three options for units of measure: 

* FOOT
* METRE
* PIXEL

${branding} only supports FOOT and METRE since they are the most applicable to scalar distances.

===== Creating Filters

The common way to create a `Filter` is to use the GeoTools `FilterFactoryImpl` object, which provides Java implementations for the various types of filters in the Filter Specification.
Examples are the easiest way to understand how to properly create a `Filter` and a `Query`. 

[NOTE]
====
Refer to the http://docs.geotools.org/latest/javadocs/[GeoTools javadoc] for more information on `FilterFactoryImpl`.
====

The example below illustrates creating a query, and thus an OGC Filter, that does a case-insensitive search for the phrase "mission" in the entire metacard's text.
Note that the OGC `PropertyIsLike` Filter is used for this simple contextual query.

===== Example Creating-Filters-1 

.Simple Contextual Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar,
and the escapeChar itself

String searchPhrase = "mission" ;
org.opengis.filter.Filter propertyIsLikeFilter =
    filterFactory.like(filterFactory.property(Metacard.ANY_TEXT), searchPhrase, wildcardChar, singleChar, escapeChar, isCaseSensitive);
${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( propertyIsLikeFilter );
----

The example below illustrates creating an absolute temporal query, meaning the query is searching for Metacards whose modified timestamp occurred during a specific time range.
Note that this query uses the `During` OGC Filter for an absolute temporal query.

===== Example Creating-Filters-2

.Absolute Temporal Search
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;
org.opengis.temporal.Instant startInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(start));

org.opengis.temporal.Instant endInstant = new org.geotools.temporal.object.DefaultInstant(new DefaultPosition(end));

org.opengis.temporal.Period period =  new org.geotools.temporal.object.DefaultPeriod(startInstant, endInstant);

String property = Metacard.MODIFIED ; // modified date of a metacard

org.opengis.filter.Filter filter = filterFactory.during( filterFactory.property(property), filterFactory.literal(period)  );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl(filter) ;
----

===== Contextual Searches

Most contextual searches can be expressed using the `PropertyIsLike` filter. The special haracters that have meaning in a `PropertyIsLike` filter are the wildcard, single wildcard, and escape characters (see Example Creating-Filters-1).

====== `PropertyIsLike` Special Characters
[cols="2*", options="header"]
|===
|Character
|Description

|Wildcard
|Matches zero or more characters.

|Single Wildcard
|Matches exactly one character.

|Escape
|Escapes the meaning of the Wildcard, Single Wildcard, and the Escape character itself
|===

Characters and words, such as `AND`, `&`, `and`, `OR`, `|`, `or`, `NOT`, `~`, `not`, `{`, and `}`, are treated as literals in a `PropertyIsLike` filter. In order to create equivalent logical queries, a developer must instead use the Logical Operator filters {`AND`, `OR`, `NOT`}. The Logical Operator filters can be combined together with `PropertyIsLike` filters to create a tree that represents the search phrase expression. 

===== Example Creating-Filters-3

.Creating the search phrase "mission and planning"
[source,java,linenums]
----
org.opengis.filter.FilterFactory filterFactory = new FilterFactoryImpl() ;

boolean isCaseSensitive = false ;

String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar, and the escapeChar itself

Filter filter =
    filterFactory.and(
       filterFactory.like(filterFactory.property(Metacard.METADATA), "mission" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive),
       filterFactory.like(filterFactory.property(Metacard.METADATA), "planning" ,
wildcardChar, singleChar, escapeChar, isCaseSensitive)
    );

${ddf-branding}.catalog.operation.QueryImpl query = new QueryImpl( filter );
----

====== Tree View of Example Creating-Filters-3 

Filters used in ${branding} can always be represented in a tree diagram.

[ditaa,tree1, png,600]
....
+--------------------\
|cEEE /-------\      |
|     |  And  |      |
|     \-+---+-/      |
|       |   |        |
|     +-+   +-+      |
|     |       |      |
|     v       v      |
|/-------\ /--------\|
||mission| |planning||
|\-------/ \--------/|
\--------------------/
....

====== XML View of Example Creating-Filters-3

Another way to view this type of Filter is through an XML model, which is shown below.

.Pseudo XML of Example Creating-Filters-3
[source,xml,linenums]
----
<Filter>
   <And>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>mission</Literal>
      </PropertyIsLike>
      <PropertyIsLike wildCard="*" singleChar="?" escapeChar="\">
           <PropertyName>metadata</PropertyName>
           <Literal>planning</Literal>
      </PropertyIsLike>
   <And>
</Filter>
----

Using the Logical Operators and `PropertyIsLike` filters, a developer can create a whole language of search phrase expressions.

===== Fuzzy Operation 

${branding} only supports one custom function.
The Filter specification does not include a fuzzy operator, so a Filter function was created to represent a fuzzy operation.
The function and class is called `FuzzyFunction`, which is used by clients to notify the Sources to perform a fuzzy search.
The syntax expected by providers is similar to the Fuzzy Function.
Refer to the example below.

[source,java,linenums]
----
String wildcardChar = "*" ; // used to match zero or more characters
String singleChar = "?" ; // used to match exactly one character
String escapeChar = "\\" ; // used to escape the meaning of the wildCard, singleChar

boolean isCaseSensitive = false ;

Filter fuzzyFilter = filterFactory.like(
     new ${ddf-branding}.catalog.impl.filter.FuzzyFunction(
          Arrays.asList((Expression) (filterFactory.property(Metacard.ANY_TEXT))),
          filterFactory.literal("")),
     searchPhrase,
     wildcardChar,
     singleChar,
     escapeChar,
     isCaseSensitive);

QueryImpl query = new QueryImpl(fuzzyFilter);
----

===== Parsing Filters

According to the http://www.opengeospatial.org/standards/filter[OGC Filter Specification 04-095]: a "(filter expression) representation can be ... parsed and then transformed into whatever target language is required to retrieve or modify object instances stored in some persistent object store."
Filters can be thought of as the `WHERE` clause for a SQL SELECT statement to "fetch data stored in a SQL-based relational database." 

Sources can parse OGC Filters using the `FilterAdapter` and `FilterDelegate`.
See Developing a Filter Delegate for more details on implementing a new `FilterDelegate`.
This is the preferred way to handle OGC Filters in a consistent manner.

Alternately, `org.opengis.filter.Filter` implementations can be parsed using implementations of the interface `org.opengis.filter.FilterVisitor`. 
The `FilterVisitor` uses the http://www.oodesign.com/visitor-pattern.html[Visitor pattern]. Essentially, `FilterVisitor` instances "visit" each part of the `Filter` tree allowing developers to implement logic to handle the filter's operations. 
GeoTools 8 includes implementations of the `FilterVisitor` interface.
The `DefaultFilterVisitor`, as an example, provides only business logic to visit every node in the `Filter` tree.
The `DefaultFilterVisitor` methods are meant to be overwritten with the correct business logic. 
The simplest approach when using `FilterVisitor` instances is to build the appropriate query syntax for a target language as each part of the `Filter` is visited.
For instance, when given an incoming `Filter` object to be evaluated against a RDBMS, a `CatalogProvider instance could use a `FilterVisitor` to interpret each filter operation on the `Filter` object and translate those operations into SQL.
The `FilterVisitor` may be needed to support `Filter` functionality not currently handled by the `FilterAdapter` and `FilterDelegate` reference implementation.

===== Examples

====== Interpreting a Filter to Create SQL

If the `FilterAdapter` encountered or "visited" a `PropertyIsLike` filter with its property assigned as `title` and its literal expression assigned as `mission`, the `FilterDelegate` could create the proper SQL syntax similar to title `LIKE` mission.

.Figure Parsing-Filters1
[ditaa,tree2,png]
....
+-------------------------\
|    /----------------\   |
|    | PropertyIsLike |   |
|    \----------------/   |
| cEEE      |  |          |
|      /----/  \----\     |
|      |            |     |
|      v            v     |
|/----------\  /---------\|
||Property- |  |Literal- ||
|| title    |  | mission ||
|\----------/  \---------/|
\-------------------------/
....

====== Interpreting a Filter to Create XQuery

If the `FilterAdapter` encountered an `OR` filter, such as in Figure Parsing-Filters2 and the target language was XQuery, the `FilterDelegate` could yield an expression such as 

[source]
----
ft:query(//inventory:book/@subject,'math') union
ft:query(//inventory:book/@subject,'science').
----

.Figure Parsing-Filters2
[ditaa, tree3, png]
....
+---------------------------------------------------\
|                       /----\                      |
|  cEEE                 | OR |                      |
|                       \----/                      |
|                        |  |                       |
|             /----------/  \----------\            |
|             |                        |            |
|             v                        v            |
|    /----------------\        /----------------\   |
|    | PropertyIsLike |        | PropertyIsLike |   |
|    \----------------/        \----------------/   |
|           |  |                      |  |          |
|      /----/  \----\            /----/  \----\     |
|      |            |            |            |     |
|      v            v            v            v     |
|/----------\  /---------\  /---------\  /---------\|
||Property- |  |Literal- |  |Property-|  |Literal- ||
|| title    |  | mission |  | Subject |  | science ||
|\----------/  \---------/  \---------/  \---------/|
\---------------------------------------------------/
....


====== FilterAdapter/Delegate Process for Figure Parsing-Filters2

. `FilterAdapter` visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike`method with the LHS property and literal.
. The LHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to the `OR` filter, which visits its second child.
. The `FilterAdapter` will call the `FilterDelegate` `PropertyIsLike` method with the RHS property and literal.
. The RHS `PropertyIsLike` delegate method builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject` Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The `FilterAdapter` then moves back to its `OR Filter which is now done with its children.
. It then collects the output of each child and sends the list of results to the `FilterDelegate OR` method.
. The final result object will be returned from the `FilterAdapter` adapt method.

====== FilterVisitor Process for Figure Parsing-Filters2

. FilterVisitor visits the `OR` filter first.
. `OR` filter visits its children in a loop. 
. The first child in the loop that is encountered is the LHS `PropertyIsLike`.
. The LHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to the `OR` filter, which visits its second child.
. The RHS `PropertyIsLike` builds the XQuery syntax that makes sense for this particular underlying object store. In this case, the _subject_ property is specific to this XML database, and the business logic maps the _subject_ property to its index at `//inventory:book/@subject`. Note that `ft:query` in this instance is a custom XQuery module for this specific XML database that does full text searches.
. The FilterVisitor then moves back to its `OR` filter, which is now done with its children. It then collects the output of each child and could potentially execute the following code to produce the above expression.

[source,java,linenums]
----
public visit( Or filter, Object data) {
...
   /* the equivalent statement for the OR filter in this domain (XQuery) */
   xQuery = childFilter1Output + " union " + childFilter2Output;
...
}
----

==== Filter Profile

===== Role of the OGC Filter

Both Queries and Subscriptions extend the OGC GeoAPI Filter interface.

The Filter Builder and Adapter do not fully implement the OGC Filter Specification.
The filter support profile contains suggested filter to metacard type mappings.
For example, even though a Source could support a `PropertyIsGreaterThan` filter on `XML_TYPE`, it would not likely be useful.

===== Catalog Filter Profile

====== Metacard Attribute To Type Mapping

The filter profile maps filters to metacard types.
The following table displays the common metacard attributes with their respective types for reference.

[cols="2*", options="header"]
|===

|Metacard Attribute
|Metacard Type

|ANY_DATE
|DATE_TYPE

|ANY_GEO
|GEO_TYPE

|ANY_TEXT
|STRING_TYPE

|CONTENT_TYPE
|STRING_TYPE

|CONTENT_TYPE_VERSION
|STRING_TYPE

|CREATED
|DATE_TYPE

|EFFECTIVE
|DATE_TYPE

|GEOGRAPHY
|GEO_TYPE

|ID
|STRING_TYPE

|METADATA
|XML_TYPE

|MODIFIED
|DATE_TYPE

|RESOURCE_SIZE
|STRING_TYPE

|RESOURCE_URI
|STRING_TYPE

|SOURCE_ID
|STRING_TYPE

|TARGET_NAMESPACE
|STRING_TYPE

|THUMBNAIL
|BINARY_TYPE

|TITLE
|STRING_TYPE

|===

====== Comparison Operators

Comparison operators compare the value associated with a property name with a given Literal value.
Endpoints and sources should try to use metacard types other than the object type.
The object type only supports backwards compatibility with `java.net.URI`.  
Endpoints that send other objects will not be supported by standard sources.
The following table maps the metacard types to supported comparison operators.

[cols="12*", options="header"]
|===

|PropertyIs
|Between
|EqualTo
|GreaterThan
|GreaterThan
|OrEqualTo
|LessThan
|LessThan
|OrEqualTo
|Like
|NotEqualTo
|Null

|BINARY_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|BOOLEAN_TYPE
|
|*X*
|
|
|
|
|
|
|
|
|

|DATE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|DOUBLE_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|FLOAT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

 

|GEO_TYPE
|
|
|
|
|
|
|
|
|
|
|*X*

|INTEGER_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|LONG_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|OBJECT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|SHORT_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*

|STRING_TYPE
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*
|*X*

|XML_TYPE
|
|*X*
|
|
|
|
|
|
|*X*
|
|*X*
 
|===

The following table describes each comparison operator.

.Comparison Operators
[cols="2*", options="header"]
|===

|Operator
|Description

|PropertyIsBetween
|Lower <= Property <= Upper

|PropertyIsEqualTo
|Property == Literal

|PropertyIsGreaterThan
|Property > Literal

|PropertyIsGreaterThanOrEqualTo
|Property >= Literal

|PropertyIsLessThan
|Property < Literal

|PropertyIsLessThanOrEqualTo
|Property <= Literal

|PropertyIsLike
|Property LIKE Literal

Equivalent to SQL "like" 

|PropertyIsNotEqualTo
|Property != Literal

|PropertyIsNull
|Property == null

|===

====== Logical Operators
Logical operators apply Boolean logic to one or more child filters.

.Logical Operators
[cols="4*", options="header"]
|===

|
|And
|Not
|Or

|Supported Filters
|*X*
|*X*
|*X*

|===

====== Temporal Operators
Temporal operators compare a date associated with a property name to a given Literal date or date range.
The following table displays the supported temporal operators.

[cols="12*", options="header"]
|===
|
|After
|AnyInteracts
|Before
|Begins
|BegunBy
|During
|EndedBy
|Meets
|MetBy
|OverlappedBy
|TContains

|DATE_TYPE
|*X*
|
|*X*
|
|
|*X*
|
|
|
|
|

|===

The following table describes each temporal operator.
Literal values can be either date instants or date periods.
[cols="2*", options="header"]
|===

|Operator
|Description

|After
|Property > (Literal \|\| Literal.end)

|Before
|Property < (Literal \|\| Literal.start)

|During
|Literal.start < Property < Literal.end

|===

====== Spatial Operators

Spatial operators compare a geometry associated with a property name to a given Literal geometry. 
The following table displays the supported spatial operators.

[cols="11*", options="headers"]
|===

|BBox
|Beyond
|Contains
|Crosses
|Disjoint
|Equals
|DWithin
|Intersects
|Overlaps
|Touches
|Within

|GEO_TYPE
|
|*X*
|*X*
|*X*
|*X*
|
|*X*
|*X*
|*X*
|

|===

The following table describes each spatial operator.
Geometries are usually represented as Well-Known Text (_WKT_).

[cols="2*", options="header"]
|===

|Operator
|Description

|Beyond
|Property geometries beyond given distance of Literal geometry

|Contains
|Property geometry contains Literal geometry

|Crosses
|Property geometry crosses Literal geometry

|Disjoint
|Property geometry direct positions are not interior to Literal geometry

|DWithin
|Property geometry lies within distance to Literal geometry

|Intersects
|Property geometry intersects Literal geometry; opposite to the Disjoint operator 

|Overlaps
|Property geometry interior somewhere overlaps Literal geometry interior

|Touches
|Property geometry touches but does not overlap Literal geometry

|Within
|Property geometry completely contains Literal geometry

|===

==== Commons-DDF Utilities

The `commons-${ddf-branding}`bundle, located in `<DDF_HOME_SOURCE_DIRECTORY>/common/commons-${ddf-branding}`, provides utilities and functionality commonly used across other ${branding} components, such as the endpoints and providers. 

==== Noteworthy Classes

===== FuzzyFunction

`${ddf-branding}.catalog.impl.filter.FuzzyFunction` class is used to indicate that a `PropertyIsLike` filter should interpret the search as a fuzzy query. 

===== XPathHelper

`${ddf-branding}.util.XPathHelper` provides convenience methods for executing XPath operations on XML.
It also provides convenience methods for converting XML as a `String` from a `org.w3c.dom.Document` object and vice versa.

=== Extending Catalog Plugins

The Catalog Framework calls Catalog Plugins to process requests and responses as they enter and leave the Framework. 

[ditaa, catalog_architecture_plugins, png,${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||c369           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Existing Plugins

===== Pre-Ingest Plugin

.Ingest Plugin Flow
[ditaa,ingest-plugin-flow,png, ${image-width}]
....
/------\
|Client|
|cDEF  |
\------/
    ^
    |
+-------------------------------------------\
|DDF|                                  cCCC |
|   v                                       |
|/--------\   /-----------------\   /------\|
||Endpoint|<->|Catalog Framework|<->|Source||
|| cDEF   |   | cDEF            |   | cDEF ||
|\--------/   \-----------------/   \------/|
|                     | |                   |
|          /----------/ \--------\          |
|          |                     |          |
|          v                     v          |
|/------------------\  /-------------------\|
||PreIngest Plugins |  |PostIngest Plugins ||
|| cDEF             |  | cDEF              ||
|\------------------/  \-------------------/|
\-------------------------------------------/
....

===== Using

Pre-Ingest plugins are invoked before an ingest operation is sent to the catalog.
They are not run on a query.
This is an opportunity to take any action on the ingest request, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-Ingest plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 

The output of a Pre-Ingest plugin is sent to the next Pre-Ingest plugin, until all have executed and the ingest operation is sent to the requested Source.

===== Metacard Groomer

The Metacard Groomer Pre-Ingest plugin makes modifications to `CreateRequest` and `UpdateRequest` metacards.

This plugin makes the following modifications when metacards are in a `CreateRequest`:

* Overwrites the `Metacard.ID` field with a generated, unique, 32 character hexadecimal value
* Overwrites the `Metacard.CREATED` date with a current time stamp
* Overwrites the `Metacard.MODIFIED` date with a current time stamp

The plugin also makes the following modifications when metacards are in an `UpdateRequest`:

* If no value is provided for `Metacard.ID` in the new metacard, it will be set using the `UpdateRequest` ID if applicable.
* If no value is provided, sets the `Metacard.CREATED` date with the `Metacard.MODIFIED` date so that the `Metacard.CREATED` date is not null.
* Overwrites the `Metacard.MODIFIED` date with a current time stamp.

====== Installing and UnInstalling

This plugin can be installed and uninstalled using the normal processes described in the Configuring ${branding} section.

====== Configuring

No configuration is necessary for this plugin. 

====== Using

Use this pre-ingest plugin as a convenience to apply basic rules for your metacards. 

====== Known Issues

None

===== Metacard Validity Marker

The Metacard Validity Marker Pre-Ingest plugin modifies the metacards contained in `CreateRequest`s and `UpdateRequest`s.

The plugin runs each metacard in the `CreateRequest` and `UpdateRequest` against each registered `MetacardValidator` service.

[NOTE]
====
This plugin can make it seem like ingested products are not successfully ingested.
If after ingesting, the ingest did not fail and there are no errors in the ingest log, but the expected results do not show up after a query,
verify either that the ingested data is valid or that the <<catalogFederationStrategy, Catalog Federation Strategy>> is configured to show warnings and/or errors.
====


====== Installing and Uninstalling

This plugin can be installed and uninstalled using the normal processes described in the Configuring ${branding} section.

====== Configuring

No configuration is necessary for this plugin. 
By default, it will mark metacards with validation errors and warnings as they are reported by each metacard validator and then allow the ingest.
To prevent the ingest of certain invalid metacards, the `Metacard Validity Marker` plugin can be configured to "enforce" one or more validators.
The `Metacard Validity Marker` plugin can also be configured to enforce validator errors, warnings, or both.

If errors are enforced, then any validation errors from an enforced validator will result in the metacard being rejected.
If warnings are enforced, then any validation warnings from an enforced validator will result in the metacard being rejected.
In all other cases, metacards will be ingested and marked with any errors or warnings that may occur during validation.

====== Using

Use this pre-ingest plugin to validate metacards against metacard validators, which can check schemas, schematron, or any other logic. 

====== Known Issues

None

===== Post-Ingest Plugin

====== Using

Post-ingest plugins are invoked after data has been created, updated, or deleted in a Catalog Provider.

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.

====== Invocation

Because the event has already occurred and changes from one post-ingest plugin cannot affect others, all Post-Ingest plugins are invoked in parallel and no priority is enforced.

.QueryPlugin Flow
[ditaa,query-plugin-flow,png]
....
/------\
|Client|
|cDEF  |
\------/
    ^
    |
+-------------------------------------------\
|DDF|                                  cCCC |
|   v                                       |
|/--------\   /-----------------\   /------\|
||Endpoint|<->|Catalog Framework|<->|Source||
|| cDEF   |   | cDEF            |   | cDEF ||
|\--------/   \-----------------/   \------/|
|                     | |                   |
|          /----------/ \--------\          |
|          |                     |          |
|          v                     v          |
|/------------------\  /-------------------\|
|| PreQuery Plugins |  | PostQuery Plugins ||
||  cDEF            |  |  cDEF             ||
|\------------------/  \-------------------/|
\-------------------------------------------/
....

===== Pre-Query Plugin

====== Using

Pre-query plugins are invoked before a query operation is sent to any of the Sources. 
This is an opportunity to take any action on the query, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-query plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 
The output of a pre-query plugin is sent to the next pre-query plugin, until all have executed and the query operation is sent to the requested Source.

===== Post-Query Plugin

====== Using

Post-query plugins are invoked after a query has been executed successfully, but before the response is returned to the endpoint. 
This is an opportunity to take any action on the query response, including but not limited to:

* logging
* auditing
* security filtering/redaction
* deduplication

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Post-query plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 
The output of the first plugin is sent to the next plugin, until all have executed and the response is returned to the requesting endpoint.

==== Metacard Resource Size Plugin

This post-query plugin updates the resource size attribute of each metacard in the query results if there is a cached file for the product and it has a size greater than zero; otherwise, the resource size is unmodified and the original result is returned.

====== Installing and UnInstalling
This feature can be installed and uninstalled using the normal processes described in the Configuring ${branding} section.

====== Configuring
No configuration is necessary for this plugin. 

====== Using
Use this post-query plugin as a convenience to return query results with accurate resource sizes for cached products. 

====== Known Issues
None

==== Other Types of Plugins

===== Pre-Get Resource Plugin

====== Using
Pre-get resource plugins are invoked before a request to retrieve a resource is sent to a Source. 
This is an opportunity to take any action on the request, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled. 
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-get resource plugins are invoked serially, prioritized by descending OSGi service ranking. 
That is, the plugin with the highest service ranking will be executed first. 

The output of the first plugin is sent to the next plugin, until all have executed and the request is sent to the targeted Source.

===== Post-Get Resource Plugin

====== Using

Post-get resource plugins are invoked after a resource has been retrieved, but before it is returned to the endpoint. 
This is an opportunity to take any action on the response, including but not limited to:

* logging
* auditing
* security filtering/redaction

===== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown. 
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Post-get resource plugins are invoked serially, prioritized by descending OSGi service ranking. 
The plugin with the highest service ranking will be executed first. 

The output of the first plugin is sent to the next plugin, until all have executed and the response is returned to the requesting endpoint.

===== Pre-Subscription Plugin

====== Using

Pre-subscription plugins are invoked before a Subscription is activated by an Event Processor. 
This is an opportunity to take any action on the Subscription, including but not limited to:

* validation
* logging
* auditing
* optimization
* security filtering

===== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

===== Invocation

Pre-subscription plugins are invoked serially, prioritized by descending OSGi service ranking. 
That is, the plugin with the highest service ranking will be executed first. 

The output of a pre-subscription plugin is sent to the next pre-subscription plugin, until all have executed and the create Subscription operation is sent to the Event Processor.

====== Examples

${branding} includes a pre-subscription plugin example in the SDK that illustrates how to modify a subscription's filter.
This example is located in the ${branding} trunk at `sdk/sample-plugins/${ddf-branding}/sdk/plugin/presubscription`.

===== Pre-Delivery Plugin

====== Using

Pre-delivery plugins are invoked before a Delivery Method is invoked on a Subscription. 
This is an opportunity to take any action before notification, including but not limited to:

* logging
* auditing
* security filtering/redaction

====== Failure Behavior

In the event that this Catalog Plugin cannot operate but does not wish to fail the transaction, a `PluginExecutionException` will be thrown.
For any other Exceptions, the Catalog will "fail safe" and the Operation will be cancelled.
If processing is to be explicitly stopped, a `StopProcessingException` will be thrown.

====== Invocation

Pre-delivery plugins are invoked serially, prioritized by descending OSGi service ranking.
The plugin with the highest service ranking will be executed first. 

The output of a pre-delivery plugin is sent to the next pre-delivery plugin, until all have executed and the Delivery Method is invoked on the associated Subscription.

==== Developing a Catalog Plugin

==== Policy Plugin

===== Using

Policy plugins are invoked before all other plugin types to set up the policy for a request/response.  This provides an opportunity to attach custom requirements on operations or individual metacards.
All the 'requirements' from each Policy plugin will be combined into a single policy that will be included in the request/response. Access plugins will be used to act on this combined policy.

===== Failure Behavior

All failure cases should be handled internally to the plugin with the exception of the StopProcessingException. If the exception encountered should stop/block the request then a StopProcessingException should be thrown.

==== Access Plugin

===== Using

Access plugins are invoked directly after the Policy plugins have been successfully executed.  This is an opportunity to either stop processing or modify the request/response based on policy information.

===== Failure Behavior

All failure cases should be handled internally to the plugin with the exception of the StopProcessingException. If the exception encountered should stop/block the request then a StopProcessingException should be thrown.

==== Developing a Catalog Plugin

Plugins extend the functionality of the Catalog Framework by performing actions at specified times during a transaction. 
Plugins can be _Pre-Ingest_, _Post-Ingest_, _Pre-Query_, _Post-Query_, _Pre-Subscription_, _Pre-Delivery_, _Pre-Resource_, or _Post-Resource_. 
By implementing these interfaces, actions can be performed at the desired time. 

===== Create New Plugins

====== Implement Plugin Interface

The following types of plugins can be created:

[cols="4*", options="header"]
|===

|Plugin Type
|Plugin Interface
|Description
|Example

|Pre-Ingest
|`${ddf-branding}.catalog.plugin.PreIngestPlugin`
|Runs before the Create/Update/Delete method is sent to the CatalogProvider
|Metadata validation services

|Post-Ingest
|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|Runs after the Create/Update/Delete method is sent to the CatalogProvider
|EventProcessor for processing and publishing event notifications to subscribers

|Pre-Query
|`${ddf-branding}.catalog.plugin.PreQueryPlugin`
|Runs prior to the Query/Read method being sent to the Source
|An example is not included with ${branding}

|Post-Query
|`${ddf-branding}.catalog.plugin.PostQueryPlugin`
|Runs after results have been retrieved from the query but before they are posted to the Endpoint
|An example is not included with ${branding}

|Pre-Subscription
|`${ddf-branding}.catalog.plugin.PreSubscription`
|Runs prior to a Subscription being created or updated
|Modify a query prior to creating a subscription

|Pre-Delivery
|`${ddf-branding}.catalog.plugin.PreDeliveryPlugin`
|Runs prior to the delivery of a Metacard when an event is posted
|Inspect a metacard prior to delivering it to the Event Consumer

|Pre-Resource
|`${ddf-branding}.catalog.plugin.PreResource`
|Runs prior to a Resource being retrieved
|An example is not included with ${branding}

|Post-Resource
|`${ddf-branding}.catalog.plugin.PostResource`
|Runs after a Resource is retrieved, but before it is sent to the Endpoint
|Verification of a resource prior to returning to a client

|Policy
|${ddf-branding}.catalog.plugin.PolicyPlugin
|Runs prior to all other catalog plugins to esablish the policy for requests/responses
|An example is MetacardValidityFilterPlugin

|Access
|${ddf-branding}.catalog.plugin.AccessPlugin
|Runs directly after the PolicyPlugin
|An examples are the FilterPlugin and OperationPlugin

|===

===== Implement Plugins

The procedure for implementing any of the plugins follows a similar format:

. Create a new class that implements the specified plugin interface.

. Implement the required methods.

. Create OSGi descriptor file to communicate with the OSGi registry.

.. Import ${branding} packages.

.. Register plugin class as service to OSGi registry.

. Deploy to ${branding}.

[TIP]
====
Refer to the Javadoc for more information on all Requests and Responses in the `${ddf-branding-lowercase}.catalog.operation` and `${ddf-branding-lowercase}.catalog.event` packages.
====

===== Pre-Ingest

. Create a Java class that implements `PreIngestPlugin.` +
`public class SamplePreIngestPlugin implements ${ddf-branding}.catalog.plugin.PreIngestPlugin`

. Implement the required methods. +
 * `public CreateRequest process(CreateRequest input) throws PluginExecutionException;`
 * `public UpdateRequest process(UpdateRequest input) throws PluginExecutionException;`
 * `public DeleteRequest process(DeleteRequest input) throws PluginExecutionException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
*Blueprint descriptor example*
`<service ref="[[SamplePreIngestPlugin ]]"interface="${ddf-branding}.catalog.plugin.PreIngestPlugin" />`

===== Post-Ingest

. Create a Java class that implements `PostIngestPlugin`. +
`public class SamplePostIngestPlugin implements ${ddf-branding}.catalog.plugin.PostIngestPlugin`

. Implement the required methods. +
 * `public CreateResponse process(CreateResponse input) *throws* PluginExecutionException;`
 * `public UpdateResponse process(UpdateResponse input) *throws* PluginExecutionException;`
 * `public DeleteResponse process(DeleteResponse input) *throws* PluginExecutionException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
*Blueprint descriptor example*
`<service ref="[[SamplePostIngestPlugin ]]"interface="${ddf-branding}.catalog.plugin.PostIngestPlugin" />`

===== Pre-Query

. Create a Java class that implements `PreQueryPlugin`. +
`public class SamplePreQueryPlugin implements ${ddf-branding}.catalog.plugin.PreQueryPlugin`

. Implement the required method. +
`public QueryRequest process(QueryRequest input) *throws* PluginExecutionException, StopProcessingException;`
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
`<service ref="[[SamplePreQueryPlugin]]"interface="${ddf-branding}.catalog.plugin.PreQueryPlugin" />`

===== Post-Query

. Create a Java class that implements `PostQueryPlugin`. +
`public class SamplePostQueryPlugin implements ${ddf-branding}.catalog.plugin.PostQueryPlugin`

. Implement the required method. +
`public QueryResponse process(QueryResponse input) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin`

. Export the service to the OSGi registry. +
`<service ref="[[SamplePostQueryPlugin]]"interface="${ddf-branding}.catalog.plugin.PostQueryPlugin" />`

===== Pre-Delivery

. Create a Java class that implements `PreDeliveryPlugin`. +
`public class SamplePreDeliveryPlugin *implements* ${ddf-branding}.catalog.plugin.PreDeliveryPlugin`

. Implement the required methods. +
`public Metacard processCreate(Metacard metacard) *throws* PluginExecutionException, StopProcessingException;`
`public Update processUpdateMiss(Update update) *throws* PluginExecutionException,
StopProcessingException;`
 * `public Update processUpdateHit(Update update) *throws* PluginExecutionException, StopProcessingException;`
 * `public Metacard processCreate(Metacard metacard) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation,${ddf-branding}.catalog.event`

. Export the service to the OSGi registry. +
*Blueprint descriptor example* +
`<service ref="[[SamplePreDeliveryPlugin]]"interface="${ddf-branding}.catalog.plugin.PreDeliveryPlugin" />`

===== Pre-Subscription

. Create a Java class that implements `PreSubscriptionPlugin`. +
`public class SamplePreSubscriptionPlugin *implements* ${ddf-branding}.catalog.plugin.PreSubscriptionPlugin

. Implement the required method.
 * `public Subscription process(Subscription input) *throws* PluginExecutionException, StopProcessingException;`

===== Pre-Resource

. Create a Java class that implements `PreResourcePlugin`.
`public class SamplePreResourcePlugin *implements* ${ddf-branding}.catalog.plugin.PreResourcePlugin`

. Implement the required method. +
 * `public ResourceRequest process(ResourceRequest input) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.
.Blueprint descriptor example
[source,xml]
----
<service ref="[[SamplePreResourcePlugin]]" interface="${ddf-branding}.catalog.plugin.PreResourcePlugin" />
----

===== Post-Resource

. Create a Java class that implements `PostResourcePlugin`. +
`public class SamplePostResourcePlugin *implements* ${ddf-branding}.catalog.plugin.PostResourcePlugin`

. Implement the required method. +
 * `public ResourceResponse process(ResourceResponse input) *throws* PluginExecutionException, StopProcessingException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.

.Blueprint descriptor example
[source,xml]
----
<service ref="[[SamplePostResourcePlugin]]" interface="${ddf-branding}.catalog.plugin.PostResourcePlugin" />
----

===== Policy

. Create a Java class that implements `PolicyPlugin`. +
`public class SamplePolicyPlugin *implements* ${ddf-branding}.catalog.plugin.PolicyPlugin`

. Implement the required methods. +
 * `PolicyResponse processPreCreate(Metacard input, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPreUpdate(Metacard input, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPreDelete(String attributeName, List<Serializable> attributeValues, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPreQuery(Query query, Map<String, Serializable> properties) *throws* StopProcessingException;`
 * `PolicyResponse processPostQuery(Result input, Map<String, Serializable> properties) *throws* StopProcessingException;`

. Import the DDF interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.  +
*Blueprint descriptor example* +
`<service ref="[[SamplePolicyPlugin]]" interface="${ddf-branding}.catalog.plugin.PolicyPlugin" />`


===== Access

. Create a Java class that implements `AccessPlugin`. +
`public class SamplePostResourcePlugin *implements* ${ddf-branding}.catalog.plugin.AccessPlugin`

. Implement the required methods. +
 * `CreateRequest processPreCreate(CreateRequest input) *throws* StopProcessingException;`
 * `UpdateRequest processPreUpdate(UpdateRequest input) *throws* StopProcessingException;`
 * `DeleteRequest processPreDelete(DeleteRequest input) *throws* StopProcessingException;`
 * `QueryRequest processPreQuery(QueryRequest input) *throws* StopProcessingException;`
 * `QueryResponse processPostQuery(QueryResponse input) *throws* StopProcessingException;`

. Import the DDF interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.plugin,${ddf-branding}.catalog.operation`

. Export the service to the OSGi registry.  +
*Blueprint descriptor example* +
`<service ref="[[SampleAccessPlugin]]" interface="${ddf-branding}.catalog.plugin.AccessPlugin" />`


=== Extending Operations

The Catalog provides the capability to query, create, update, and delete metacards; retrieve resources; and retrieve information about the sources in the enterprise.

Each of these operations follow a request/response paradigm.
The request is the input to the operation and contains all of the input parameters needed by the Catalog Framework's operation to communicate with the Sources.
The response is the output from the execution of the operation that is returned to the client, which contains all of the data returned by the sources.
For each operation there is an associated request/response pair, e.g., the `QueryRequest` and `QueryResponse` pair for the Catalog Framework's query operation.

All of the request and response objects are extensible in that they can contain additional key/value properties on each request/response.
This allows additional capability to be added without changing the Catalog API, helping to maintain backwards compatibility.

[ditaa, catalog_architecture_operations, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |c369        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Extending Data and Metadata Basics

The catalog stores and translates Metadata which can be transformed into many data formats, shared, and queried.
The primary form of this metadata is the metacard. 
A `Metacard` is a container for metadata. 
`CatalogProviders` accept `Metacards` as input for ingest, and `Sources` search for metadata and return matching `Results` that include `Metacards`.

[ditaa, catalog_architecture_data, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |c369  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Metacard

A single instance of metadata in the Catalog (an instance of a metacard type) which generally contains metadata providing a title for the product and describing a product's geo-location, created and modified dates, owner or producer, security classification, etc. 

==== Metacard Type

===== Metacard Type

A metacard type indicates the attributes available for a particular metacard.
It is a model used to define the attributes of a metacard, much like a schema.

===== Default Metacard Type and Attributes

Most metacards within the system are created using with the default metacard type.
The default metacard type of the system can be programmatically retrieved by calling `${ddf-branding}.catalog.data.BasicTypes.BASIC_METACARD`.
The name of the default MetacardType can be retrieved from `${ddf-branding}.catalog.data.MetacardType.DEFAULT_METACARD_TYPE_NAME`.

The default metacard type has the following required attributes.
Though the following attributes are required on all metacard types, setting their values is optional except for ID.

===== Required Attributes

[cols="4*", options="header"]
|===

|`${ddf-branding}.catalog.data.Metacard` Constant
|Attribute Name
|Attribute Format
|Description

|`CONTENT_TYPE`
|`metadata-content-type`
|STRING
|Attribute name accessing for the metadata content type of a Metacard.

|`CONTENT_TYPE_VERSION`
|`metadata-content-type-version`
|STRING
|Attribute name for the version of the metadata content accessing type of a Metacard.

|`CREATED`
|`created`
|DATE
|Attribute name for accessing the date/time *this Metacard* was created.

|`EFFECTIVE`
|`effective`
|DATE
|Attribute name for accessing the date/time of *the product* represented by the Metacard.

|`EXPIRATION`
|`expiration`
|DATE
|Attribute name for accessing the date/time the Metacard is no longer valid and could be removed.

|`GEOGRAPHY`
|`location`
|GEOMETRY
|Attribute name for accessing the location for this Metacard.

|`ID`
|`id`
|STRING
|Attribute name for accessing the ID of the Metacard.

|`METADATA`
|`metadata`
|XML
|Attribute name for accessing the XML metadata for this Metacard.

|`MODIFIED`
|`modified`
|DATE
|Attribute name for accessing the date/time this Metacard was last modified.

|`RESOURCE_SIZE`
|`resource-size`
|STRING
|Attribute name for accessing the size in bytes of the product this Metacard represents.

|`RESOURCE_URI`
|`resource-uri`
|STRING
|Attribute name for accessing the URI reference to the product this Metacard represents.

|`TARGET_NAMESPACE`
|`metadata-target-namespace`
|STRING
|Attribute name for the target namespace of the accessing metadata content type of a Metacard.

|`THUMBNAIL`
|`thumbnail`
|BINARY
|Attribute name for accessing the thumbnail image of the product this Metacard represents. The thumbnail must be of MIME Type `image/jpeg` and be less than 128 kilobytes. 

|`TITLE`
|`title`
|STRING
|Attribute name for accessing the title of the Metacard.

|===

[NOTE]
====
It is highly recommended when referencing a default attribute name to use the `${ddf-branding}.catalog.data.Metacard` constants whenever possible.
====

[WARNING]
====
Every Source should at the very least return an ID attribute according to Catalog API.
Other fields might or might not be applicable, but a unique ID must be returned by a Source.
====

===== Extensible Metacards

Metacard extensibility is achieved by creating a new `MetacardType` that supports attributes in addition to the required attributes listed above.

Required attributes must be the base of all extensible metacard types. 

[WARNING]
====
Not all Catalog Providers support extensible metacards.
Nevertheless, each Catalog Provider should at least have support for the default `MetacardType`; i.e., it should be able to store and query on the attributes and attribute formats specified by the default metacard type.
Consult the documentation of the Catalog Provider in use for more information on its support of extensible metacards.
====

===== Metacard Extensibility

Often, the `BASIC_METACARD` `MetacardType` does not provide all the functionality or attributes necessary for a specific task.
For performance or convenience purposes, it may be necessary to create custom attributes even if others will not be aware of those attributes.
One example could be if a user wanted to optimize a search for a date field that did not fit the definition of `CREATED`, `MODIFIED`, `EXPIRATION`, or `EFFECTIVE`.
The user could create an additional `java.util.Date` attribute in order to query the attribute separately. 

`Metacard` objects are extensible because they allow clients to store and retrieve standard and custom key/value Attributes from the `Metacard`. 
All `Metacards` must return a `MetacardType` object that includes an `AttributeDescriptor` for each `Attribute`, indicating it's key and value type.
`AttributeType` support is limited to those types defined by the Catalog.

New `MetacardType` implementations can be made by implementing the `MetacardType` interface.

==== Metacard Type Registry

[WARNING]
====
The `MetacardTypeRegistry` is experimental. 
While this component has been tested and is functional, it may change as more information is gathered about what is needed and as it is used in more scenarios.
====

The `MetacardTypeRegistry` allows ${branding} components, primarily CatalogProviders and Sources, to make available the `MetacardTypes` that they support. 
It maintains a list of all supported `MetacardTypes` in the `CatalogFramework`, so that other components such as Endpoints, Plugins, and Transformers can make use of those `MetacardTypes`. 
The `MetacardType` is essential for a component in the `CatalogFramework` to understand how it should interpret a metacard by knowing what attributes are available in that metacard. 

For example, an endpoint receiving incoming metadata can perform a lookup in the `MetacardTypeRegistry` to find a corresponding `MetacardType`. 
The discovered `MetacardType` will then be used to help the endpoint populate a metacard based on the specified attributes in the `MetacardType`. 
By doing this, all the incoming metadata elements can then be available for processing, cataloging, and searching by the rest of the `CatalogFramework`.

`MetacardTypes` should be registered with the `MetacardTypeRegistry`.  The `MetacardTypeRegistry` makes those `MetacardTypes` available to other ${branding} `CatalogFramework` components. 
Other components that need to know how to interpret metadata or metacards should look up the appropriate `MetacardType` from the registry. 
By having these `MetacardTypes` available to the `CatalogFramework`, these components can be aware of the custom attributes. 

The `MetacardTypeRegistry` is accessible as an OSGi service. 
The following blueprint snippet shows how to inject that service into another component:

[source,xml,linenums]
----
<bean id="sampleComponent" class="${ddf-branding}.catalog.SampleComponent">
    <argument ref="metacardTypeRegistry" />
</bean>

<!-- Access MetacardTypeRegistry -->
<reference id="metacardTypeRegistry" interface="${ddf-branding}.catalog.data.MetacardTypeRegistry"/>
----

The reference to this service can then be used to register new `MetacardTypes` or to lookup existing ones. 

Typically, new `MetacardTypes` will be registered by `CatalogProviders` or Sources indicating they know how to persist, index, and query attributes from that type. 
Typically, Endpoints or `InputTransformers` will use the lookup functionality to access a `MetacardType` based on a parameter in the incoming metadata. 
Once the appropriate `MetacardType` is discovered and obtained from the registry, the component will know how to translate incoming raw metadata into a ${branding} Metacard.

===== Attribute

A single field of a metacard, an instance of an attribute type.
Attributes are typically indexed for searching by a Source or Catalog Provider.

====== Attribute Type

An attribute type indicates the attribute format of the value stored as an attribute. 
It is a model for an attribute.

====== Attribute Format

An enumeration of attribute formats are available in the catalog.
Only these attribute formats may be used.

[cols="2*", options="header"]
|===
|AttributeFormat
|Description

|`BINARY`
|Attributes of this attribute format must have a value that is a Java `byte[]` and `AttributeType.getBinding()` should return `Class<Array>of` byte.

|`BOOLEAN`
|Attributes of this attribute format must have a value that is a Java boolean.

|`DATE`
|Attributes of this attribute format must have a value that is a Java date.

|`DOUBLE`
|Attributes of this attribute format must have a value that is a Java double.

|`FLOAT`
|Attributes of this attribute format must have a value that is a Java float.

|`GEOMETRY`
|Attributes of this attribute format must have a value that is a WKT-formatted Java string.

|`INTEGER`
|Attributes of this attribute format must have a value that is a Java integer.

|`LONG`
|Attributes of this attribute format must have a value that is a Java long.

|`OBJECT`
|Attributes of this attribute format must have a value that implements the serializable interface.

|`SHORT`
|Attributes of this attribute format must have a value that is a Java short.

|`STRING`
|Attributes of this attribute format must have a value that is a Java string and treated as plain text.

|`XML`
|Attributes of this attribute format must have a value that is a XML-formatted Java string.

|===

===== Result

A single "hit" included in a query response.

A result object consists of the following:

* a metacard
* a relevance score if included
* distance in meters if included

===== Creating Metacards

The quickest way to create a `Metacard` is to extend or construct the `MetacardImpl` object. 
`MetacardImpl` is the most commonly used and extended `Metacard` implementation in the system because it provides a convenient way for developers to retrieve and set `Attribute`s without having to create a new `MetacardType` (see below).
`MetacardImpl` uses `BASIC_METACARD` as its `MetacardType`.  

===== Limitations

A given developer does not have all the information necessary to programmatically interact with any arbitrary `Source`. 
Developers hoping to query custom fields from extensible `Metacards` of other `Sources` cannot easily accomplish that task with the current API.
A developer cannot question a random `Source` for all its _queryable_ fields.
A developer only knows about the `MetacardTypes` which that individual developer has used or created previously. 

The only exception to this limitation is the `Metacard.ID` field, which is required in every `Metacard` that is stored in a `Source`.
A developer can always request `Metacards` from a `Source` for which that developer has the `Metacard.ID` value. 
The developer could also perform a wildcard search on the `Metacard.ID` field if the `Source` allows.

===== Processing Metacards

As `Metacard` objects are created, updated, and read throughout the Catalog, care should be taken by all Catalog Components to interrogate the `MetacardType` to ensure that additional `Attributes` are processed accordingly.

===== Basic Types

The Catalog includes definitions of several Basic Types all found in the `${ddf-branding}.catalog.data.BasicTypes` class.

[cols="3*", options="header"]
|===

|Name
|Type
|Description

|`BASIC_METACARD`
|MetacardType
|representing all required Metacard Attributes

|`BINARY_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.BINARY`.

|`BOOLEAN_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.BOOLEAN`.

|`DATE_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.DATE`.

|`DOUBLE_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.DOUBLE`.

|`FLOAT_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.FLOAT`.

|`GEO_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.GEOMETRY`.

|`INTEGER_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.INTEGER`.

|`LONG_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.LONG`.

|`OBJECT_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.OBJECT`.

|`SHORT_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.SHORT`.

|`STRING_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.STRING`.

|`XML_TYPE`
|AttributeType
|A Constant for an AttributeType with `AttributeType.AttributeFormat.XML`.

|===

=== Extending Catalog Framework

This section describes the core components of the Catalog app and Catalog Framework. 
The Catalog Framework wires all Catalog components together.

It is responsible for routing Catalog requests and responses to the appropriate target. 

Endpoints send Catalog requests to the Catalog Framework.
The Catalog Framework then invokes Catalog Plugins, Transformers, and Resource Components as needed before sending requests to the intended destination, such as one or more Sources. 

The Catalog Framework functions as the routing mechanisms between all catalog components.
It decouples clients from service implementations and provides integration points for Catalog Plugins and convenience methods for Endpoint developers.

[ditaa, catalog_architecture_framework, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |c369               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Included Catalog Frameworks

===== Catalog API

The Catalog API is an OSGi bundle (`catalog-core-api`) that contains the Java interfaces for the Catalog components and implementation classes for the Catalog Framework, Operations, and Data components.

===== Standard Catalog Framework

The Standard Catalog Framework provides the reference implementation of a Catalog Framework that implements all requirements of the ${ddf-catalog}API. 
`CatalogFrameworkImpl` is the implementation of the ${branding} Standard Catalog Framework.

===== Installing and Uninstalling

The Standard Catalog Framework is bundled as the `catalog-core-standardframework` feature and can be installed and uninstalled using the normal processes described in Configuration.

When this feature is installed, the Catalog Fanout Framework App feature `catalog-core-fanoutframework` should be uninstalled, as both catalog frameworks should not be installed simultaneously.

===== Configuring

====== Configurable Properties

.Catalog Standard Framework
[cols="2,1,3,1,1", options="header"]
|===

|Property
|Type
|Description
|Default Value
|Required

|`fanoutEnabled`
|Boolean
|When enabled the Framework acts as a proxy, federating requests to all available sources. All requests are executed as federated queries and resource retrievals, allowing the framework to be the sole component exposing the functionality of all of its Federated Sources.
|false
|yes

|`productCacheDirectory`
|String
|Directory where retrieved products will be cached for faster, future retrieval. If a directory path is specified with directories that do not exist, Catalog Framework will attempt to create those directories. Out of the box (without configuration), the product cache directory is `<INSTALL_DIR>/data/product-cache`. If a relative path is provided it will be relative to the `<INSTALL_DIR>`.

It is recommended to enter an absolute directory path such as `/opt/product-cache`in Linux or `C:\product-cache` in Windows."
|`(empty)`
|no

|`cacheEnabled`
|Boolean
|Check to enable caching of retrieved products to provide faster retrieval for subsequent requests for the same product.
|false
|no

|`delayBetweenRetryAttempts`
|Integer
|The time to wait (in seconds) between each attempt to retry retrieving a product from the Source.
|10
|no

|`maxRetryAttempts`
|Integer
|The maximum number of attempts to try and retrieve a product from the Source.
|3
|no

|`cachingMonitorPeriod`
|Integer
|The number of seconds allowed for no data to be read from the product data before determining that the network connection to the Source where the product is located is considered to be down.
|5
|no

|`cacheWhenCanceled`
|Boolean
|Check to enable caching of retrieved products even if client cancels the download.
|false
|no

|===

[cols="2*", options="header"]
|===

|Managed Service PID
|`${ddf-branding}.catalog.CatalogFrameworkImpl`
|Managed Service Factory PID
|N/A
|===

===== Using

The Standard Catalog Framework is the core class of ${branding}.
It provides the methods for query, create, update, delete, and resource retrieval (QCRUD) operations on the `Sources`.
By contrast, the Fanout Catalog Framework only allows for query and resource retrieval operations, no catalog modifications, and all queries are enterprise-wide.

Use this framework if:

* access to a catalog provider to create, update, and delete catalog entries are required.
* queries to specific sites are required.
* queries to only the local provider are required.

It is possible to have only remote Sources configured with no local `CatalogProvider` configured and be able to execute queries to specific remote sources by specifying the site name(s) in the query request.

The Standard Catalog Framework also maintains a list of `ResourceReaders` for resource retrieval operations.
A resource reader is matched to the scheme (i.e., protocol, such as `file://`) in the URI of the resource specified in the request to be retrieved.

Site information about the catalog provider and/or any federated source(s) can be retrieved using the Standard Catalog Framework.
Site information includes the source's name, version, availability, and the list of unique content types currently stored in the source (e.g., NITF).
If no local catalog provider is configured, the site information returned includes site info for the catalog framework with no content types included.

===== Implementation Details

====== Exported Services

[cols="3,1,2", options="header"]
|===

|Registered Interface
|Service Property
|Value

|`${ddf-branding}.catalog.federation.FederationStrategy`
|shortname
|sorted

|`org.osgi.service.event.EventHandler`
|event.topics
|`${ddf-branding}/catalog/event/CREATED`, `${ddf-branding}/catalog/event/UPDATED`, d`df/catalog/event/DELETED`

|`${ddf-branding}.catalog.CatalogFramework`
|
|

|`${ddf-branding}.catalog.event.EventProcessor`
|
|

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|
|

|===

===== Imported Services

[cols="3,1,1" options="header"]
|===

|Registered Interface
|Availability
|Multiple

|`${ddf-branding}.catalog.plugin.PostFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreDeliveryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreSubscriptionPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PolicyPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.AccessPlugin`
|optional
|true

|`${ddf-branding}.catalog.resource.ResourceReader`
|optional
|true

|`${ddf-branding}.catalog.source.CatalogProvider`
|optional
|true

|`${ddf-branding}.catalog.source.ConnectedSource`
|optional
|true

|`${ddf-branding}.catalog.source.FederatedSource`
|optional
|true

|`${ddf-branding}.cache.CacheManager`
| 
|false

|`org.osgi.service.event.EventAdmin`
| 
|false

|===

==== Known Issues

None

=== Catalog Fanout Framework 

The Fanout Catalog Framework (`fanout-catalogframework` bundle) provides an implementation of the Catalog Framework that acts as a proxy, federating requests to all available sources. 
All requests are executed as federated queries and resource retrievals, allowing the fanout site to be the sole site exposing the functionality of all of its Federated Sources.
The Fanout Catalog Framework is the implementation of the Fanout Catalog Framework.

The Fanout Catalog Framework provides the capability to configure ${branding} to be a fanout proxy to other federated sources within the enterprise.
The Fanout Catalog Framework has no catalog provider configured for it, so it does not allow catalog modifications to take place.
Therefore, create, update, and delete operations are not supported.

.Catalog Fanout Framework
[ditaa,query-flow,png, ${image-width}]
....
           /------\
           |Client|
           |cDEF  |
           \------/
              ^
              |
+-------------|------------------------------------------------------------\
|DDF          |                                                       cCCC |
|             v                                                            |
|         /--------\   /-----------------\   /-------------------\         |
|         |Endpoint|<->|Catalog Framework|<->|Federation Strategy|         |
|         | cDEF   |   | cDEF            |   | cDEF              |         |
|         \--------/   \-----------------/   \-------------------/         |
|                                                     ^ ^                  |
|                                                     | |                  |
|                                          /----------/ \---------\        |
|                                          |                      |        |
| +----------------------------------------|----------------------|------+ |
| |Enterprise Query c369                   v                      v      | |
| |+--------------------------------------------+ +---------------------+| |
| ||Local Query                                 | |Federated Query      || |
| ||/------------------\ /---------------------\| |/-------------------\|| |
| ||| Catalog Provider | | Connected Source(s) || ||Federated Source(s)||| |
| |||  cDEF            | |  cDEF               || || cDEF              ||| |
| ||\------------------/ \---------------------/| |\-------------------/|| |
| |+-------^----------------------^-------------+ +----^----------^-----+| |
| +--------|----------------------|--------------------|----------|------+ |
\----------|----------------------|--------------------|----------|--------/
           |                      |                    |          \-------------------\
           |                      |                    |                              |
           v                      v                    v                              v
/=-------------------\ /----------------------\ /---------=------------\     /----------------------\
|Internal Data Source| |External Data Source 1| |External Data Source 3| ... |External Data Source N|
\--------------------/ \--------------------=-/ \----------------------/     \-------=--------------/
....

In addition, the Fanout Catalog Framework provides the following benefits:

* Backwards compatibility (e.g., federating with older versions) with existing older versions of ${branding}.
* A single node being exposed from an enterprise, thus hiding the enterprise from an external client.
* Ensures all queries and resource retrievals are federated.

===== Installing and Uninstalling

The Fanout Catalog Framework is bundled as the `catalog-core-fanoutframework` feature and can be installed and uninstalled using the normal processes described in Configuration.

[WARNING]
====
When this feature is installed, the Standard Catalog Framework feature `catalog-core-standardframework` should be uninstalled, as both catalog frameworks should not be installed simultaneously.
====

==== Configuring

The Fanout Catalog Framework can be configured using the normal processes described in Configuring ${branding}.

The configurable properties for the Fanout Catalog Framework are accessed from the Catalog Fanout Framework configuration in the Admin Console.

===== Configurable Properties

[cols="1,2,1,3,1,1" options="header"]
|===

|Title
|Property
|Type
|Description
|Default Value
|Required

|Default Timeout
(in milliseconds)
|`defaultTimeout`
|Integer
|The maximum amount of time to wait for a response from the Sources.
|60000
|yes

|Product Cache Directory
|`productCacheDirectory`
|String
|Directory where retrieved products will be cached for faster, future retrieval. If a directory path is specified with directories that do not exist, Catalog Framework will attempt to create those directories. Out of the box (without configuration), the product cache directory is `<INSTALL_DIR>/data/product-cache`. If a relative path is provided, it will be relative to the `<INSTALL_DIR>`.

It is recommended to enter an absolute directory path, such as `/opt/product-cache` in Linux or `C:\product-cache` in Windows.
|(empty)
|no

|Enable Product Caching
|`cacheEnabled`
|Boolean
|Check to enable caching of retrieved products to provide faster retrieval for subsequent requests for the same product.
|false
|no

|Delay (in seconds) between product retrieval retry attempts
|`delayBetweenRetryAttempts`
|Integer
|The time to wait (in seconds) between attempting to retry retrieving a product.
|10
|no

|Max product retrieval retry attempts
|`maxRetryAttempts`
|Integer
|The maximum number of attempts to retry retrieving a product.
|3
|no

|Caching Monitor Period
|`cachingMonitorPeriod`
|Integer
|How many seconds to wait and not receive product data before retrying to retrieve a product.
|5
|no

|Always Cache Product
|`cacheWhenCanceled`
|Boolean
|Check to enable caching of retrieved products, even if client cancels the download.
|false
|no

|===

[cols="2*" options="header"]
|===
|Managed Service PID
|`${ddf-branding}.catalog.impl.service.fanout.FanoutCatalogFramework`
|Managed Service Factory PID
|N/A
|===

===== Using

The Fanout Catalog Framework is a core class of ${branding} when configured as a fanout proxy.
It provides the methods for query and resource retrieval operations on the Sources, where all operations are enterprise-wide operations.
By contrast, the Standard Catalog Framework supports create/update/delete operations of metacards, in addition to the query and resource retrieval operations.

Use the Fanout Catalog Framework if:

* exposing a single node for enterprise access and hiding the details of the enterprise, such as federate source's names, is desired.
* access to individual federated sources is not required.
* access to a catalog provider to create, update, and delete metacards is not required.

The Fanout Catalog Framework also maintains a list of `ResourceReaders` for resource retrieval operations.
A resource reader is matched to the scheme (i.e., protocol, such as `file://`) in the URI of the resource specified in the request to be retrieved.

Site information about the fanout configuration can be retrieved using the Fanout Catalog Framework.
Site information includes the source's name, version, availability, and the list of unique content types currently stored in the source (e.g., NITF).
Details of the individual federated sources is not included, only the fanout catalog framework.

===== Implementation Details

====== Exported Services

[cols="3*" options="header"]
|===
|Registered Interface
|Service Property
|Value

|`${ddf-branding}.catalog.federation.FederationStrategy`
|shortname
|sorted

|`org.osgi.service.event.EventHandler`
|event.topics
|`${ddf-branding}/catalog/event/CREATED`, `${ddf-branding}/catalog/event/UPDATED`, `${ddf-branding}/catalog/event/DELETED`

|`${ddf-branding}.catalog.CatalogFramework`
|
|

|`${ddf-branding}.catalog.event.EventProcessor`
|
| 

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|
|

|===

===== Imported Services

[cols="3*" options="header"]
|===

|Registered Interface
|Availability
|Multiple

|`${ddf-branding}.cache.CacheManager`
|
|false

|`${ddf-branding}.catalog.plugin.PostFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PostResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreDeliveryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreFederatedQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreIngestPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreQueryPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreResourcePlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PreSubscriptionPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.PolicyPlugin`
|optional
|true

|`${ddf-branding}.catalog.plugin.AccessPlugin`
|optional
|true

|`${ddf-branding}.catalog.resource.ResourceReader`
|optional
|true

|`${ddf-branding}.catalog.source.ConnectedSource`
|optional
|true

|`${ddf-branding}.catalog.source.FederatedSource`
|optional
|true

|`org.osgi.service.event.EventAdmin`
| 
|false

|===

==== Known Issues

None

==== Catalog Framework Camel Component

The catalog framework camel component supports creating, updating, and deleting metacards using the Catalog Framework from a Camel route.

===== URI Format

----
catalog:framework
----

===== Message Headers

====== Catalog Framework Producer

[cols="1,5" options="header"]
|===
|Header
|Description

|operation
|the operation to perform using the catalog framework (possible values are CREATE \| UPDATE \| DELETE)
|===

===== Sending Messages to Catalog Framework Endpoint

====== Catalog Framework Producer

In Producer mode, the component provides the ability to provide different inputs and have the Catalog framework perform different operations based upon the header values.  

For the CREATE and UPDATE operation, the message body can contain a list of metacards or a single metacard object. 

For the DELETE operation, the message body can contain a list of strings or a single string object.
The string objects represent the IDs of metacards to be deleted. 
The exchange's "in" message will be set with the affected metacards.
In the case of a CREATE, it will be updated with the created metacards.
In the case of the UPDATE, it will be updated with the updated metacards and with the DELETE it will contain the deleted metacards.

[cols="2,2,3" options="header"]
|===
|Header
|Message Body (Input)
|Exchange Modification (Output)

|operation = CREATE
|List<Metacard> or Metacard
|exchange.getIn().getBody() updated with List of Metacards created

|operation = UPDATE
|List<Metacard> or Metacard
|exchange.getIn().getBody() updated with List of Metacards updated

|operation = DELETE
|List<String> or String (representing metacard IDs)
|exchange.getIn().getBody() updated with List of Metacards deleted

|===

====== Samples

This example demonstrates:

. Reading in some sample data from the file system.
. Using a Java bean to convert the data into a metacard.
. Setting a header value on the Exchange.
. Sending the Metacard to the Catalog Framework component for ingestion.

[source,xml,linenums]
----
<route>
 <from uri="file:data/sampleData?noop=true“/>
    <bean ref="sampleDataToMetacardConverter" method="covertToMetacard"/>\
   <setHeader headerName="operation">
  <constant>CREATE</constant>
 </setHeader>
    <to uri="catalog:framework"/>
</route>
----


==== Working with the Catalog Framework

===== Catalog Framework Reference

The Catalog Framework can be requested from the OSGi registry.

.Blueprint Service Reference
[source,xml]
----
<reference id="catalogFramework" interface="${ddf-branding}.catalog.CatalogFramework" />
----

===== Methods

====== Create, Update, and Delete

Create, Update, and Delete (CUD) methods add, change, or remove stored metadata in the local Catalog Provider.

.Create, Update, Delete Methods
[source,java,linenums]
----
public CreateResponse create(CreateRequest createRequest) throws IngestException, SourceUnavailableException;
public UpdateResponse update(UpdateRequest updateRequest) throws IngestException, SourceUnavailableException;
public DeleteResponse delete(DeleteRequest deleteRequest) throws IngestException, SourceUnavailableException;
----

CUD operations process `PolicyPlugin`, `AccessPlugin`, and `PreIngestPlugin` instances before execution and `PostIngestPlugin` instances after execution.

====== Query

Query methods search metadata from available Sources based on the `QueryRequest` properties and Federation Strategy.
Sources could include Catalog Provider, Connected Sources, and Federated Sources.

.Query Methods
[source,java,linenums]
----
public QueryResponse query(QueryRequest query) throws UnsupportedQueryException,SourceUnavailableException, FederationException;
public QueryResponse query(QueryRequest queryRequest, FederationStrategy strategy) throws SourceUnavailableException, UnsupportedQueryException, FederationException;
----
Query requests process  `PolicyPlugin`, `AccessPlugin`, and `PreQueryPlugin` instances before execution and  `PolicyPlugin`, `AccessPlugin`, and `PostQueryPlugin` instances after execution.

====== Resources

Resource methods retrieve products from Sources.

.Resource Methods
[source,java,linenums]
----
public ResourceResponse getEnterpriseResource(ResourceRequest request) throwsIOException, ResourceNotFoundException, ResourceNotSupportedException;
public ResourceResponse getLocalResource(ResourceRequest request) throws IOException, ResourceNotFoundException, ResourceNotSupportedException;
public ResourceResponse getResource(ResourceRequest request, String resourceSiteName) throws IOException, ResourceNotFoundException, ResourceNotSupportedException;
----
Resource requests process `PreResourcePlugin`s before execution and `PostResourcePlugin`s after execution.

====== Sources

Source methods can get a list of Source identifiers or request descriptions about Sources.

.Source Methods
[source,java,linenums]
----
public Set<String> getSourceIds();
public SourceInfoResponse getSourceInfo(SourceInfoRequest sourceInfoRequest) throws SourceUnavailableException;
----

====== Transforms

Transform methods provide convenience methods for using Metacard Transformers and Query Response Transformers.

.Transform Methods
[source,java,linenums]
----
// Metacard Transformer
public BinaryContent transform(Metacard metacard, String transformerId, Map<String,Serializable> requestProperties) throws CatalogTransformerException;

// Query Response Transformer
public BinaryContent transform(SourceResponse response, String transformerId, Map<String, Serializable> requestProperties) throws CatalogTransformerException;
----

==== Developing Complementary Frameworks

${branding} and the underlying OSGi technology can serve as a robust infrastructure for developing frameworks that complement the ${ddf-catalog}.

Recommendations for Framework Development

. Provide extensibility similar to that of the ${ddf-catalog}.
.. Provide a stable API with interfaces and simple implementations (refer to `http://www.ibm.com/developerworks/websphere/techjournal/1007_charters/1007_charters.html`).
. Make use of the ${ddf-catalog} wherever possible to store, search, and transform information.
. Utilize OSGi standards wherever possible.
.. ConfigurationAdmin
.. MetaType
. Utilize the sub-frameworks available in ${branding}.
.. Karaf
.. CXF
.. PAX Web and Jetty

==== Developing Console Commands

===== Console Commands

${branding} supports development of custom console commands.

${branding} includes custom commands for working with the Catalog, as described in the <<managing.adoc#_console_commands, Managing Console Commands>> section.

=== Extending Sources
Catalog sources are used to connect Catalog components to data sources, local and remote.
Sources act as proxies to the actual external data sources, e.g., a RDBMS database or a NoSQL database.

[ditaa, sources_architecture, png, ${image-width}]
....
+----------------------------------------------------------------------------------------------+
|                /-------------------\                                               +-=------+|
|                |cDEFEndpoints      |            /-----------------------------\    |External||
|                +------------+------+            |c369   Remote Sources        |    | Data{s}||
|                |cDEF        |cDEF  |            | /-------------------------\ |    |Holdings||
|                | Operations | Data |            | |c369Federated Sources    |-+--> +--------+|
|/---------------+------------+------+------------+ +-------------------------+ |              |
||cDEF           |cDEF               |cDEF        | |c369Connected Sources    |-+--> +-=------+|
||  Transformers |                   | Federation | \-------------------------/ |    |External||
|+---------------+ Catalog Framework +------------+-----------------------------+    | Data{s}||
||cDEF           |                   |cDEF           Eventing                   |    |Holdings||
||   Catalog     |                   +------------------------------------------+    +--------+|
||   Plugins     |                   |cDEF           Resources                  |              |
|\---------------+-------------------+------------------------------------------/              |
|                |c369               |                                                         |
|                | Catalog Provider  |              cFFF                                       |
|                \-------------------/                                                         |
|                          |                                                                   |
|                          v                                                                   |
|                  +-=-------------+                                                           |
|                  |               |                                                           |
|                  |{s}Data Store  |                                                           |
|                  +---------------+                                                           |
+----------------------------------------------------------------------------------------------+
....

==== Existing Source Types

===== Catalog Provider
A Catalog provider provides an implementation of a searchable and writable catalog.
All sources, including federated source and connected source, support queries, but a Catalog provider also allows metacards to be created, updated, and deleted.

A Catalog provider typically connects to an external application or a storage system (e.g., a database), acting as a proxy for all catalog operations.

===== Using

The Standard Catalog Framework uses only one Catalog provider, determined by the OSGi Framework as the service reference with the highest service ranking.
In the case of a tie, the service with the lowest service ID (first created) is used.

The Catalog Fanout Framework App does not use a Catalog provider and will fail any create/update/delete operations even if there are active Catalog providers configured.

The Catalog reference implementation comes with a Solr Provider out of the box.

==== Remote Sources

Remote sources are read-only data sources that support query operations but cannot be used to create, update, or delete metacards.

[TIP]
====
Remote sources currently extend the `ResourceReader` interface.
However, a `RemoteSource` is not treated as a `ResourceReader`.
The `getSupportedSchemes()` method should never be called on a `RemoteSource`, thus the suggested implementation for a `RemoteSource` is to return an empty set.
The `retrieveResource( ... )` and `getOptions( ... )` methods will be called and MUST be properly implemented by a `RemoteSource`.
====

==== Connected Source

A connected source is a remote source that is included in all local and federated queries but remains hidden from external clients.
A connected source's identifier is removed in all query results by replacing it with ${branding}'s source identifier.
The Catalog Framework does not reveal a connected source as a separate source when returning source information responses.

.Connected Sources
image::query-flow.png, ${image-width}[]

==== Federated Source

A federated source is a remote source that can be included in federated queries by request or as part of an enterprise query.
Federated sources support query and site information operations only.
Catalog modification operations, such as create, update, and delete, are not allowed.
Federated sources also expose an event service, which allows the Catalog Framework to subscribe to even notifications when metacards are created, updated, and deleted.

${ddf-catalog} instances can also be federated to each other.
Therefore, a ${ddf-catalog} can also act as a federated source to another ${ddf-catalog}.

==== OpenSearch Source

The OpenSearch source provides a Federated Source that has the capability to do http://www.opensearch.org/Home[OpenSearch] queries for metadata from Content Discovery and Retrieval (CDR) Search V1.1 compliant sources.
The OpenSearch source does not provide a Connected Source interface.

===== Installing and Uninstalling

The OpenSearch source can be installed and uninstalled using the normal processes described in the Configuring ${branding} section.

===== Configuring

This component can be configured using the normal processes described in the Configuring ${branding} section.
The configurable properties for the OpenSearch source are accessed from the Catalog OpenSearch Federated Source Configuration in the Web Console.

===== Configuring the OpenSearch Source

====== Configurable Properties
[cols="1,1,1,3,1,1" options="header"]
|===

|Title
|Property
|Type
|Description
|Default Value
|Required

|Source Name
|`shortname`
|String
|
|DDF-OS
|Yes

|OpenSearch service URL
|`endpointUrl`
|String
|The OpenSearch endpoint URL, e.g., ${branding}'s OpenSearch endpoint (http://0.0.0.0:8181/services/catalog/query?q={searchTerms}...)
|https://example.com?q={searchTerms}&amp;src={fs:routeTo?}&amp;mr={fs:maxResults?}&amp;count={count?}&amp;mt={fs:maxTimeout?}&amp;dn={idn:userDN?}&amp;lat={geo:lat?}&amp;lon={geo:lon?}&amp;radius={geo:radius?}&amp;bbox={geo:box?}&amp;polygon={geo:polygon?}&amp;dtstart={time:start?}&amp;dtend={time:end?}&amp;dateName={cat:dateName?}&amp;filter={fsa:filter?}&amp;sort={fsa:sort?}
|Yes

|Username
|`username`
|String
|Username to use with HTTP Basic Authentication. This auth info will overwrite any federated auth info. Only set this if the OpenSearch endpoint requires basic authentication.
|
|No

|Password
|`password`
|String
|Password to use with HTTP Basic Authentication. This auth info will overwrite any federated auth info. Only set this if the OpenSearch endpoint requires basic authentication.
|
|No

|Always perform local query
|`localQueryOnly`
|Boolean
|Always performs a local query by setting src=local OpenSearch parameter in endpoint URL. *This must be set if federating to another ${branding}*.
|false
|Yes

|Convert to BBox
|`shouldConvertToBBox`
|Boolean
|Converts Polygon and Point-Radius searches to a Bounding Box for compatibility with legacy interfaces. Generated bounding box is a very rough representation of the input geometry
|true
|Yes

|===

===== Using

Use the OpenSearch source if querying a CDR-compliant search service is desired.

===== Query Format

====== OpenSearch Parameter to ${branding} Query Mapping

[cols="2*" options="header"]
|===
|OpenSearch/CDR Parameter
|${branding} Data Location

|q={searchTerms}
|Pulled verbatim from ${branding} query.

|src={fs:routeTo?}
|Unused

|mr={fs:maxResults?}
|Pulled verbatim from ${branding} query.

|count={count?}
|Pulled verbatim from ${branding} query.

|mt={fs:maxTimeout?}
|Pulled verbatim from ${branding} query.

|dn={idn:userDN?}
|${branding} Subject

|lat={geo:lat?}
|Pulled verbatim from ${branding} query.

|lon={geo:lon?}
|Pulled verbatim from ${branding} query.

|radius={geo:radius?}
|Pulled verbatim from ${branding} query.

|bbox={geo:box?}
|Converted from Point-Radius ${branding} query.

|polygon={geo:polygon?}
|Pulled verbatim from ${branding} query.

|dtstart={time:start?}
|Pulled verbatim from ${branding} query.

|dtend={time:end?}
|Pulled verbatim from ${branding} query.

|dateName={cat:dateName?}
|Unused

|filter={fsa:filter?}
|Unused

|sort={fsa:sort?}
|Translated from ${branding} query.
Format: "relevance" or "date"
Supports "asc" and "desc" using colon as delimiter.

|===

===== Implementation Details

====== Exported Services

[cols="2,1,1" options="header"]
|===

|Registered Interface
|Service Property
|Value

|`${ddf-branding-lowercase}.catalog.source.FederatedSource`
|
|

|===

===== Imported Services
[cols="2,1,1,2" options="header"]
|===

|Registered Interface
|Availability
|Multiple
|Filter

|${ddf-branding-lowercase}.catalog.transform.InputTransformer
|required
|false
|(&amp;(mime-type=text/xml)(id=xml))

|===

===== Known Issues

The OpenSearch source does not provide a Connected Source interface.

==== Federated Source for Atlassian Confluence(R)

The Confluence source provides a Federated Source to retrieve pages, comments, and attachments from a Confluence REST API and turns the results into Metacards the system can use.
The Confluence source does provide a Connected Source interface but its functionality has not been verified.

Confluence Source has been tested against the following versions of Confluence with REST API v2

* Confluence 1000.444.5 (Cloud)
* Confluence 5.10.6 (Server)
* Confluence 5.10.7 (Server)

===== Installing the Confluence Source

The Confluence Federated Source is installed by default with a standard installation in the ${ddf-spatial} application.

Add a New Confluence Federated Source through the ${admin-console}:

* Navigate to the *${admin-console}*.
* Select the *${ddf-catalog}* application.
* Select the *Sources* tab.
* Add a New source.
* Name the New source.
* Select *Confluence Federated Source* from *Binding Configurations*.

===== Configuring the Confluence Source

This component can be configured using the normal processes described in the Configuring ${branding} section.
The configurable properties for the Confluence source are accessed from the Confluence Federated Source Configuration in the Admin UI.

====== Configurable Properties
[cols="1,1m,1,2,1,1" options="header"]
|===
|Name
|Property
|Type
|Description
|Default Value
|Required

|Source Name
|shortname
|String
|
|
|Yes

|Confluence Rest URL
|endpointUrl
|String
|The Confluence Rest API endpoint URL. Example: https://<host>:<port>/rest/api/content
|
|Yes

|Username
|username
|String
|Username to use with HTTP Basic Authentication. This auth info will overwrite any federated auth info. Only set this if the Confluence endpoint requires basic authentication.
|
|No

|Password
|password
|Password
|Password to use with HTTP Basic Authentication. This auth info will overwrite any federated auth info. Only set this if the Confluence endpoint requires basic authentication.
|
|No

|Include Page Contents In Results
|includePageContent
|Boolean
|Flag indicating if Confluence page contents should be included in the returned results. If page contents not included in results then the returned metacards will not have the `description` or `metadata` fields set.
|false
|No

|Include Archived Spaces
|includeArchivedSpaces
|Boolean
|Flag indicating if archived confluence spaces should be included in search results.
|false
|No

|Exclude Confluence Spaces
|excludeSpaces
|Boolean
|Flag indicating if the list of Confluence Spaces should be excluded from searches instead of included.
|false
|No

|Confluence Spaces
|confluenceSpaces
|String cardinality=1000
|The confluence spaces to include/exclude from searches. If no spaces are specified, all visible spaces will be searched. A confluence space must be set in order for wildcard only searches to work.
|
|No

|Additional Attributes
|additionalAttributes
|String cardinality=100
|Additional attributes to add to confluence metacards returned from this source.
|
|No

|Availability Poll Interval
|availabilityPollInterval
|Long
|Availability polling interval in milliseconds.
|60000
|No

|===

===== Using

Use the Confluence source if querying a Confluence server is desired.

===== Restrictions

Most of the fields that can be queried on confluence have some sort of restriction on them. Most of the fields do not support the `like` aka `~` operation so the source will convert `like` queries to `equal` queries for attributes that don't support `like`. If the source receives a query with attributes it doesn't understand, it will just ignore them. If the query doesn't contain any attributes that map to confluence search attributes, an empty result set will be returned.

===== Implementation Details

====== Common Taxonomy Mappings
[cols="2,4,2" options="header"]
|===

|Taxonomy Name
|Source
|Query Restrictions

|created
|history.createDate
|>, <, =

|description
|First 256 characters of the Confluence entry body
|Not directly queryable.

|id
|Uses the Confluence id as the metacard id.
|=, !=

|metacard-tags
|resource, confluence
|blank

|metadata
|Tika-like formatted xml containing the entire text body of the Confluence entry
|Queryable via `anyText` ~, !~

|modified
|history.lastModified.when
|>, <, =

|resource-download-url
|_links.download
|Not directly queryable.

|resource-size
|extensions.fileSize
|Not directly queryable.

|resource-uri
|_links.download
|Not directly queryable.

|title
|title
|=, !=, ~, !~

|associations.external
|_links.webui, _links.base, space._links.webui
|Not directly queryable.

|contact.contributor-name
|history.contributors.publishers.users.username
|=, !=

|contact.creator-name
|history.createdBy.username
|=, !=

|media.type
|metadata.mediaType
|Not directly queryable.

|metacard.created
|history.createDate
|>, <, =

|metacard.modified
|history.lastModified.when
|>, <, =

|security.access-groups
|restrictions.read.restrictions.group.name
|Not directly queryable.

|security.access-individuals
|restrictions.read.restrictions.user.username
|Not directly queryable.

|topic.keyword
|metadata.labels.results.name
|=, !=

|topic.category
|type
|=, !=

|topic.vocabulary
|https://developer.atlassian.com/confdev/confluence-server-rest-api/advanced-searching-using-cql/cql-field-reference#CQLFieldReference-titleTitleType
|Not directly queryable.

|===

====== Exported Services

[cols="2,1,1" options="header"]
|===

|Registered Interface
|Service Property
|Value

|`${ddf-branding-lowercase}.catalog.source.FederatedSource`
|
|

|===

===== Imported Services
[cols="2,1,1,2" options="header"]
|===

|Registered Interface
|Availability
|Multiple
|Filter

|${ddf-branding-lowercase}.security.encryption.EncryptionService
|required
|false
|

|${ddf-branding-lowercase}.catalog.filter.FilterAdapter
|required
|false
|

|${ddf-branding-lowercase}.catalog.resource.ResourceReader
|required
|false
|(shortname=URLResourceReader)

|===

===== Known Issues

Depending on your version of Confluence, when downloading attachments you might get redirected to a different download URL. If this happens the default URLResourceReader configuration does not allow redirects and will fail the download. This can be fixed by enabling redirects in the URLResourceReader configuration.

==== Developing a Source

Sources are components that enable ${branding} to talk to back-end services.
They let ${branding} perform query and ingest operations on catalog stores and query operations on federated sources.
Sources reside in the Sources area of the ${branding} Overview.

===== Creating a New Source

===== Implement a Source Interface

There are three types of sources that can be created.
All of these types of sources can perform a query operation.
Operating on queries is the foundation for all sources.
All of these sources must also be able to return their availability and the list of content types currently stored in their back-end data stores.

* Catalog Provider - `${ddf-branding}.catalog.source.CatalogProvider` +
_Used to communicate with back-end storage. Allows for Query and Create/Update/Delete operations._
* Federated Source - `${ddf-branding}.catalog.source.FederatedSource` +
_Used to communicate with remote systems. Only allows query operations._
* Connected Source - `${ddf-branding}.catalog.source.ConnectedSource` +
_Similar to a Federated Source with the following exceptions:_
** _Queried on all local queries_
** _SiteName is hidden (masked with the ${branding} sourceId) in query results_
** _SiteService does not show this Source's information separate from ${branding}'s._

The procedure for implementing any of the source types follows a similar format:
. Create a new class that implements the specified Source interface and `ConfiguredService`.
. Implement the required methods.
. Create an OSGi descriptor file to communicate with the OSGi registry. (Refer to the OSGi Services  section.)
.. Import ${branding} packages.
.. Register source class as service to the OSGi registry.
. Deploy to ${branding}.
[IMPORTANT]
====
The `factory-pid` property of the metatype must contain one of the following in the name: service, Service, source, Source
====

===== Catalog Provider
. Create a Java class that implements `CatalogProvider`. +
`public class TestCatalogProvider implements ${ddf-branding}.catalog.source.CatalogProvider`
. Implement the required methods from the `${ddf-branding}.catalog.source.CatalogProvider` interface. +
`public CreateResponse create(CreateRequest createRequest) throws IngestException;`
`public UpdateResponset update(UpdateRequest updateRequest) throws IngestException;`
`public DeleteResponse delete(DeleteRequest deleteRequest) throws IngestException;`

. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.source`
. Export the service to the OSGi registry.

.Blueprint example
[source,xml]
----
<service ref="[[TestCatalogProvider]]" interface="${ddf-branding}.catalog.source.CatalogProvider" />
----
The ${branding} Integrator's Guide provides details on the following Catalog Providers that come with ${branding} out of the box.

[NOTE]
====
A code example of a Catalog Provider delivered with ${branding} is the Catalog Solr Embedded Provider.
====

===== Federated Source
. Create a Java class that implements `FederatedSource` and `ConfiguredService`. +
`public class TestFederatedSource implements ${ddf-branding}.catalog.source.FederatedSource, ${ddf-branding}.catalog.service.ConfiguredService`
. Implement the required methods of the `${ddf-branding}.catalog.source.FederatedSource` and `${ddf-branding}.catalog.service.ConfiguredService` interfaces.
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.source`
. Export the service to the OSGi registry.

.Blueprint example
[source,xml]
----
<service ref="[[TestFederatedSource]]" interface="${ddf-branding}.catalog.source.FederatedSource" />
----

[NOTE]
====
A code example of a Federated Source delivered with ${branding} can be found in `${ddf-branding}.catalog.source.solr`
====

===== Connected Source

. Create a Java class that implements `ConnectedSource` and `ConfiguredService`. +
`public class TestConnectedSource implements ${ddf-branding}.catalog.source.ConnectedSource, ${ddf-branding}.catalog.service.ConfiguredService`
. Implement the required methods of the `${ddf-branding}.catalog.source.ConnectedSource` and `${ddf-branding}.catalog.service.ConfiguredService` interfaces.
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.source`
. Export the service to the OSGi registry.

.Blueprint example
[source,xml,linenums]
----
<service ref="[[TestConnectedSource]]" interface="${ddf-branding}.catalog.source.ConnectedSource" />
----
[IMPORTANT]
====
In some Providers that are created, there is a need to make Web Service calls through JAXB clients.
It is best NOT to create your JAXB client as a global variable.
There may be intermittent failures with the creation of Providers and federated sources when clients are created in this manner.
Create your JAXB clients every single time within the methods that require it in order to avoid this issue.
====

===== Exception Handling
In general, sources should only send information back related to the call, not implementation details.

===== Examples
* "Site XYZ not found" message rather than the full stack trace with the original site not found exception.
* The caller issues a malformed search request. Return an error describing the right form, or specifically what was not recognized in the request. Do not return the exception and stack trace where the parsing broke.
* The caller leaves something out. Do not return the null pointer exception with a stack trace, rather return a generic exception with the message "xyz was missing."

====== Additional Information

* http://today.java.net/pub/a/today/2003/12/04/exceptions.html[Three Rules for Effective Exception Handling]

==== Developing a Filter Delegate

Filter Delegates help reduce the complexity of parsing OGC Filters.
The reference Filter Adapter implementation contains the necessary boilerplate visitor code and input normalization to handle commonly supported OGC Filters.

===== Creating a New Filter Delegate

A Filter Delegate contains the logic that converts normalized filter input into a form that the targeted data source can handle.
Delegate methods will be called in a depth first order as the Filter Adapter visits filter nodes.

===== Implementing the Filter Delegate

. Create a Java class extending `FilterDelegate`. +
`public class ExampleDelegate extends ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> {`
. `FilterDelegate` will throw an appropriate exception for all methods not implemented.  Refer to the ${branding} JavaDoc for more details about what is expected of each `FilterDelegate` method.

[NOTE]
====
A code example of a Filter Delegate can be found in `${ddf-branding}.catalog.filter.proxy.adapter.test` of the `filter-proxy` bundle.
====

===== Throwing Exceptions

Filter delegate methods can throw `UnsupportedOperationException` run-time exceptions.
The `GeotoolsFilterAdapterImpl` will catch and re-throw these exceptions as `UnsupportedQueryExceptions`.

===== Using the Filter Adapter
The FilterAdapter can be requested from the OSGi registry.

[source,xml]
----
<reference id="filterAdapter" interface="${ddf-branding}.catalog.filter.FilterAdapter" />
----

The Query in a QueryRequest implements the Filter interface.
The Query can be passed to a `FilterAdapter` and `FilterDelegate` to process the Filter.

[source,java,linenums]
----
@Override
public ${ddf-branding}.catalog.operation.QueryResponse query(${ddf-branding}.catalog.operation.QueryRequest queryRequest)
    throws ${ddf-branding}.catalog.source.UnsupportedQueryException {

    ${ddf-branding}.catalog.operation.Query query = queryRequest.getQuery();

    ${ddf-branding}.catalog.filter.FilterDelegate<ExampleReturnObjectType> delegate = new ExampleDelegate();

    // ${ddf-branding}.catalog.filter.FilterAdapter adapter injected via Blueprint
    ExampleReturnObjectType result = adapter.adapt(query, delegate);
}
----

Import the ${ddf-catalog} API Filter package and the reference implementation package of the Filter Adapter in the bundle manifest  (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.filter, ${ddf-branding}.catalog.source`

===== Filter Support

Not all OGC Filters are exposed at this time.
If demand for further OGC Filter functionality is requested, it can be added to the Filter Adapter and Delegate so sources can support more complex filters.
The following OGC Filter types are currently available:

[cols="1" options="header"]
|===
|Logical
|And
|Or
|Not
|Include
|Exclude
|===

[cols="1" options="header"]
|===
|Property Comparison
|`PropertyIsBetween`
|`PropertyIsEqualTo`
|`PropertyIsGreaterThan`
|`PropertyIsGreaterThanOrEqualTo`
|`PropertyIsLessThan`
|`PropertyIsLessThanOrEqualTo`
|`PropertyIsLike`
|`PropertyIsNotEqualTo`
|`PropertyIsNull`
|===

[cols="2,5" options="header"]
|===
|`Spatial`
|Definition

|`Beyond`
|True if the geometry being tested is beyond the stated distance of the geometry provided.

|`Contains`
|True if the second geometry is wholly inside the first geometry.

|`Crosses`
|True if the intersection of the two geometries results in a value whose dimension is less than the geometries and the maximum dimension of the intersection value includes points interior to both the geometries, and the intersection value is not equal to either of the geometries.

|`Disjoint`
|True if the two geometries do not touch or intersect.

|`DWithin`
|True if the geometry being tested is within the stated distance of the geometry provided.

|`Intersects`
|True if the two geometries intersect. This is a convenience method as you could always ask for Not Disjoint(A,B) to get the same result.

|`Overlaps`
|True if the intersection of the geometries results in a value of the same dimension as the geometries that is different from both of the geometries.

|`Touches`
|True if and only if the only common points of the two geometries are in the union of the boundaries of the geometries.

|`Within`
|True if the first geometry is wholly inside the second geometry.
|===

[cols="1" options="header"]
|===
|Temporal
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/After.html[After]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/Before.html[Before]
|http://docs.geotools.org/latest/javadocs/org/opengis/filter/temporal/During.html[During]
|===

=== Extending Catalog Transformers

Transformers transform data to and from various formats.
Transformers can be categorized on the basis of when they are invoked and used.
The existing types are Input transformers, Metacard transformers, and Query Response transformers.
Additionally, XSLT transformers are provided to aid in developing custom, lightweight Metacard and Query Response transformers.

Transformers are utility objects used to transform a set of standard ${branding} components into a desired format, such as into PDF, GeoJSON, XML, or any other format.
For instance, a transformer can be used to convert a set of query results into an easy-to-read GeoJSON format (GeoJSON Transformer) or convert a set of results into a RSS feed that can be easily published to a URL for RSS feed subscription.
A major benefit of transformers is that they can be registered in the OSGi Service Registry so that any other developer can access them based on their standard interface and self-assigned identifier, referred to as its "shortname."
Transformers are often used by endpoints for data conversion in a system standard way.
Multiple endpoints can use the same transformer, a different transformer, or their own published transformer.

.Transformers
[ditaa, catalog_architecture_transformers, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||c369           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

[WARNING]
====
The current transformers only work for UTF-8 characters and do not support Non-Western Characters (e.g., Hebrew).
It is recommend not to use international character sets as they may not be displayed properly.
====

.Communication Diagram
[ditaa, transformer_communication_diagram, png, ${image-width}]
....
/------\
|Client|
|cDEF  |
\------/
    ^
    |
+-------------------------------------------\
|DDF|                                  cCCC |
|   v                                       |
|/--------\   /-----------------\   /------\|
||Endpoint|<->|Catalog Framework|<->|Source||
|| cDEF   |   | cDEF            |   | cDEF ||
|\--------/   \-----------------/   \------/|
|                      ^                    |
|                      |                    |
|                      v                    |
|               /-------------\             |
|               | Transformer |             |
|               |  cDEF       |             |
|               \-------------/             |
\-------------------------------------------/
....

==== Working with Transformers

The `${ddf-branding}.catalog.transform` package includes the `InputTransformer`, `MetacardTransformer`, and `QueryResponseTransformer` interfaces.
All implementations can be accessed using the Catalog Framework or OSGi Service Registry, as long as the implementations have been registered with the Service Registry.

==== Catalog Framework

The `CatalogFramework` provides convenient methods to transform `Metacards` and `QueryResponses` using a reference to the `CatalogFramework`.
See Working with the Catalog Framework for more details on the method signatures.
It is easy to execute the convenience `transform` methods on the `CatalogFramework` instance.

.Query Response Transform Example
[source,java,linenums]
----
// inject CatalogFramework instance or retrieve an instance
private CatalogFramework catalogFramework;

public RSSEndpoint(CatalogFramework catalogFramework)
{
     this.catalogFramework = catalogFramework ;
     // implementation
}

 // Other implementation details ...

private void convert(QueryResponse queryResponse ) {
    // ...
    String transformerId = "rss";

    BinaryContent content = catalogFramework.transform(queryResponse, transformerId, null);

    // ...

}
----

[cols="2,5" options="header"]
|===
|Line #
|Action
|4
|`CatalogFramework` is injected, possibly by dependency injection framework.

|16
|`queryResponse` is transformed into the RSS format, which is stored in the `BinaryContent` instance
|===

==== Dependency Injection
Using Blueprint or another injection framework, transformers can be injected from the OSGi Service Registry.

.Blueprint Service Reference
[source,xml]
----
<reference id="[[Reference Id]]" interface="${ddf-branding}.catalog.transform.[[Transformer Interface Name]]" filter="(shortname=[[Transformer Identifier]])" />
----

Each transformer has one or more `transform` methods that can be used to get the desired output.

.Input Transformer Example
[source,java,linenums]
----
${ddf-branding}.catalog.transform.InputTransformer inputTransformer = retrieveInjectedInstance() ;

Metacard entry = inputTransformer.transform(messageInputStream);
----

.Metacard Transformer Example
[source,java,linenums]
----
${ddf-branding}.catalog.transform.MetacardTransformer metacardTransformer = retrieveInjectedInstance() ;

BinaryContent content = metacardTransformer.transform(metacard, arguments);
----

.Query Response Transformer Example
[source,java,linenums]
----
${ddf-branding}.catalog.transform.QueryResponseTransformer queryResponseTransformer = retrieveInjectedInstance() ;

BinaryContent content = queryResponseTransformer.transform(sourceSesponse, arguments);
----

==== OSGi Service Registry

[IMPORTANT]
====
In the vast majority of cases, working with the OSGi Service Reference directly should be avoided.
Instead, dependencies should be injected via a dependency injection framework like Blueprint.
====

Transformers are registered with the OSGi Service Registry.
Using a `BundleContext` and a filter, references to a registered service can be retrieved.

.OSGi Service Registry Reference Example
[source,java,linenums]
----
ServiceReference[] refs =
    bundleContext.getServiceReferences(${ddf-branding}.catalog.transform.InputTransformer.class.getName(),"(shortname=" + transformerId + ")");
InputTransformer inputTransformer = (InputTransformer) context.getService(refs[0]);
Metacard entry = inputTransformer.transform(messageInputStream);
----

==== Included Input Transformers

An input transformer transforms raw data (text/binary) into a Metacard.

Once converted to a Metacard, the data can be used in a variety of ways, such as in an `UpdateRequest`, `CreateResponse`, or within Catalog Endpoints or Sources.
For instance, an input transformer could be used to receive and translate XML into a Metacard so that it can be placed within a `CreateRequest` in order to be ingested within the Catalog.
Input transformers should be registered within the Service Registry with the interface `${ddf-branding}.catalog.transform.InputTransformer` in order to notify some Catalog components of any new transformers.

===== Tika Input Transformer

The Tika Input Transformer is the default input transformer responsible for translating Microsoft Word, Microsoft Excel, Microsoft PowerPoint, OpenOffice Writer, and PDF documents into a Catalog Metacard.
This input transformer utilizes Apache Tika to provide basic support for these mime types.
As such, the metadata extracted from these types of documents is the metadata that is common across all of these document types, e.g., creation date, author, last modified date, etc.
The Tika Input Transformer's main purpose is to ingest these types of content into the Metadata Catalog.

The Tika input transformer is given a service ranking (prioity) of -1 so that it is guaranteed to be the last input transformer that is invoked.
This allows any registered input transformer that are more specific for any of these document types to be invoked instead of this rudimentary default input transformer.

====== Installing and Uninstalling

This transformer is installed by default.
To install or uninstall manually, use the `tika-input-transformer` feature in the ${admin-console} (${secure_url}/admin) under DDF Catalog -> Features or use the System Console.

Install the `catalog-transformer-tika` feature using the ${admin-console}.
This feature is uninstalled by default.

====== Configuring

None

====== Using

Use the Tika Input Transformer for ingesting Microsoft documents, OpenOffice documents, or PDF documents into the Catalog.

====== Service Properties

[cols="2,5a" options="header"]
|===

|Key
|Value

|mime-type
|* application/pdf
* application/vnd.openxmlformats-officedocument.wordprocessingml.document
* application/vnd.openxmlformats-officedocument.spreadsheetml.sheet
* application/vnd.openxmlformats-officedocument.presentationml.presentation
* application/vnd.openxmlformats-officedocument.presentationml.presentation
* application/vnd.ms-powerpoint.presentation.macroenabled.12
* application/vnd.ms-powerpoint.slideshow.macroenabled.12
* application/vnd.openxmlformats-officedocument.presentationml.slideshow
* application/vnd.ms-powerpoint.template.macroenabled.12
* application/vnd.oasis.opendocument.text

|shortname
|

|id
|tika

|title
|Tika Input Transformer

|description
|Default Input Transformer for all mime types.

|`service.ranking`
|-1

|===

====== Implementation Details

This input transformer maps the metadata common across all mime types to applicable metacard attributes in the default MetacardType.

===== PPTX Input Transformer

The PPTX Input Transformer is the input transformer responsible for translating Microsoft PowerPoint (OOXML only) documents into a Catalog Metacard. This input transformer utilizes Apache Tika
(for basic metadata) and Apache POI (for thumbnail creation). The PPTX Input Transformer's main purpose is to ingest PPTX documents into the ${branding} Content Repository and the Metadata Catalog.

The PPTX Input Transformer will take precedence over the Tika Input Transformer for PPTX documents.

====== Installing and Uninstalling
This transformer is installed by default. To install or uninstall manually, use the `catalog-transformer-pptx` feature in the ${admin-console} (${secure_url}/admin) under DDF Catalog -> Features.


====== Configuring
This transformer does not require any configuring.

====== Using
Use the PPTX Input Transformer for ingesting Microsoft PowerPoint (OOXML only) documents into the ${branding} Content Repository and/or the Metadata Catalog.

====== Service Properties

[cols="2,5a" options="header"]
|===

|Key
|Value

|mime-type
|* application/vnd.openxmlformats-officedocument.presentationml.presentation

|id
|pptx

|title
|PPTX Input Transformer

|description
|Default Input Transformer for the `application/vnd.openxmlformats-officedocument.presentationml.presentation` mime type.

|===

====== Implementation Details

This input transformer maps the metadata common across all mime types to applicable metacard attributes in the default MetacardType and adds a thumbnail of
the first page in the PPTX document.


===== Video Input Transformer
The video input transformer is responsible for creating Catalog metacards from certain video file types. Currently, it is responsible for handling MPEG-2 transport streams as well as MPEG-4, AVI, MOV, and WMV videos. This input transformer uses Apache Tika to extract basic metadata from the video files and applies more sophisticated methods to extract more meaningful metadata from these types of video.

====== Installing and Uninstalling
This transformer is installed by default. To install or uninstall manually, use the `video-input-transformer` feature in the Admin Console (${secure_url}/admin) under DDF Catalog -> Features or use the System Console.

====== Configuring
None

====== Using
Use the video input transformer for ingesting video files into the Catalog.

====== Service Properties
[cols="2,5a" options="header"]
|===
|Key
|Value

|mime-type
|* video/avi
* video/msvideo
* video/vnd.avi
* video/x-msvideo
* video/mp4
* video/MP2T
* video/mpeg
* video/quicktime
* video/wmv
* video/x-ms-wmv

|shortname
|video

|id
|video

|description
|Detects and extracts metadata from various video file formats.
|===

===== GeoJSON Input Transformer

The GeoJSON input transformer is responsible for translating specific GeoJSON into a Catalog metacard.

====== Installing and Uninstalling

Install the `catalog-rest-endpoint` feature using the \${secure_url}/admin.

====== Configuring

None

====== Using

Using the REST Endpoint, for example, HTTP POST a GeoJSON metacard to the Catalog.
Once the REST Endpoint receives the GeoJSON Metacard, it is converted to a Catalog metacard.

.Example HTTP POST of a local `metacard.json` file using the Curl Command
----
curl -X POST -i -H "Content-Type: application/json" -d "${at-symbol}metacard.json" ${secure_url}/services/catalog
----

====== Conversion

A http://geojson.org/geojson-spec.html#geojson-objects[GeoJSON object] consists of a single JSON object.
The single JSON object can be a geometry, a feature, or a FeatureCollection.
This input transformer only converts "feature" objects into metacards.
This is a natural choice since feature objects include geometry information and a list of properties.
For instance, if only a geometry object is passed, such as only a LineString, that is not enough information to create a metacard.
This input transformer currently does not handle FeatureCollections either, but could be supported in the future.

[IMPORTANT]
====
.Cannot create Metacard from this limited GeoJSON
[source,javascript,linenums]
----
{ "type": "LineString",
 "coordinates": [ [100.0, 0.0], [101.0, 1.0] ]
 }
----
====

The following sample _will_ create a valid metacard:

.Sample Parseable GeoJson (Point)
[source,javascript,linenums]
----
{
    "properties": {
        "title": "myTitle",
        "thumbnail": "CA==",
        "resource-uri": "http://example.com",
        "created": "2012-09-01T00:09:19.368+0000",
        "metadata-content-type-version": "myVersion",
        "metadata-content-type": "myType",
        "metadata": "<xml></xml>",
        "modified": "2012-09-01T00:09:19.368+0000"
    },
    "type": "Feature",
    "geometry": {
        "type": "Point",
        "coordinates": [
            30.0,
            10.0
        ]
    }
}
----

In the current implementation, `Metacard.LOCATION` is not taken from the properties list as WKT, but instead interpreted from the `geometry` JSON object.
The geometry object is formatted according to the http://geojson.org/geojson-spec.html[GeoJSON] standard.
Dates are in the ISO 8601 standard.
White space is ignored, as in most cases with JSON.
Binary data is accepted as Base64.
XML must be properly escaped, such as what is proper for normal JSON.

Only Required Attributes are recognized in the properties currently.

====== Metacard Extensibility

GeoJSON supports custom, extensible properties on the incoming GeoJSON using ${branding}'s extensible metacard support.
To have those customized attributes understood by the system, a corresponding `MetacardType` must be registered with the `MetacardTypeRegistry`.
That `MetacardType` must be specified by name in the metacard-type property of the incoming GeoJSON.
If a `MetacardType` is specified on the GeoJSON input, the customized properties can be processed, cataloged, and indexed.

[source,javascript,linenums]
----
{
    "properties": {
        "title": "myTitle",
        "thumbnail": "CA==",
        "resource-uri": "http://example.com",
        "created": "2012-09-01T00:09:19.368+0000",
        "metadata-content-type-version": "myVersion",
        "metadata-content-type": "myType",
        "metadata": "<xml></xml>",
        "modified": "2012-09-01T00:09:19.368+0000",
        "min-frequency": "10000000",
        "max-frequency": "20000000",
        "metacard-type": "${ddf-branding}.metacard.custom.type"
 },
    "type": "Feature",
    "geometry": {
        "type": "Point",
        "coordinates": [
            30.0,
            10.0
        ]
    }
}
----

When the GeoJSON Input Transformer gets GeoJSON with the `MetacardType` specified, it will perform a lookup in the `MetacardTypeRegistry` to obtain the specified `MetacardType` in order to understand how to parse the GeoJSON.
If no `MetacardType` is specified, the GeoJSON Input Transformer will assume the default `MetacardType`.
If an unregistered `MetacardType` is specified, an exception will be returned to the client indicating that the `MetacardType` was not found.

====== Package Details

_Feature Information_

N/A

_Included Bundles_

N/A

_Services_

_Exported Services_

.${ddf-branding}.catalog.transform.InputTransformer
[cols="2"]
|===

|mime-type
|application/json

|id
|geojson

|===

====== Implementation Details
.Exported Services
[cols="3"]
|===

|Registered Interface
|Service Property
|Value

|`${ddf-branding}.catalog.transform.InputTransformer`
|mime-type
|application/json

|
|id
|geojson

|===

====== Known Issues

Does not handle multiple geometries yet.

==== Developing an Input Transformer

===== Using Java

. Create a new Java class that implements ${ddf-branding}.catalog.transform.InputTransformer. +
`public class SampleInputTransformer implements ${ddf-branding}.catalog.transform.InputTransformer`
. Implement the transform methods. +
`public Metacard transform(InputStream input) throws IOException, CatalogTransformerException` +
`public Metacard transform(InputStream input, String id) throws IOException, CatalogTransformerException`
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.transform`
. Create an OSGi descriptor file to communicate with the OSGi Service Registry (described in the Working with OSGi section). Export the service to the OSGi Registry and declare service properties.

.Blueprint descriptor example
[source,xml,linenums]
----
...
<service ref="[[SampleInputTransformer]]" interface="${ddf-branding}.catalog.transform.InputTransformer">
    <service-properties>
        <entry key="shortname" value="[[sampletransform]]" />
        <entry key="title" value="[[Sample Input Transformer]]" />
        <entry key="description" value="[[A new transformer for metacard input.]]" />
    </service-properties>
</service>
...
----
. Deploy OSGi Bundle to OSGi runtime.

====== Variable Descriptions

.Blueprint Service Properties
[cols="1,3,2" options="header"]
|===

|Key
|Description of Value
|Example

|`shortname`
|(Required) An abbreviation for the return-type of the BinaryContent being sent to the user.
|_atom_

|`title`
|(Optional) A user-readable title that describes (in greater detail than the shortname) the service.
|_Atom Entry Transformer Service_

|`description`
|(Optional) A short, human-readable description that describes the functionality of the service and the output.
|_This service converts a single metacard xml document to an atom entry element._

|===

===== Create an XML Input Transformer using SaxEventHandlers [[saxEventHandlers]]

If the transformer will transform XML, (as opposed to JSON or a Word document, for example) there is a simpler solution than fully implementing a MetacardValidator.
DDF includes an extensible, configurable `XmlInputTransformer`. This transformer can be instantiated via blueprint as a managed service factory and configured via metatype.
The `XmlInputTransformer` takes a configuration of `SaxEventHandlers`.
A `SaxEventHandler` is a class that handles SAX Events (a very fast XML parser) to parse metadata and create metacards.
As many `SaxEventHandlers` as needed can be implemented and included in the `XmlInputTransformer` configuration. See the `catalog-transformer-streaming-impl` bundle for examples (`XmlSaxEventHandlerImpl` which parses the DDF Metacard XML Metadata and the `GmlHandler` which parses GML 2.0)
Each `SaxEventHandler` implementation has a `SaxEventHandlerFactory` associated with it.
The `SaxEventHandlerFactory` is responsible for instantiating new `SaxEventHandlers` - each transform request gets a new instance of `XmlInputTransformer` and set of `SaxEventHandlers` to be thread- and state-safe.

The following diagrams intend to clarify implementation details:

Figure 1 shows the XmlInputTransformer configuration, which is configured using the metatype and has the `SaxEventHandlerFactory` ids.
Then, when a transform request is received, the `ManagedServiceFactory` instantiates a new `XmlInputTransformer`.
This `XmlInputTransformer` then instantiates a new `SaxEventHandlerDelegate` with the configured `SaxEventHandlersFactory` ids.
The factories all in turn instantiate a `SaxEventHandler`.
Then, the `SaxEventHandlerDelegate` begins parsing the XML input document, handing the SAX Events off to each `SaxEventHandler`, which handle them if they can.
After parsing is finished, each `SaxEventHandler` returns a list of `Attributes` to the `SaxEventHandlerDelegate` and `XmlInputTransformer` which add the attributes to the metacard and then return the fully constructed metacard.

[ditaa, XmlInputTransformer_diagram1, png]
....
Fig. 1
XmlInputTransformer Configuration
|
|
--- String value of SaxEventHandlerFactory1 id
|
|
--- String value of SaxEventHandlerFactory2 id
....

[ditaa, XmlInputTransformer_diagram2, png]
....
Fig. 2
XmlInputTransformer
|
--- SaxEventHandlerDelegate
    |
    |
    --- SaxEventHandlerFactory1 -> SaxEventHandler1
    |
    |
    --- SaxEventHandlerFactory2 -> SaxEventHandler2
....

For more specific details, see the Javadoc for the `org.codice.ddf.transformer.xml.streaming.*` package.
Additionally, see the source code for the `org.codice.ddf.transformer.xml.streaming.impl.GmlHandler.java`, `org.codice.ddf.transformer.xml.streaming.impl.GmlHandlerFactory`, `org.codice.ddf.transformer.xml.streaming.impl.XmlInputTransformerImpl`, and `org.codice.ddf.transformer.xml.streaming.impl.XmlInputTransformerImplFactory`.

[NOTE]
====
1. The `XmlInputTransformer` & `SaxEventHandlerDelegate` create and configure themselves based on String matches of the configuration ids with the `SaxEventHandlerFactory` ids, so ensure these match.
2. The `XmlInputTransformer` uses a `DynamicMetacardType`.
This is pertinent because a metacards attributes are only stored in Solr if they are declared on the `MetacardType`.
Since the `DynamicMetacardType` is constructed dynamically, attributes are declared by the `SaxEventHandlerFactory` that parses them, as opposed to the `MetacardType`. See `org.codice.ddf.transformer.xml.streaming.impl.XmlSaxEventHandlerFactoryImpl.java` vs `ddf.catalog.data.impl.BasicTypes.java`
====

===== Create an Input Transformer Using Apache Camel
Alternatively, make an Apache Camel route in a blueprint file and deploy it using a feature file or via hot deploy.

===== Design Pattern

====== From

When using *from* `catalog:inputtransformer?id=text/xml`, an Input Transformer will be created and registered in the OSGi registry with an id of `text/xml`.

====== To

When using *to* `catalog:inputtransformer?id=text/xml`, an Input Transformer with an id matching text/xml will be discovered from the OSGi registry and invoked.

====== Message Formats

.InputTransformer
[cols="3,2,1" optiona="header"]
|===

|Exchange Type
|Field
|Type

|Request (comes from `<from>` in the route)
|body
|java.io.InputStream

|Response (returned after called via `<to>` in the route)
|body
|`${ddf-branding}.catalog.data.Metacard`

|===

====== Examples
.InputTransformer Creation
[source,xml,linenums]
----
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0">
    <camelContext xmlns="http://camel.apache.org/schema/blueprint">
        <route>
            <from uri="catalog:inputtransformer?mimeType=RAW(id=text/xml;id=vehicle)"/>
            <to uri="xslt:vehicle.xslt" /> <!-- must be on classpath for this bundle -->
            <to uri="catalog:inputtransformer?mimeType=RAW(id=application/json;id=geojson)" />
        </route>
    </camelContext>
</blueprint>
----

[TIP]
====
Its always a good idea to wrap the `mimeType` value with the RAW parameter as shown in the example above.
This will ensure that the value is taken exactly as is, and is especially useful when you are using special characters.
====

[cols="1,8" options="header"]
|===

|Line Number
|Description

|1
|Defines this as an Apache Aries blueprint file.

|2
|Defines the Apache Camel context that contains the route.

|3
|Defines start of an Apache Camel route.

|4
|Defines the endpoint/consumer for the route. In this case it is the ${branding} custom catalog component that is an InputTransformer registered with an id of text/xml;id=vehicle meaning it can transform an InputStream of vehicle data into a metacard.

*Note that the specified XSL stylesheet must be on the classpath of the bundle that this blueprint file is packaged in.*

|5
|Defines the XSLT to be used to transform the vehicle input into GeoJSON format using the Apache Camel provided XSLT component.

|6
Defines the route node that accepts GeoJSON formatted input and transforms it into a Mmtacard, using the ${branding} custom catalog component that is an InputTransformer registered with an id of application/json;id=geojson.
|===

[NOTE]
====
An example of using an Apache Camel route to define an `InputTransformer` in a blueprint file and deploying it as a bundle to an OSGi container can be found in the ${branding} SDK examples at `${ddf-branding}/sdk/sample-transformers/xslt-identity-input-transformer`
====

==== Included Metacard InputTransformers

A metacard transformer transforms a metacard into other data formats.

===== HTML Metacard Transformer
The HTML metacard transformer is responsible for translating a metacard into an HTML formatted document.

====== Installing and Uninstalling
Install the `catalog-transformer-html` feature using the Admin Console.

===== Configuring

None

===== Using

Using the REST Endpoint for example, request a metacard with the transform option set to the HTML shortname.
----
${public_url}/services/catalog/0123456789abcdef0123456789abcdef?transform=html
----

====== Example Output
----
html metacard.png
----

===== Implementation Details
[cols="3*" options="header"]
|===
|Registered Interface
|Service Property
|Value

1.3+^|`${ddf-branding}.catalog.transform.MetacardTransformer`
|title
|View as html...
|description
|Transforms query results into html
|shortname (for backwards compatibility)
|html

|===

===== Known Issues

None

==== XML Metacard Transformer
The XML metacard transformer is responsible for translating a metacard into an XML-formatted document.
The metacard element that is generated is an extension of `gml:AbstractFeatureType`, which makes the output of this transformer GML 3.1.1 compatible.

===== Installing and Uninstalling

This transformer comes installed out of the box and is running on startup.
To install or uninstall manually, use the `catalog-transformer-xml` feature.

===== Configuring

None

===== Using
Using the REST Endpoint for example, request a metacard with the transform option set to the XML shortname.
----
${secure_url}/services/catalog/ac0c6917d5ee45bfb3c2bf8cd2ebaa67?transform=xml
----

===== Implementation Details

====== Metacard to XML Mappings

[cols="2m" options="header"]
|===
|Metacard Variables
|XML Element

|id
|metacard/@gml:id

|metacardType
|metacard/type

|sourceId
|metacard/source

|all other attributes
|metacard/<AttributeType>[name='<AttributeName>']/value +
For instance, the value for the metacard attribute named "title" would be found at
metacard/string[@name='title']/value
|===

====== AttributeTypes

[cols="1*" options="header"]
|===
|XML Adapted Attributes
|boolean
|base64Binary
|dateTime
|double
|float
|geometry
|int
|long
|object
|short
|string
|stringxml
|===

===== Known Issues

None

==== GeoJSON Metacard Transformer

GeoJSON Metacard Transformer translates a Metacard into GeoJSON.

===== Installing and Uninstalling

Install the `catalog-transformer-json` feature.

===== Configuring

None

===== Using

The GeoJSON Metacard Transformer can be used programmatically by requesting a `MetacardTransformer` with the id `geojson`.
It can also be used within the REST Endpoint by providing the transform option as `geojson`.

.Example REST GET method with the GeoJSON MetacardTransformer
----
${public_url}/services/catalog/0123456789abcdef0123456789abcdef?transform=geojson
----

.Example Output
[source,javascript,linenums]
----
{
    "properties":{
        "title":"myTitle",
        "thumbnail":"CA==",
        "resource-uri":"http:\/\/example.com",
        "created":"2012-08-31T23:55:19.518+0000",
        "metadata-content-type-version":"myVersion",
        "metadata-content-type":"myType",
        "metadata":"<xml>text<\/xml>",
        "modified":"2012-08-31T23:55:19.518+0000",
        "metacard-type": "${ddf-branding}.metacard"
    },
    "type":"Feature",
    "geometry":{
        "type":"LineString",
        "coordinates":[
            [
                30.0,
                10.0
            ],
            [
                10.0,
                30.0
            ],
            [
                40.0,
                40.0
            ]
        ]
    }
}
----

===== Implementation Details

[cols="3*" options="header"]
|===
|Registered Interface
|Service Property
|Value

1.3+^|`${ddf-branding}.catalog.transform.MetacardTransformer`
|mime-type
|application/json

|id
|geojson

|shortname (for backwards compatibility)
|geojson

|===

==== Known Issues

None

==== Thumbnail Metacard Transformer

The Thumbnail Metacard Transformer retrieves the thumbnail bytes of a Metacard by returning the `Metacard.THUMBNAIL` attribute value.

===== Installing and Uninstalling

This transformer is installed out of the box.
To uninstall the transformer, you must stop or uninstall the bundle.

===== Configuring

None

===== Using

Endpoints or other components can retrieve an instance of the Thumbnail Metacard Transformer using its id `thumbnail`.

.Sample Blueprint Reference Snippet
[source,xml,linenums]
----
<reference id="metacardTransformer" interface="${ddf-branding}.catalog.transform.MetacardTransformer" filter="(id=thumbnail)"/>
----

The Thumbnail Metacard Transformer returns a `BinaryContent` object of the `Metacard.THUMBNAIL` bytes and a MIME Type of `image/jpeg`.

===== Implementation Details

[cols="2*" option="header"]
|===
|Service Property
|Value

|id
|thumbnail

|shortname
|thumbnail

|mime-type
|image/jpeg
|===

===== Known Issues

None

==== Metadata Metacard Transformer

The Metadata Metacard Transformer returns the `Metacard.METADATA` attribute when given a metacard.
The MIME Type returned is `text/xml`.

===== Installing and Uninstalling

Catalog Transformers application will install this feature when deployed.
This transformer's feature, `catalog-transformer-metadata`, can be uninstalled or installed.

===== Configuring

None

===== Using

The Metadata Metacard Transformer can be used programmatically by requesting a MetacardTransformer with the id metadata.
It can also be used within the REST Endpoint by providing the transform option as metadata.

.Example REST GET method with the Metadata MetacardTransformer
----
${public_url}/services/catalog/0123456789abcdef0123456789abcdef?transform=metadata
----

===== Implementation Details

[cols="3" options="header"]
|===
|Registered Interface
|Service Property
|Value

1.3+^|`${ddf-branding}.catalog.transform.MetacardTransformer`

|mime-type
|`text/xml`

|id
|metadata

|shortname (for backwards compatibility)
|metadata

|===

===== Known Issues

None.

==== Resource Metacard Transformer

The Resource Metacard Transformer retrieves the resource bytes of a metacard by returning the product associated with the metacard.

===== Installing and Uninstalling

This transformer is installed or uninstalled with the feature `catalog-transformer-resource`.

===== Configuring

None

===== Using

Endpoints or other components can retrieve an instance of the Resource Metacard Transformer using its id resource.

.Sample Blueprint Reference Snippet
[source,xml]
----
<reference id="metacardTransformer" interface="${ddf-branding}.catalog.transform.MetacardTransformer" filter="(id=resource)"/>
----

===== Implementation Details

[cols="3" options="header"]
|===
|Service Property
|Value

|id
|resource

|shortname
|resource

|mime-type
|application/octet-stream

|title
|Get Resource ...
|===

===== Known Issues

None

==== Developing a Metacard Transformer

In general, a `MetacardTransformer` is used to transform a `Metacard` into some desired format useful to the end user or as input to another process.
Programmatically, a `MetacardTransformer` transforms a `Metacard` into a `BinaryContent` instance, which contains the translated `Metacard` into the desired final format.
Metacard transformers can be used through the Catalog Framework `transform` convenience method or requested from the OSGi Service Registry by endpoints or other bundles.

===== Create a New Metacard Transformer
. Create a new Java class that implements `${ddf-branding}.catalog.transform.MetacardTransformer`. +
`public class SampleMetacardTransformer implements ${ddf-branding}.catalog.transform.MetacardTransformer`
. Implement the transform method. +
`public BinaryContent transform(Metacard metacard, Map<String, Serializable> arguments) throws CatalogTransformerException`
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog,${ddf-branding}.catalog.transform`
. Create an OSGi descriptor file to communicate with the OSGi Service registry (described in the Working with OSGi section). Export the service to the OSGi registry and declare service properties.

.Blueprint descriptor example
[source,xml,linenums]
----
...
<service ref="[[SampleMetacardTransformer]]" interface="${ddf-branding}.catalog.transform.MetacardTransformer">
    <service-properties>
        <entry key="shortname" value="[[sampletransform]]" />
        <entry key="title" value="[[Sample Metacard Transformer]]" />
        <entry key="description" value="[[A new transformer for metacards.]]" />
    </service-properties>
</service>
...
----

Deploy OSGi Bundle to OSGi runtime.

===== Variable Descriptions

.Blueprint Service properties
[cols="3" options="header"]
|===
|Key
|Description of Value
|Example

|`shortname`
|(Required) An abbreviation for the return type of the BinaryContent being sent to the user.
|atom

|`title`
|(Optional) A user-readable title that describes (in greater detail than the shortname) the service.
|Atom Entry Transformer Service

|`description`
|(Optional) A short, human-readable description that describes the functionality of the service and the output.
|This service converts a single metacard xml document to an atom entry element.

|===

==== Included Query Response Transformers

Query Response transformers convert query responses into other data formats.

===== Atom Query Response Transformer

The Atom Query Response Transformer transforms a query response into an http://tools.ietf.org/html/rfc4287[Atom 1.0] feed.
The Atom transformer maps a `QueryResponse` object as described in the Query Result Mapping.

===== Installing and Uninstalling

The Catalog Transformers application will install this feature when deployed. This transformer's feature, `catalog-transformer-atom`, can be uninstalled or installed.

===== Configuring

None.

===== Using

Use this transformer when Atom is the preferred medium of communicating information, such as for feed readers or federation.
An integrator could use this with an endpoint to transform query responses into an Atom feed.

For example, clients can use the https://tools.codice.org/#[OpenSearch Endpoint].
The client can query with the format option set to the shortname, atom.

.Sample OpenSearch query with Atom specified as return format
----
${public_url}/services/catalog/query?q=${ddf-branding}?format=atom
----

Developers could use this transformer to programmatically transform `QueryResponse` objects on the fly.

====== Sample Results

.Sample Atom Feed from `QueryResponse` object
[source,xml,linenums]
----
 <feed xmlns="http://www.w3.org/2005/Atom" xmlns:os="http://a9.com/-/spec/opensearch/1.1/">
    <title type="text">Query Response</title>
    <updated>2013-01-31T23:22:37.298Z</updated>
    <id>urn:uuid:a27352c9-f935-45f0-9b8c-5803095164bb</id>
    <link href="#" rel="self" />
    <author>
        <name>Lockheed Martin</name>
    </author>
    <generator version="2.1.0.20130129-1341">${ddf-branding}123</generator>
    <os:totalResults>1</os:totalResults>
    <os:itemsPerPage>10</os:itemsPerPage>
    <os:startIndex>1</os:startIndex>
    <entry xmlns:relevance="http://a9.com/-/opensearch/extensions/relevance/1.0/" xmlns:fs="http://a9.com/-/opensearch/extensions/federation/1.0/"
        xmlns:georss="http://www.georss.org/georss">
        <fs:resultSource fs:sourceId="${ddf-branding}123" />
        <relevance:score>0.19</relevance:score>
        <id>urn:catalog:id:ee7a161e01754b9db1872bfe39d1ea09</id>
        <title type="text">F-15 lands in Libya; Crew Picked Up</title>
        <updated>2013-01-31T23:22:31.648Z</updated>
        <published>2013-01-31T23:22:31.648Z</published>
        <link href="http://123.45.67.123:8181/services/catalog/${ddf-branding}123/ee7a161e01754b9db1872bfe39d1ea09" rel="alternate" title="View Complete Metacard" />
        <category term="Resource" />
        <georss:where xmlns:gml="http://www.opengis.net/gml">
            <gml:Point>
                <gml:pos>32.8751900768792 13.1874561309814</gml:pos>
            </gml:Point>
        </georss:where>
        <content type="application/xml">
            <ns3:metacard xmlns:ns3="urn:catalog:metacard" xmlns:ns2="http://www.w3.org/1999/xlink" xmlns:ns1="http://www.opengis.net/gml"
                xmlns:ns4="http://www.w3.org/2001/SMIL20/" xmlns:ns5="http://www.w3.org/2001/SMIL20/Language" ns1:id="4535c53fc8bc4404a1d32a5ce7a29585">
                <ns3:type>${ddf-branding}.metacard</ns3:type>
                <ns3:source>${ddf-branding}.distribution</ns3:source>
                <ns3:geometry name="location">
                    <ns3:value>
                        <ns1:Point>
                            <ns1:pos>32.8751900768792 13.1874561309814</ns1:pos>
                        </ns1:Point>
                    </ns3:value>
                </ns3:geometry>
                <ns3:dateTime name="created">
                    <ns3:value>2013-01-31T16:22:31.648-07:00</ns3:value>
                </ns3:dateTime>
                <ns3:dateTime name="modified">
                    <ns3:value>2013-01-31T16:22:31.648-07:00</ns3:value>
                </ns3:dateTime>
                <ns3:stringxml name="metadata">
                    <ns3:value>
                        <ns6:xml xmlns:ns6="urn:sample:namespace" xmlns="urn:sample:namespace">Example description.</ns6:xml>
                    </ns3:value>
                </ns3:stringxml>
                <ns3:string name="metadata-content-type-version">
                    <ns3:value>myVersion</ns3:value>
                </ns3:string>
                <ns3:string name="metadata-content-type">
                    <ns3:value>myType</ns3:value>
                </ns3:string>
                <ns3:string name="title">
                    <ns3:value>Example title</ns3:value>
                </ns3:string>
            </ns3:metacard>
        </content>
    </entry>
</feed>
----

====== Query Result Mapping
[cols="2,3a" options="header"]
|===

|XPath to Atom XML
|Value

|`/feed/title`
|"Query Response"

|`/feed/updated`
|ISO 8601 dateTime of when the feed was generated

|`/feed/id`
|Generated UUID URN (http://en.wikipedia.org/wiki/Universally_Unique_Identifier)

|`/feed/author/name`
|Platform Global Configuration organization

|`/feed/generator`
|Platform Global Configuration site name

|`/feed/generator/@version`
|Platform Global Configuration version

|`/feed/os:totalResults`
|SourceResponse Number of Hits

|`/feed/os:itemsPerPage`
|Request's Page Size

|`/feed/os:startIndex`
|Request's Start Index

|`/feed/entry/fs:resultSource/@fs:sourceId`
|Source Id from which the Result came. `Metacard.getSourceId()`

|`/feed/entry/relevance:score`
|Result's relevance score if applicable. `Result.getRelevanceScore()`

|`/feed/entry/id`
|`urn:catalog:id:<Metacard.ID>`

|`/feed/entry/title`
|`Metacard.TITLE`

|`/feed/entry/updated`
|ISO 8601 dateTime of `Metacard.MODIFIED`

|`/feed/entry/published`
|ISO 8601 dateTime of `Metacard.CREATED`

|`/feed/entry/link[@rel='related']`
|URL to retrieve underlying resource (if applicable and link is available)

|`/feed/entry/link[@rel='alternate']`
|Link to alternate view of the Metacard (if a link is available)

|`/feed/entry/category`
|`Metacard.CONTENT_TYPE`

|`/feed/entry//georss:where`
|GeoRSS GML of every Metacard attribute with format `AttributeFormat.GEOMETRY`

|`/feed/entry/content`
|Metacard XML generated by `${ddf-branding}.catalog.transform.MetacardTransformer` with `shortname=xml`.
If no transformer found, `/feed/entry/content/@type` will be text and `Metacard.ID` is displayed

.Sample Content with no Metacard Transformation
[source,xml]
----
<content type="text">4e1f38d1913b4e93ac622e6c1b258f89</content>
----
|===

===== XML Query Response Transformer

The XML Query Response Transformer is responsible for translating a query response into an XML formatted document.
The metacards element that is generated is an extension of `gml:AbstractFeatureCollectionType`, which makes the output of this transformer GML 3.1.1 compatible.

====== Installing and Uninstalling

This transformer comes installed out of the box and is running on start up. To uninstall or install manually, use the `catalog-transformer-xml` feature.

====== Configuring

None

====== Using

Using the OpenSearch Endpoint, for example, query with the format option set to the XML shortname `xml`.

[source,http]
----
${public_url}/services/catalog/query?q=input?format=xml
----

.Example Output
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns3:metacards xmlns:ns1="http://www.opengis.net/gml" xmlns:ns2="http://www.w3.org/1999/xlink" xmlns:ns3="urn:catalog:metacard" xmlns:ns4="http://www.w3.org/2001/SMIL20/" xmlns:ns5="http://www.w3.org/2001/SMIL20/Language">
    <ns3:metacard ns1:id="000ba4dd7d974e258845a84966d766eb">
        <ns3:type>${ddf-branding}.metacard</ns3:type>
        <ns3:source>southwestCatalog1</ns3:source>
        <ns3:dateTime name="created">
          <ns3:value>2013-04-10T15:30:05.702-07:00</ns3:value>
        </ns3:dateTime>
        <ns3:string name="title">
            <ns3:value>Input 1</ns3:value>
        </ns3:string>
    </ns3:metacard>
    <ns3:metacard ns1:id="00c0eb4ba9b74f8b988ef7060e18a6a7">
        <ns3:type>${ddf-branding}.metacard</ns3:type>
        <ns3:source>southwestCatalog1</ns3:source>
        <ns3:dateTime name="created">
          <ns3:value>2013-04-10T15:30:05.702-07:00</ns3:value>
        </ns3:dateTime>
        <ns3:string name="title">
            <ns3:value>Input 2</ns3:value>
        </ns3:string>
    </ns3:metacard>
</ns3:metacards>
----

====== Implementation Details
[cols="3" options="header"]
|===

|Registered Interface
|Service Property
|Value

1.3+^|`${ddf-branding}.catalog.transform.QueryResponseTransformer`

|`shortname`
|xml

|`description`
|Transforms query results into xml

|`title`
|View as XML...
|===

====== Known Issues

None

===== SearchUI

The SearchUI is a `QueryResponseTransformer` that not only provides results in html format but also provides a convenient, simple querying user interface.
It is primarily used as a test tool and verification of configuration.
The left pane of the SearchUI contains basic fields to query the Catalog and other Sources.
The right pane consists of the results returned from the query.

====== Installing and Uninstalling

Catalog Transformers App will install this feature when deployed.
This transformer's feature, `catalog-transformer-ui`, can be uninstalled or installed.

====== Configuring

In the Admin Console the SearchUI can be configured under the Catalog HTML Query Response Transformer.

.Configurable Properties
[cols="6" options="header"]
|===

|Title
|Property
|Type
|Description
|Default Value
|Required

|Header
|`header`
|String
|Specifies the header text to be rendered on the SearchUI
|
|yes

|Footer
|`footer`
|String
|Specifies the footer text to be rendered on the SearchUI
|
|yes

|Template
|`template`
|String
|Specifies the path to the Template
|/templates/searchpage.ftl
|`yes`

|Text Color
|`color`
|String
|Specifies the Text Color of the Header and Footer
|yellow
|yes

|Background Color
|`background`
|String
|Specifies the Background Color of the Header and Footer
|green
|yes

|===

===== Using

In order to obtain the SearchUI, a user must use the transformer with an endpoint that queries the Catalog such as the OpenSearch Endpoint.
If a distribution is running locally, \${secure_url}/search/simple should bring up the Simple Search UI.
After the page has loaded, enter the desired search criteria in the appropriate fields.
Then click the "Search" button in order to execute the search on the Catalog.

The "Clear" button will reset the query criteria specified.

====== Query Response Result Mapping
[cols="3" options="header"]
|===

|SearchUI Column Title
|Catalog Result
|Notes

|Title
|`Metacard.TITLE`
|The title may be hyperlinked to view the full Metacard

|Source
|`Metacard.getSourceId()`
|Source where the Metacard was discoved

|Location
|`Metacard.LOCATION`
|Geographical location of the Metacard

|Time
|`Metacard.CREATED or Metacard.EFFECTIVE`
|Time received/created

|Thumbnail
|`Metacard.THUMBNAIL`
|No column shown if no results have thumbnail

|Resource
|`Metacard.RESOURCE_URI`
|No column shown if no results have a resource

|===

====== Search Criteria

The SearchUI allows for querying a Catalog in the following methods:

* Keyword Search - searching with keywords using the grammar of the underlying endpoint/Catalog.
* Temporal Search - searching based on relative or absolute time.
* Spatial search - searching spatially with a Point-Radius or Bounding Box.
* Content Type Search - searching for specific `Metacard.CONTENT_TYPE` values

====== Known Issues

If the SearchUI results do not provide usable links on the metacard results, verify that a valid host has been entered in the Platform Global Configuration.

==== Developing a Query Response Transformer

A `QueryResponseTransformer` is used to transform a List of Results from a SourceResponse.
Query Response Transformers can be used through the Catalog `transform` convenience method or requested from the OSGi Service Registry by endpoints or other bundles.

==== Create a New Query Response Transformer

. Create a new Java class that implements `${ddf-branding}.catalog.transform.QueryResponseTransformer`. +
`public class SampleResponseTransformer implements ${ddf-branding}.catalog.transform.QueryResponseTransformer`
. Implement the transform method. +
`public BinaryContent transform(SourceResponse upstreamResponse, Map<String, Serializable> arguments) throws CatalogTransformerException`
. Import the ${branding} interface packages to the bundle manifest (in addition to any other required packages). +
`Import-Package: ${ddf-branding}.catalog, ${ddf-branding}.catalog.transform`
. Create an OSGi descriptor file to communicate with the OSGi Service Registry (described in the Working with OSGi section). Export the service to the OSGi registry and declare service properties.

.Blueprint descriptor example
[source,xml,linenums]
----
...
<service ref="[[SampleResponseTransformer]]" interface="${ddf-branding}.catalog.transform.QueryResponseTransformer">
    <service-properties>
        <entry key="shortname" value="[[sampletransform]]" />
        <entry key="title" value="[[Sample Response Transformer]]" />
        <entry key="description" value="[[A new transformer for response queues.]]" />
    </service-properties>
</service>
...
----
. Deploy OSGi Bundle to OSGi runtime.

==== Variable Descriptions

===== Blueprint Service properties

[cols="1,3,3" options="header"]
|===

|Key
|Description of Value
|Example

|`shortname`
|An abbreviation for the return-type of the BinaryContent being sent to the user.
|atom

|`title`
|A user-readable title that describes (in greater detail than the shortname) the service.
|Atom Entry Transformer Service

|`description`
|A short, human-readable description that describes the functionality of the service and the output.
|_This service converts a single metacard xml document to an atom entry element._

|===

==== XSLT Transformer

==== XSLT Transformer Framework

The XSLT Transformer Framework allows developers to create light-weight Query Response Transformers and Metacard Transformers using only a bundle header and XSLT files.
The XSLT Transformer Framework registers bundles, following the XSLT Transformer Framework bundle pattern, as new transformer services.
The `service-xslt-transformer` feature is part of the ${branding} core.

===== Examples

Examples of XSLT Transformers using the XSLT Transformer Framework include `service-atom-transformer` and `service-html-transformer`, found in the services folder of the source code trunk.

==== Developing an XSLT Transformer

The XSLT Transformer Framework allows developers to create light-weight Query Response Transformers using only a bundle header and XSLT files.
The XSLT Transformer Framework registers bundles, following the XSLT Transformer Framework bundle pattern, as new transformer services.
The `service-xslt-transformer` feature is part of the ${branding} core.

===== Examples

Examples of XSLT Transformers using the XSLT Transformer Framework include `service-atom-transformer` and `service-html-transformer`, found in the services folder of the source code trunk.

===== Implement an XSLT Transformer

. Create a new Maven project.
. Configure the POM to create a bundle using the Maven bundle plugin.
.. Add the transform output MIME type to the bundle headers.
. Add XSLT files.

===== Bundle POM Configuration

Configure the Maven project to create an OSGi bundle using the `maven-bundle-plugin`.
Change the ${branding}-Mime-Type to match the MIME type of the transformer output.

.Example POM file
[source,xml,linenums]
----
...
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.felix</groupId>
            <artifactId>maven-bundle-plugin</artifactId>
            <extensions>true</extensions>
            <configuration>
                <instructions>
                    <DDF-Mime-Type>[[Transform Result MIME Type]]</DDF-Mime-Type>
                    <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>
                    <Import-Package />
                    <Export-Package />
                </instructions>
            </configuration>
        </plugin>
    </plugins>
</build>
...
----

====== Including XSLT

The XSLT Transformer Framework will scan for XSLT files inside a bundle.
The XSLT file must have a `.xsl` or `.xslt` file in the correct directory location relative to the root of the bundle.
The path depends on if the XSLT will act as a Metacard Transformer, Query Response Transformer, or both.
The name of the XSLT file will be used as the transformer's shortname.

.XSLT File Bundle Path Patterns
[source,xml,linenums]
----
// Metacard Transformer
<bundle root>
    /OSGI-INF
        /${ddf-branding}
            /xslt-metacard-transformer
                /<transformer shortname>.[xsl|xslt]

// Query Response Transformer
<bundle root>
    /OSGI-INF
        /${ddf-branding}
            /xslt-response-queue-transformer
                /<transformer shortname>.[xsl|xslt]
----

The XSLT file has access to metacard or Query Reponse XML data, depending on which folder the XSLT file is located.
The Metacard XML format will depend on the metadata schema used by the Catalog Provider.

For Query Response XSLT Transformers, the available XML data for XSLT transform has the following structure:

.Query Response XML
[source,xml,linenums]
----
<results>
    <metacard>
        <id>[[Metacard ID]]</id>
        <score>[[Relevance score]]</score>
        <distance>[[Distance from query location]]</distance>
        <site>[[Source of result]]</site>
        <type qualifier="type">[[Type]]</type>
        <updated>[[Date last updated]]</updated>
        <geometry>[[WKT geometry]]</geometry>
        <document>
            [[Metacard XML]]
        </document>
    </metacard>
    ...
</results>
----

The XSLT file has access to additional parameters.
The `Map<String, Serializable>` arguments from the transform method parameters is merged with the available XSLT parameters.

* Query Response Transformers
** `grandTotal` - total result count
* Metacard Transformers
** `id` - metacard ID
** `siteName` - source ID
** `services` - list of displayable titles and URLs of available metacard transformers

====== RSS Example

. Create a Maven project named `service-rss-transformer`.
. Add the following to its POM file.

.Example RSS POM
[source,xml,linenums]
----
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <packaging>bundle</packaging>
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <artifactId>services</artifactId>
    <groupId>${ddf-branding}</groupId>
    <version>[[DDF release version]]</version>
  </parent>
  <groupId>${ddf-branding}.services</groupId>
  <artifactId>service-rss-transformer</artifactId>

  <build>
    <plugins>
      <plugin>
        <groupId>org.apache.felix</groupId>
        <artifactId>maven-bundle-plugin</artifactId>
        <extensions>true</extensions>
        <configuration>
          <instructions>
            <DDF-Mime-Type>application/rss+xml</DDF-Mime-Type>
            <Bundle-SymbolicName>${project.artifactId}</Bundle-SymbolicName>
            <Import-Package />
            <Export-Package />
          </instructions>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>
----

[cols="1,4" options="header"]
|===
|Line #
|Comment

|8
|Use the current release version.

|21
|Set the MIME type to the RSS MIME type.

|===

. Add `service-rss-transformer/src/main/resources/OSGI-INF/${ddf-branding}/xslt-response-queue-transformer/rss.xsl`.
The transformer will be a Query Response Transformer with the shortname `rss` based on the XSL filename and path.
. Add the following XSL to the new file.

.Example RSS XSLT
[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet version="2.0"
 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
 xmlns:gml="http://www.opengis.net/gml" exclude-result-prefixes="xsl gml">

  <xsl:output method="xml" version="1.0" indent="yes" />

  <xsl:param name="grandTotal" />
  <xsl:param name="url" />

  <xsl:template match="/">
    <xsl:apply-templates />
  </xsl:template>

  <xsl:template match="results">
    <rss version="2.0">
      <channel>
      <title>Query Results</title>
      <link><xsl:value-of select="$url" disable-output-escaping="yes" /></link>
      <description>Query Results of <xsl:value-of select="count(//metacard)" /> out of <xsl:value-of select="$grandTotal" /></description>
      <xsl:for-each select="metacard/document">
        <item>
          <guid>
            <xsl:value-of select="../id" />
          </guid>
          <title>
            <xsl:value-of select="Data/title" />
          </title>
          <link>
            <xsl:value-of select="substring-before($url,'/services')" /><xsl:text>/services/catalog/</xsl:text><xsl:value-of select="../id" /><xsl:text>?transform=html</xsl:text>
          </link>
          <description>
            <xsl:value-of select="//description" />
          </description>
          <author>
            <xsl:choose>
              <xsl:when test="Data/creator">
                <xsl:value-of select="Resource/creator//name" />
              </xsl:when>
              <xsl:when test="Data/publisher">
                <xsl:value-of select="Data/publisher//name" />
              </xsl:when>
              <xsl:when test="Data/unknown">
                <xsl:value-of select="Data/unknown//name" />
              </xsl:when>
            </xsl:choose>
          </author>
          <xsl:if test=".//@posted" >
            <pubDate>
              <xsl:value-of select=".//posted" />
            </pubDate>
          </xsl:if>
          </item>
        </xsl:for-each>
      </channel>
    </rss>
  </xsl:template>
</xsl:stylesheet>
----

[cols="1,4" options="header"]
|===

|Line #
|Comment

|8-9
|Example of using additional parameters and arguments.

|15
|Example of using the Query Response XML data.

|21,27
|Example of using the Metacard XML data.

|===

=== Extending Federation

Federation provides the capability to extend the ${branding} enterprise to include Remote Sources, which may include other instances of ${branding}. 
The Catalog handles all aspects of federated queries as they are sent to the Catalog Provider and Remote Sources, processed, and the query results are returned.
Queries can be scoped to include only the local Catalog Provider (and any Connected Sources), only specific Federated Sources, or the
entire enterprise (which includes all local and Remote Sources).
If the query is supposed to be federated, the Catalog Framework passes the query to a Federation Strategy, which is responsible for querying each federated source that is specified.
The Catalog Framework is also responsible for receiving the query results from each federated source and returning them to the client in the order specified by the particular federation strategy used.
After the federation strategy handles the results, the Catalog returns them to the client through the Endpoint.
Query results returned from a federated query are a list of metacards.
The source ID in each metacard identifies the Source from which the metacard originated.

The Catalog normalizes the incoming query into an OGC Filter format.
When the query is disseminated by the Catalog Framework to the sources, each source is responsible for denormalizing the OGC Filter formatted query into the format understood by the external store that the source is acting as a proxy.
This normalization/denormalization is what allows any endpoint to interface with any type of source.
For example, a query received by the OpenSearch Endpoint can be executed against an OpenSearch Source.

.Federation Architecture
[ditaa, catalog_architecture_federation, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |c369        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

.Federation
[ditaa, federation, png, ${image-width}]
....
           /------\
           |Client|
           |cDEF  |
           \------/
              ^
              |
+-------------|------------------------------------------------------------\
|DDF          |                                                       cCCC |
|             v                                                            |
|         /--------\   /-----------------\   /-------------------\         |
|         |Endpoint|<->|Catalog Framework|<->|Federation Strategy|         |
|         | cDEF   |   | cDEF            |   | cDEF              |         |
|         \--------/   \-----------------/   \-------------------/         |
|                                                     ^ ^                  |
|                                                     | |                  |
|                                          /----------/ \---------\        |
|                                          |                      |        |
| +----------------------------------------|----------------------|------+ |
| |Enterprise Query                        v                      v      | |
| |+--------------------------------------------+ +---------------------+| |
| ||Local Query                                 | |Federated Query      || |
| ||/------------------\ /---------------------\| |/-------------------\|| |
| ||| Catalog Provider | | Connected Source(s) || ||Federated Source(s)||| |
| |||  cDEF            | |  cDEF               || || cDEF              ||| |
| ||\------------------/ \---------------------/| |\-------------------/|| |
| |+-------^----------------------^-------------+ +----^----------^-----+| |
| +--------|----------------------|--------------------|----------|------+ |
\----------|----------------------|--------------------|----------|--------/
           |                      |                    |          \-------------------\
           |                      |                    |                              |
           v                      v                    v                              v
/=-------------------\ /----------------------\ /---------=------------\     /----------------------\
|  Oracle Database   | |       Source A       | |       Source B       | ... |       Source X       |
\--------------------/ \--------------------=-/ \----------------------/     \-------=--------------/
....

==== Federation Strategy

A federation strategy federates a query to all of the Remote Sources in the query's list, processes the results in a unique way, then returns the results to the client. 
For example, implementations can choose to block until all results return then perform a mass sort or return the results back to the client as soon as they are received back from a Federated Source.

===== Usage

An endpoint can optionally specify the federation strategy to use when it invokes the query operation.
Otherwise, the Catalog provides a default federation strategy that will be used.

===== Catalog Federation Strategy [[catalogFederationStrategy]]

The Catalog Federation Strategy is the default federation strategy and is based on sorting metacards by the sorting parameter specified in the federated query.

The possible sorting values are:

* metacard's effective date/time
* temporal data in the query result
* distance data in the query result
* relevance of the query result

The supported sorting orders are ascending and descending.

The default sorting value/order automatically used is relevance descending.

[WARNING]
====
The Catalog Federation Strategy expects the results returned from the Source to be sorted based on whatever sorting criteria were specified.
If a metadata record in the query results contains null values for the sorting criteria elements, the Catalog Federation Strategy expects that result to come at the end of the result list.
====

===== Configuration

The Catalog Federation Strategy configuration can be found in the admin console under *Configuration -> Catalog Federation Strategy*.

[cols="1,1,4a,1,1" options="header"]
|===

|Property
|Type
|Description
|Default Value
|Required

|`maxStartIndex`
|Integer
|The maximum query offset number (any number from 1 to unlimited). Setting the number too high would allow offset queries that could result in an out of memory error because the ${branding} will cycle through all records in memory. Things to consider when setting this value are:

* How much memory is allocated to the ${branding} Server
* How many sites are being federated with.

|50000
|yes

|`expirationIntervalInMinutes`
|Long
|Interval that Solr Cache checks for expired documents to remove.
|10
|yes

|`expirationAgeInMinutes`
|Long
|The number of minutes a document will remain in the cache before it will expire. Default is 7 days.
|10080
|yes

|`cachingEverything`
|Boolean
|Cache all results unless configured as native
|false
|yes

|===

[cols="2" options="header"]
|===

|Managed Service PID
|`${ddf-branding}.catalog.federation.impl.CachingFederationStrategy`

|Managed Service Factory PID
|N/A
|===

=== Extending Eventing

The Eventing capability of the Catalog allows endpoints (and thus external users) to create a "standing query" and be notified when a matching metacard is created, updated, or deleted.

Notably, the Catalog allows event evaluation on both the previous value (if available) and new value of a Metacard when an update occurs.

To better understand why this would be useful, suppose that there has been increased pirating activity off the coast of Somalia. 
Because of these events, a group of intelligence analysts is interested in determining the reason for the heightened activity and discovering its cause.
To do this, analysts need to monitor interesting events occurring in that area. 
Without ${branding} Eventing, the analysts would need to repeatedly query for any records of events or intelligence gathered in that area. 
Analysts would have to monitor changes or anything of interest. 
However, with ${branding} Eventing, the analysts can create a subscription indicating criteria for the types of intelligence of interest. 
In this scenario, analysts could specify interest in metacards added, updated, or deleted that describe data obtained around the coast of Somalia. 
Through this subscription, ${branding} will send event notifications back to the team of analysts containing metadata of interest. 
Furthermore, they could filter the records not only spatially, but by any other criteria that would zero in on the most interesting records. 
For example, a fishing company that has operated ships peacefully in the same region for a long time may not be interesting. 
To exclude metadata about that company, analysts may add contextual criteria indicating to return only records containing the keyword "pirate." 
With the subscription in place, analysts will only be notified of metadata related to the pirating activity, giving them better situational awareness.

The key components of ${branding} Eventing include:

* Subscription
* Delivery Method
* Event Processor

After reading this section, you will be able to:

* Create new subscriptions
* Register subscriptions
* Perform operations on event notification
* Remove a subscription

.Eventing Architecture
[ditaa, catalog_architecture_eventing, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |c369   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |cDEF   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Subscription

Subscriptions represent "standing queries" in the Catalog.
Like a query, subscriptions are based on the OGC Filter specification.

===== Subscription Lifecycle

====== Creation

* Subscriptions are created directly with the Event Processor or declaratively through use of the Whiteboard Design Pattern.
* The Event Processor will invoke each Pre-Subscription Plugin and, if the subscription is not rejected, the subscription will be activated.

====== Evaluation

* When a metacard matching the subscription is created, updated, or deleted in any Source, each Pre-Delivery Plugin will be invoked.

* If the delivery is not rejected, the associated Delivery Method callback will be invoked.

====== Update Evaluation

Notably, the Catalog allows event evaluation on both the previous value (if available) and new value of a Metacard when an update occurs.

====== Durability

Subscription durability is not provided by the Event Processor.
Thus, all subscriptions are transient and will not be recreated in the event of a system restart.
It is the responsibility of Endpoints using subscriptions to persist and re-establish the subscription on startup.
This decision was made for the sake of simplicity, flexibility, and the inability of the Event Processor to recreate a fully-configured Delivery Method without being overly restrictive.

[IMPORTANT]
====
*Subscriptions are not persisted by the Catalog itself.* +
Subscriptions must be explicitly persisted by an endpoint and are not persisted by the Catalog.
The Catalog Framework, or more specifically the Event Processor itself, does not persist subscriptions.
Certain endpoints, however, can persist the subscriptions on their own and recreate them on system startup.
====

====== Creating a Subscription

Currently, the Catalog reference implementation does not contain a subscription endpoint.
Nevertheless, an endpoint that exposes a web service interface to create, update, and delete subscriptions would provide a client's subscription's filtering criteria to be used by Catalog's Event Processor to determine which create, update, and delete events are of interest to the client.
The endpoint client also provides the callback URL of the event consumer to be called when an event matching the subscription's criteria is found.
This callback to the event consumer is made by a Delivery Method implementation that the client provides when the subscription is created. 
Whenever an event occurs in the Catalog matching the subscription, the Delivery Method implementation will be called by the Event Processor. 
The Delivery Method will, in turn, send the event notification out to the event consumer. 
As part of the subscription creation process, the Catalog verifies that the event consumer at the specified callback URL is available to receive callbacks.
Therefore, the client must ensure the event consumer is running prior to creating the subscription.
The Catalog completes the subscription creation by executing any pre-subscription Catalog Plugins, and then registering the subscription with the OSGi Service Registry.
The Catalog does not persist subscriptions by default.

===== Delivery Method

A Delivery Method provides the operation (created, updated, deleted) for how an event's metacard can be delivered.

A Delivery Method is associated with a subscription and contains the callback URL of the event consumer to be notified of events.
The Delivery Method encapsulates the operations to be invoked by the Event Processor when an event matches the criteria for the subscription.
The Delivery Method's operations are responsible for invoking the corresponding operations on the event consumer associated with the callback URL.

===== Event Processor

The Event Processor provides an engine that creates, updates, and deletes subscriptions for event notification.
These subscriptions optionally specify a filter criteria so that only events of interest to the subscriber are posted for notification.

An internal subscription tracker monitors the OSGi registry, looking for subscriptions to be added (or deleted).
When it detects a subscription being added, it informs the Event Processor, which sets up the subscription's filtering and is responsible for posting event notifications to the subscriber when events satisfying their criteria are met.

===== Event Processing and Notification

As metacards are created, updated, and deleted, the Catalog's Event Processor is invoked (as a post-ingest plugin) for each of these events.
TheEvent Processor applies the filter criteria for each registered subscription to each of these ingest events to determine if they match the criteria.
If an event matches a subscription's criteria, any pre-delivery plugins that are installed are invoked, the subscription's Delivery Method is retrieved, and its operation corresponding to the type of ingest event is invoked. 
For example, the DeliveryMethod's `created()` function is called when a metacard is created.
The Delivery Method's operations subsequently invoke the corresponding operation in the client's event consumer service, which is specified by the callback URL provided when the Delivery Method was created.

===== Standard Event Processor

The Standard Event Processor is an implementation of the Event Processor and provides the ability to create/delete subscriptions.
Events are generated by the ${ddf-catalog}Framework as metacards are created/updated/deleted and the Standard Event Processor is called since it is also a Post-Ingest Plugin.
The Standard Event Processor checks each event against each subscription's criteria.

When an event matches a subscription's criteria the Standard Event Processor:

* invokes each pre-delivery plugin on the metacard in the event
* invokes the Delivery Method's operation corresponding to the type of event being processed, e.g., created operation for the creation of a metacard

===== Installing and Uninstalling

The StandardEvent Processor is automatically installed/uninstalled when the 
Standard Catalog Framework is installed/uninstalled.

===== Known Issues

The Standard Event processor currently broadcasts federated events and should not.
It should only broadcast events that were generated locally, all other events should be dropped.

==== Fanout Event Processor

The Fanout Event Processor is used when ${branding} is configured as a fanout proxy.
The only difference between the Fanout Event Processor and the Standard Event Processor is that the source ID in the metacard of each event is overridden with the fanout's source ID.
This is done to hide the source names of the Remote Sources in the fanout's enterprise.
Otherwise, the Fanout Event Processor functions exactly like the Standard Event Processor. 

===== Installing and Uninstalling

The Fanout Event Processor is automatically installed/uninstalled when the Catalog Fanout Framework App is installed/uninstalled.

===== Known Issues

None

==== Working with Subscriptions

===== Creating a Subscription

====== Using ${branding} Implementation

If applicable, the implementation of `Subscription` that comes with ${branding} should be used.
It is available at `${ddf-branding}.catalog.event.impl.SubscriptionImpl` and offers a constructor that takes in all of the necessary objects.
Specifically, all that is needed is a `Filter`, `DeliveryMethod`, `Set<String>` of source IDs, and a `boolean` for enterprise.

The following is an example code stub showing how to create a new instance of Subscription using the ${branding} implementation. 

[source,java,linenums]
----
// Create a new filter using an imported FilterBuilder
Filter filter = filterBuilder.attribute(Metacard.ANY_TEXT).like().text("*");
 
// Create a implementation of Delivery Method
DeliveryMethod deliveryMethod = new MyCustomDeliveryMethod();
 
// Create a set of source ids
// This set is empty as the subscription is not specific to any sources
Set<String> sourceIds = new HashSet<String>();
 
// Set the isEnterprise boolean value
// This subscription example should notifications from all sources (not just local)
boolean isEnterprise = true;

Subscription subscription = new SubscriptionImpl(filter, deliveryMethod, sourceIds,isEnterprise);
----

====== Creating a Custom Implementation

To create a subscription in ${branding} the developer needs to implement the `${ddf-branding}.catalog.event.Subscription` interface. 
This interface extends `org.opengis.filter.Filter` in order to represent the subscription's filter criteria. 
Furthermore, the `Subscription` interface contains a `DeliveryMethod` implementation.  

When implementing `Subscription`, the developer will need to override the methods `accept` and `evaluate` from the `Filter`. 
The `accept` method allows the visitor pattern to be applied to the `Subscription`. 
A `FilterVisitor` can be passed into this method in order to process the `Subscription's Filter`.
In ${branding}, this method is used to convert the `Subscription's Filter` into a predicate format that is understood by the Event Processor. 
The second method inherited from `Filter` is `evaluate`. 
This method is used to evaluate an object against the `Filter`'s criteria in order to determine if it matches the criteria. 

[TIP]
====
The functionality of these overridden methods is typically delegated to the `Filter` implementation that the `Subscription` is using.
====

The developer must also define `getDeliveryMethod`. 
This class is called when the an event occurs that matches the filter of the subscription.

The other two methods required because `Subscription` implements `Federatable` are `isEnterprise` and `getSourceIds`, which indicate that the subscription should watch for events occurring on all sources in the enterprise or on specified sources. 

The following is an implementation stub of `Subscription` that comes with ${branding} and is available at `${ddf-branding}.catalog.event.impl.SubscriptionImpl`.

.SubscriptionImpl
[source,java,linenums]
----
public class SubscriptionImpl implements Subscription {
    private Filter filter;

    private DeliveryMethod dm;

    private Set<String> sourceIds;

    private boolean enterprise;

    public SubscriptionImpl(Filter filter, DeliveryMethod dm, Set<String> sourceIds,
            boolean enterprise) {
        this.filter = filter;
        this.dm = dm;
        this.sourceIds = sourceIds;
        this.enterprise = enterprise;
    }

    @Override
    public boolean evaluate(Object object) {
        return filter.evaluate(object);
    }

    @Override
    public Object accept(FilterVisitor visitor, Object extraData) {
        return filter.accept(visitor, extraData);
    }

    @Override
    public Set<String> getSourceIds() {
        return sourceIds;
    }

    @Override
    public boolean isEnterprise() {
        return enterprise;
    }

    @Override
    public DeliveryMethod getDeliveryMethod() {
        return dm;
    }
}
----

==== Registering a Subscription

Once a `Subscription` is created, it needs to be registered in the OSGi Service Registry as a `${ddf-branding}.catalog.event.Subscription` service. 
This is necessary for the `Subscription` to be discovered by the Event Processor. 
Typically, this is done in code after the `Subscription` is instantiated. 
When the `Subscription` is registered, a unique ID will need to be specified using the key `subscription-id`.
This will be used to delete the `Subscription` from the OSGi Service Registry. 
Furthermore, the `ServiceRegistration`, which is the return value from registering a `Subscription`, should be monitored in order to remove the `Subscription` later.
The following code shows how to correctly register a `Subscription` implementation in the registry using the above `SubscriptionImpl` for clarity:

.Registering a Subscription
[source,java,linenums]
----
// Map to keep track of registered Subscriptions.  Used for unregistering Subscriptions.
Map<String, ServiceRegistration<Subscription>> subscriptions = new HashMap<String, ServiceRegistration<Subscription>>();

// New subscription using the ${branding} Implementation of subscription
Subscription subscription = new SubscriptionImpl(filter, deliveryMethod, sourceIds,isEnterprise);

// Specify the subscription-id to uniquely identify the Subscription
String subscriptionId = "0123456789abcdef0123456789abcdef";
Dictionary<String, String> properties = new Hashtable<String, String>();
properties.put("subscription-id", subscriptionId);

// Service registration requires an instance of the OSGi bundle context
// Register subscription and keep track of the service registration
ServiceRegistration<Subscription> serviceRegistration = context.registerService(${ddf-branding}.catalog.event.Subscription.class, subscription, properties );
subscriptions.put(subscriptionId, serviceRegistration);
----

==== Creating a Delivery Method

The Event Processor obtains the subscription's `DeliveryMethod` and invokes one of its four methods when an event occurs. 
The `DeliveryMethod` then handles that invocation and communicates an event to a specified consumer service outside of ${branding}.

The Event Processor calls the `DeliveryMethod`'s`created` method when a new metacard matching the filter criteria is added to the Catalog. 
It calls the `deleted` method when a metacard that matched the filter criteria is removed from the Catalog. 
`updatedHit` is called when a metacard is updated and the new metacard matches the subscription. 
`updatedMiss` is different in that it is only called if the old metacard matched the filter but the new metacard no longer does. 
An example of this would be if the filter contains spatial criteria consisting of Arizona. 
If a plane is flying over Arizona, the Event Processor will repeatedly call `updatedHit` as the plane flies from one side to the other while updating its position in the Catalog.
This happens because the updated records continually match the specified criteria. 
If the plane crosses into New Mexico, the previous metacard will have matched the filter, but the new metacard will not. 
Thus, `updatedMiss` gets called.  

The following is an implementation stub for `DeliveryMethod`:

.DeliveryMethodImpl
[source,java,linenums]
----
public class DeliveryMethodImpl implements DeliveryMethod {

    @Override
    public void created(Metacard newMetacard) {
        // Perform custom code on create
    }

    @Override
    public void updatedHit(Metacard newMetacard, Metacard oldMetacard) {
		// Perform custom code on update (where both new and old metacards matched filter)
    }

    @Override
    public void updatedMiss(Metacard newMetacard, Metacard oldMetacard) {
		// Perform custom code on update (where one of the two metacards did not match the filter)
    }

    @Override
    public void deleted(Metacard oldMetacard) {
     // Perform custom code on delete
    }
}
----

==== Deleting a Subscription

To remove a subscription from ${branding}, the subscription ID is required.
Once this is provided, the `ServiceRegistration` for the indicated `Subscription` should be obtained from the `Subscriptions` Map.
Then the `Subscription` can be removed by unregistering the service.
The following code demonstrates how this is done:

.Delete Subscription
[source,java,linenums]
----
String subscriptionId = "0123456789abcdef0123456789abcdef";

//Obtain service registration from subscriptions Map based on subscription ID
ServiceRegistration<Subscription> sr = subscriptions.get(subscriptionId);

//Unregister Subscription from OSGi Service Registry
sr.unregister();

//Remove Subscription from Map keeping track of registered Subscriptions.
subscriptions.remove(subscriptionId);
----

=== Extending Resource Components

Resource components are used when working with resources, i.e., the data that is represented by the cataloged metadata.

A resource is a URI-addressable entity that is represented by a metacard. Resources may also be known as products or data.

Resources may exist either locally or on a remote data store.

Examples of resources include:

* NITF image
* MPEG video
* Live video stream
* Audio recording
* Document

A resource object in ${branding} contains an `InputStream` with the binary data of the resource. 
It describes that resource with a name, which could be a file name, URI, or another identifier. 
It also contains a mime type or content type that a client can use to interpret the binary data.  

.Resources Architecture
[ditaa, catalog_architecture_resources, png, ${image-width}]
....
+------------------------------------------------------------+
|                /-------------------\                       |
|                |cDEFEndpoints      |                       |
|                +------------+------+                       |
|                |cDEF        |cDEF  |                       |
|                | Operations | Data |                       |
|/---------------+------------+------+------------+---------\|
||cDEF           |cDEF               |cDEF        |cDEF     ||
||  Transformers |                   | Federation | Sources ||
|+---------------+ Catalog Framework +------------+---------+|
||cDEF           |                   |cDEF   Eventing       ||
||   Catalog     |                   +------------+---------+|
||   Plugins     |                   |c369   Resources      ||
|\---------------+-------------------+----------------------/|
|                |cDEF               |                       |
|                | Catalog Provider  |                       |
|                \-------------------/                       |
+------------------------------------------------------------+
....

==== Resource Readers

A resource reader retrieves resources associated with metacards via URIs.
Each resource reader must know how to interpret the resource's URI and how to interact with the data store to retrieve the resource.

There can be multiple resource readers in a Catalog instance.
The `Catalog Framework` selects the appropriate resource reader based on the scheme of the resource's URI. 

In order to make a resource reader available to the Catalog Framework, it must be exported to the OSGi Service Registry as a `${ddf-branding}.catalog.resource.ResourceReader`. 

===== URL Resource Reader

The `URLResourceReader` is an implementation of `ResourceReader` which is included in the ${branding} Catalog. 
It obtains a resource given an http, https, or file-based URL. 
The `URLResourceReader` will connect to the provided Resource URL and read the resource's bytes into an `InputStream`.  

[WARNING]
====
When a resource linked using a file-based URL is in the product cache, the `URLResourceReader`&#8217;s rootResourceDirectories is not checked when downloading the product.
It is downloaded from the product cache which bypasses the `URLResourceReader`.
For example, if path `/my/valid/path` is configured in the `URLResourceReader`&#8217;s rootResourceDirectories and one downloads the product with resource-uri `file:///my/valid/path/product.txt` and then one removes `/my/valid/path` from the `URLResourceReader`&#8217;s `rootResourceDirectories` configuration, the product will still be accessible via the product cache.
====

===== Installing and Uninstalling

`URLResourceReader` is installed by default with the ${branding} Catalog.

===== Configuring

====== Configurable Properties

_URL Resource Reader_

[cols="1,1,3,1,1", options="header"]
|===

|Property
|Type
|Description
|Default Value
|Required

|`rootResourceDirectories`
|String array
|Specifies the only directories the `URLResourceReader` has access to when attempting to download resources linked using file-based URLs (i.e. the metacard attribute resource-uri uses the file URI scheme). This property is used to restrict the `URLResourceReader`&#8217;s access to the file system. The `URLResourceReader` can be given full access to the file system by setting the `rootResourceDirectories` property to the root directory (e.g. `/`), but this configuration is not recommended.
|<${ddf-branding}.home>/data/products
|yes

|===

===== Using

`URLResourceReader` will be used by the Catalog Framework to obtain a resource whose metacard is cataloged in the local data store.
This particular `ResourceReader` will be chosen by the `CatalogFramework` if the requested resource's URL has a protocol of `http`, `https`, or `file`.  

For example, requesting a resource with the following URL will make the Catalog Framework invoke the `URLResourceReader` to retrieve the product.

.Example
[source,http]
----
file:///home/users/${ddf-branding}_user/data/example.txt
----

If a resource was requested with the URL `udp://123.45.67.89:80/SampleResourceStream`, the `URLResourceReader` would _not_ be invoked.

===== Implementation Details

Supported Schemes:

* http
* https
* file

[NOTE]
====
If a file-based URL is passed to the `URLResourceReader`, that file path needs to be accessible by the ${branding} instance.
====

===== Known Issues

None

==== Developing a Resource Reader

A `ResourceReader` is a class that retrieves a resource or product from a native/external source and returns it to ${branding}.
A simple example is that of a File `ResourceReader`.
It takes a file from the local file system and passes it back to ${branding}.
New implementations can be created in order to support obtaining Resources from various Resource data stores. 

===== Create a New ResourceReader

Complete the following procedure to create a `ResourceReader`.

. Create a Java class that implements the `${ddf-branding}.catalog.resource.ResourceReader` interface.
. Deploy the OSGi bundled packaged service to the ${branding} run-time.

===== Implementing the ResourceReader Interface

[source,java,linenums]
----
public class TestResourceReader implements ${ddf-branding}.catalog.resource.ResourceReader
----

`ResourceReader` has a couple of key methods where most of the work is performed.

[NOTE]
====
*URI* +
It is recommended to become familiar with the Java API URI class in order to properly build a `ResourceReader`. 
Furthermore, a URI should be used according to its http://www.w3.org/Addressing/URL/uri-spec.html[specification].
====

===== retrieveResource

[source,java,linenums]
----
public ResourceResponse retrieveResource( URI uri, Map<String, Serializable> arguments )throws IOException, ResourceNotFoundException, ResourceNotSupportedException;
----

This method is the main entry to the `ResourceReader`.
It is used to retrieve a `Resource` and send it back to the caller (generally the `CatalogFramework`).
Information needed to obtain the entry is contained in the `URI` reference.
The URI Scheme will need to match a scheme specified in the `getSupportedSchemes` method.
This is how the CatalogFramework determines which `ResourceReader` implementation to use. 
If there are multiple `ResourceReaders` supporting the same scheme, these `ResourceReaders` will be invoked iteratively. 
Invocation of the `ResourceReaders` stops once one of them returns a `Resource`.

Arguments are also passed in.
These can be used by the `ResourceReader` to perform additional operations on the resource.

An example of how `URLResourceReader` (located in the source code at `/trunk/${ddf-branding}/catalog/resource/URLResourceReader.java`) implements the `getResource` method.
This `ResourceReader` simply reads a file from a URI.

[NOTE]
====
The `Map<String, Serializable> arguments` parameter is passed in to support any options or additional information associated with retrieving the resource.
====

===== Implement `retrieveResource()`

. Define supported schemes (e.g., file, http, etc.).
. Check if the incoming URI matches a supported scheme. If it does not, throw `ResourceNotSupportedException`.

.Example:
[source,java,linenums]
----
if ( !uri.getScheme().equals("http") )
 {
   throw new ResourceNotSupportedException("Unsupported scheme received, was expecting http")
 }
----

. Implement the business logic.
. For example, the `URLResourceReader` will obtain the resource through a connection:

[source,java,linenums]
----
URL url = uri.toURL();
URLConnection conn = url.openConnection();
String mimeType = conn.getContentType();
if ( mimeType == null ) {
    mimeType = URLConnection.guessContentTypeFromName( url.getFile() );
}
InputStream is = conn.getInputStream();
----

[NOTE]
====
The `Resource` needs to be accessible from the ${branding} installation (see the rootResourceDirectories property of the `URLResourceReader`). 
This includes being able to find a file locally or reach out to a remote URI. 
This may require Internet access, and ${branding} may need to be configured to use a proxy (`http.proxyHost` and `http.proxyPort` can be added to the system properties on the command line script).
====

. Return `Resource` in `ResourceResponse`.

For example:
[source,java,linenums]
----
return ResourceResponseImpl( new ResourceImpl( new BufferedInputStream( is ), new MimeType( mimeType ), url.getFile() ) );
----

If the Resource cannot be found, throw a `ResourceNotFoundException`.  

===== `getSupportedSchemes`

[source,java]
----
public Set<String> getSupportedSchemes();
----

This method lets the `ResourceReader` inform the CatalogFramework about the type of URI scheme that it accepts and should be passed.
For single-use ResourceReaders (like a URLResourceReader), there may be only one scheme that it can accept while others may understand more than one.
A ResourceReader must, at minimum, accept one qualifier. 
As mentioned before, this method is used by the `CatalogFramework` to determine which `ResourceReader` to invoke. 

[NOTE]
====
*`ResourceReader` extends `Describable`* +
Additionally, there are other methods that are used to uniquely describe a `ResourceReader`.
 The `describe` methods are straight-forward and can be implemented with guidance from the Javadoc.
====

===== Export to OSGi Service Registry

In order for the `ResourceReader` to be used by the `CatalogFramework`, it should be exported to the OSGi Service Registry as a `${ddf-branding}.catalog.resource.ResourceReader`.

See the XML below for an example:

.Blueprint example
[source,xml,linenums]
----
<bean id="[[customResourceReaderId]]" class="[[example.resource.reader.impl.CustomResourceReader]]" />
<service ref="[[customResourceReaderId]]" interface="${ddf-branding}.catalog.source.ResourceReader" />
----

==== Resource Writers

A resource writer stores a resource and produces a URI that can be used to retrieve the resource at a later time.
The resource URI uniquely locates and identifies the resource.
Resource writers can interact with an underlying data store and store the resource in the proper place.
Each implementation can do this differently, providing flexibility in the data stores used to persist the resources.

===== Examples

The Catalog reference implementation currently does not include any resource writers out of the box.

==== Developing a Resource Writer

A `ResourceWriter` is an object used to store or delete a `Resource`. 
`ResourceWriter` objects should be registered within the OSGi Service Registry, so clients can retrieve an instance when clients need to store a `Resource`. 

===== Create a New `ResourceWriter`

Complete the following procedure to create a `ResourceWriter`.

. Create a Java class that implements the `${ddf-branding}.catalog.resource.ResourceWriter` interface.

.ResourceWriter Implementation Skeleton
[source,java,linenums]
----
import java.io.IOException;
import java.net.URI;
import java.util.Map;
import ${ddf-branding}.catalog.resource.Resource;
import ${ddf-branding}.catalog.resource.ResourceNotFoundException;
import ${ddf-branding}.catalog.resource.ResourceNotSupportedException;
import ${ddf-branding}.catalog.resource.ResourceWriter;

public class SampleResourceWriter implements ResourceWriter {

	@Override
	public void deleteResource(URI uri, Map<String, Object> arguments) throws ResourceNotFoundException, IOException {
	   // WRITE IMPLEMENTATION
	 }

	@Override
	public URI storeResource(Resource resource, Map<String, Object> arguments)throws ResourceNotSupportedException, IOException {
	   // WRITE IMPLEMENTATION
	   return null;
	}

	@Override
	public URI storeResource(Resource resource, String id, Map<String, Object> arguments) throws ResourceNotSupportedException, IOException {
	   // WRITE IMPLEMENTATION
	   return null;
	}

}
----
. Register the implementation as a Service in the OSGi Service Registry.

.Blueprint Service Registration Example
[source,xml,linenums]
----
...
<service ref="[[ResourceWriterReference]]" interface="${ddf-branding}.catalog.resource.ResourceWriter" />
...
----

. Deploy the OSGi bundled packaged service to the ${branding} run-time (Refer to the Working with OSGi - Bundles section.)

[TIP]
====
*ResourceWriter Javadoc* +
Refer to the ${ddf-catalog} API Javadoc for more information about the methods required for implementing the interface. 
====

==== Developing a Registry Client

Registry Clients create Federated Sources using the OSGi Configuration Admin.
Developers should reference an individual `Source`'s (Federated, Connected, or Catalog Provider) documentation for the Configuration properties (such as a Factory PID, addresses, intervals, etc) necessary to establish that `Source` in the framework. 

===== Example

.Creating a Source Configuration
[source,java,linenums]
----
org.osgi.service.cm.ConfigurationAdmin configurationAdmin = getConfigurationAdmin() ;
org.osgi.service.cm.Configuration currentConfiguration = configurationAdmin.createFactoryConfiguration(getFactoryPid(), null);
Dictionary properties = new Dictionary() ;
properties.put(QUERY_ADDRESS_PROPERTY,queryAddress);
currentConfiguration.update( properties );
----

Note that the `QUERY_ADDRESS_PROPERTY` is specific to this Configuration and might not be required for every `Source`.
The properties necessary for creating a Configuration are different for every `Source`. 

==== Working with Resources

===== Metacards and Resources

Metacards are used to describe a resource through metadata. 
This metadata includes the time the resource was created, the location where the resource was created, etc. 
A ${branding} `Metacard` contains the `getResourceUri` method, which is used to locate and retrieve its corresponding resource.

===== Retrieve Resource

When a client attempts to retrieve a resource, it must provide a metacard ID or URI corresponding to a unique resource. 
As mentioned above, the resource URI is obtained from a `Metacard`'s `getResourceUri` method. 
The `CatalogFramework` has three methods that can be used by clients to obtain a resource: `getEnterpriseResource`, `getResource`, and `getLocalResource`.
The `getEnterpriseResource` method invokes the `retrieveResource` method on a local `ResourceReader` as well as all the `Federated` and `Connected` Sources inthe ${branding} enterprise. 
The second method, `getResource`, takes in a source ID as a parameter and only invokes `retrieveResource` on the specified `Source`. 
The third method invokes `retrieveResource` on a local `ResourceReader`. 

The parameter for each of these methods in the `CatalogFramework` is a 	`ResourceRequest`. 
${branding} includes two implementations of `ResourceRequest`: `ResourceRequestById` and `ResourceRequestByProductUri`. 
Since these implementations extend `OperationImpl`, they can pass a `Map` of generic properties through the `CatalogFramework` to customize how the resource request is carried out. 
One example of this is explained in the Options section below. 
The following is a basic example of how to create a `ResourceRequest` and invoke the `CatalogFramework` resource retrieval methods to process the request.   

.Retrieve Resource Example
[source,java,linenums]
----
Map<String, Serializable> properties = new HashMap<String, Serializable>();
properties.put("PropertyKey1", "propertyA"); //properties to customize Resource retrieval
ResourceRequestById resourceRequest = new ResourceRequestById("0123456789abcdef0123456789abcdef", properties); //object containing ID of Resource to be retrieved
String sourceName = "LOCAL_SOURCE"; //the Source ID or name of the local Catalog or a Federated Source
ResourceResponse resourceResponse; //object containing the retrieved Resource and the request that was made to get it.
resourceResponse = catalogFramework.getResource(resourceRequest, sourceName); //Source-based retrieve Resource request
Resource resource = resourceResponse.getResource(); //actual Resource object containing InputStream, mime type, and Resource name
----

`${ddf-branding}.catalog.resource.ResourceReader` instances can be discovered via the OSGi Service Registry.
The system can contain multiple `ResourceReaders`. 
The `CatalogFramework` determines which one to call based on the scheme of the resource's URI and what schemes the `ResourceReader` supports. 
The supported schemes are obtained by a `ResourceReader`'s `getSupportedSchemes` method. 
As an example, one `ResourceReader` may know how to handle file-based URIs with the scheme 	`file`, whereas another `ResourceReader` may support HTTP-based URIs with the scheme `http`.

The `ResourceReader` or `Source` is responsible for locating the resource, reading its bytes, adding the binary data to a `Resource` implementation, then returning that `Resource` in a `ResourceResponse`. 
The `ResourceReader` or `Source` is also responsible for determining the `Resource`'s name and mime type, which it sends back in the `Resource` implementation.  
 

===== Options

Options can be specified on a retrieve resource request made through any of the supporting endpoint. 
To specify an option for a retrieve resource request, the endpoint needs to first instantiate a `ResourceRequestByProductUri` or a `ResourceRequestById`. 
Both of these `ResourceRequest` implementations allow a `Map` of properties to be specified. 
Put the specified option into the `Map` under the key `RESOURCE_OPTION`.  

.Retrieve Resource with Options
[source,java,linenums]
----
Map<String, Serializable> properties = new HashMap<String, Serializable>();
properties.put("RESOURCE_OPTION", "OptionA");
ResourceRequestById resourceRequest = new ResourceRequestById("0123456789abcdef0123456789abcdef", properties);
----

Depending on the support that the `ResourceReader` or `Source` provides for options, the `properties``Map` will be checked for the `RESOURCE_OPTION` entry. 
If that entry is found, the option will be handled; however, the `ResourceReader` or `Source` supports options. 
If the `ResourceReader` or `Source` does not support options, that entry will be ignored.

A new `ResourceReader` or `Source` implementation can be created to support options in a way that is most appropriate. 
Since the option is passed through the catalog framework as a property, the `ResourceReader` or `Source` will have access to that option as long as the endpoint supports options.       

===== Store Resource

Resources are saved using a `ResourceWriter`. 
`${ddf-branding}.catalog.resource.ResourceWriter` instances can be discovered via the OSGi Service Registry.
Once retrieved, the `ResourceWriter` instance provides clients a way to store resources and get a corresponding URI that can be used to subsequently retrieve the resource via a `ResourceReader`. 
Simply invoke either of the `storeResource` methods with a resource and any potential arguments.
 
The `ResourceWriter` implementation is responsible for determining where the resource is saved and how it is saved. 
This allows flexibility for a resource to be saved in any one of  a variety of data stores or file systems. 
The following is an example of how to use a generic implementation of `ResourceWriter`.

[source,java,linenums]
----
InputStream inputStream = <Video_Input_Stream>; //InputStream of raw Resource data
MimeType mimeType = new MimeType("video/mpeg"); //Mime Type or content type of Resource
String name = "Facility_Video";  //Descriptive Resource name
Resource resource = new ResourceImpl(inputStream, mimeType, name);
Map<String, Object> optionalArguments = new HashMap<String, Object>();
ResourceWriter writer = new ResourceWriterImpl();
URI resourceUri; //URI that can be used to retrieve Resource
resourceUri = writer.storeResource(resource, optionalArguments); //Null can be passed in here
----

===== BinaryContent

`BinaryContent` is an object used as a container to store translated or transformed ${branding} components. 
`Resource` extends `BinaryContent` andincludes a `getName` method.  `
BinaryContent` has methods to get the `InputStream`, `byte` array, MIME type, and size of the represented binary data.
An implementation of `BinaryContent` (`BinaryContentImpl`) can be found in the Catalog API in the `${ddf-branding}.catalog.data` package.

====== Additional Information

* URI on Wikipedia (http://en.wikipedia.org/wiki/Uniform_resource_identifier)
* URI Javadoc (http://docs.oracle.com/javase/6/docs/api/java/net/URI.html)
