
== ${branding} Development Guidelines

[NOTE]
====
Development requires full knowledge of the ${branding} Catalog.
====

${branding} is written in Java and requires a moderate amount of experience with the Java programming language, along with Java terminology, such as packages, methods, classes, and interfaces.
${branding} uses a small OSGi runtime to deploy components and applications.
Before developing for ${branding}, it is necessary that developers have general knowledge on OSGi and the concepts used within.
This includes, but is not limited to, Catalog Commands and the following topics:

* The Service Registry
** How services are registered
** How to retrieve service references
* Bundles
** Their role in OSGi
** How they are developed

Documentation on OSGi can be viewed at the http://www.osgi.org[OSGi Alliance website].
Helpful literature for beginners includes _OSGi and Apache Felix 3.0 Beginner's Guide_ by Walid Joseph Gédéon and _OSGi in Action: Creating Modular Applications in Java_ by Richard Hall, Karl Pauls, Stuart McCulloch, and David Savage.

=== Recommended Hardware

Because of its modular nature, ${branding} may require a few or many system resources, depending on which bundles and features are deployed.
In general, ${branding} will take advantage of available memory and processors.
A 64-bit JVM is required, and a typical installation is performed on a single machine with 16GB of memory and eight processor cores.

The ${branding} source code is not tied to any particular IDE.
However, if a developer is interested in setting up the Eclipse IDE, they can view the http://books.sonatype.com/m2eclipse-book/reference/[Sonatype guide] on developing with Eclipse.

==== Getting Set Up

To develop on ${branding}, access to the source code via Github is required.

===== Integrated Development Environments (IDE)

The ${branding} source code is not tied to any particular IDE.
However, if a developer is interested in setting up the Eclipse IDE, they can view the http://books.sonatype.com/m2eclipse-book/reference/[Sonatype guide] on developing with Eclipse.

==== Formatting Source Code

A code formatter for the Eclipse IDE that can be used across all ${branding} projects will allow developers to format code similarly and minimize merge issues in the future.

${branding} uses an updated version of the http://servicemix.apache.org/developers/building.html[Apache ServiceMix Code Formatter] for code formatting.

===== Load the Code Formatter Into the Eclipse IDE

. Download the https://github.com/codice/ddf-support/blob/master/support-checkstyle/src/main/resources/ddf-eclipse-code-formatter.xml[Eclipse Code Formatter].
. In Eclipse, select *Window → Preferences*. The Preferences window opens.
. Select *Java → Code Style → Formatter*.
. Select the *Edit...* button and then Select the downloaded file.
. Select the *OK* button.

===== Load the Code Formatter Into IntelliJ IDEA

IntelliJ IDEA 13 is capable of importing Eclipse's Code Formatter directly from within IntelliJ without the use of any plugins.

. Download the https://github.com/codice/ddf-support/blob/master/support-checkstyle/src/main/resources/ddf-intellij-code-formatter.jar[IntelliJ Code Formatter].
. Open *IntelliJ* IDEA.
. Select *File → Settings → Code Style → Java*.
. Select *Manage*.
. Select the *Import* button and select the file.

===== Format Your Source Code Using Eclipse

A developer may write code and format it before saving.

. Before the file is saved, highlight all of the source code in the IDE editor window.
. Right-click on the highlighted code.
. Select *Source → Format*. The code formatter is applied to the source code and the file can be saved.

====== Set Up Save Actions in Eclipse

A developer can also set up Save Actions to format the source code automatically.

. Open Eclipse.
. Select *Window → Preferences* (*Eclipse → Preferences* on Mac). The Preferences window opens.
. Select *Java → Editor → Save Actions*.
. Select *Perform the selected actions on save*.
. Select *Format source code*.
. Select *Format all lines* or *Format edited lines*, as necessary.
. Optionally, select *Organize imports* (recommended).
. Select the *Apply* button.
. Select the *OK* button.

===== Format Source Code Using IntelliJ

In the toolbar, select *Code → Reformat Code* or use the keyboard shortcut `Ctrl-Alt-L`.

==== ${branding} Software Versioning

${branding} follows the https://www.osgi.org/wp-content/uploads/SemanticVersioning.pdf[Semantic Versioning White Paper] for bundle versioning.

==== Ensuring Compatibility

===== Compatibility Goals

The ${branding} framework, like all software, will mature over time.
Changes will be made to improve efficiency, add features, and fix bugs.
To ensure that components built for ${branding} and its sub-frameworks are compatible, developers must use caution when establishing dependencies from developed components.

===== Guidelines for Maintaining Compatibility

====== ${branding} Framework

For components written at the ${branding} Framework level (see Developing at the Framework Level), adhere to the following specifications:

[cols="2,1,5" options="header"]
|===

|Standard/Specification
|Version
|Current Implementation (subject to change)

|OSGi Framework
|4.2
|Apache Karaf 2.x +
Eclipse Equinox

|OSGi Enterprise Specification
|4.2
|Apache Aries (Blueprint) +
Apache Felix `FileInstall` and `ConfigurationAdmin`
|===

[IMPORTANT]
====
Avoid developing dependencies on the implementations directly, as compatibility in future releases is not guaranteed.
====

==== ${branding} Catalog API

For components written for the ${branding} Catalog (see Developing Catalog Components), only dependencies on the current major version of the Catalog API should be used.
Detailed documentation of the Catalog API can be found in the Catalog API Javadocs.

[cols="1,1,5"]
|===

|Dependency
|Version Interval
|Notes

|${branding} Catalog API
|[2.0, 3.0)
|Major version will be incremented (to 3.0) if/when compatibility is broken with the 2.x API.

|===

=== Development Recommendations

==== Javascript

Avoid using `console.log`

==== Package Names

Use singular package names.

==== Author Tags

Author tags are discouraged from being placed in the source code, as they can be a barrier to collaboration and have potential legal ramifications.

==== Unit Testing

All code should contain unit tests that are able to test out any localized functionality within that class.
When working with OSGi, code may have references to various services and other areas that are not available at compile-time.
One way to work around the issue of these external dependencies is to use a mocking framework.

.Recommended Framework
[NOTE]
====
The recommended framework to use with ${branding} is https://github.com/mockito/mockito[Mockito].
This test-level dependency is managed by the ${branding-lowercase} pom and is used to standardize the version being used across ${branding}.
====

==== Logging

There are many logging frameworks available for Java.

.Recommended Framework
[NOTE]
====
To maintain the best compatibility, the recommended logging framework is Simple Logging Facade for Java (SLF4J) (http://www.slf4j.org/), specifically the slf4j-api.
SLF4J allows a very robust logging API while letting the backend implementation be switched out seamlessly.
Additionally, it is compatible with pax logging and natively implemented by logback.
====

${branding} code uses the first five SLF4J log levels:

. trace (the least serious)
. debug
. info
. warn
. error (the most serious)

Examples:
[source,java,linenums]
----
//Check if trace is enabled before executing expense XML processing
if (LOGGER.isTraceEnabled()) {
      LOGGER.trace("XML returned: {}", XMLUtils.toString(xml));
}
//It is not necessary to wrap with LOGGER.isTraceEnabled() since slf4j will not construct the String unless
//trace level is enabled
LOGGER.trace("Executing search: {}", search);
----

.Architecture Diagram
[ditaa,architecture_diagram_white_box,png]
----
+-----------------------------------------------------------------------------------------------------------------------+
|                        /----------------------\  /-------------------\             /-------------------\              |
|      Components        |         New          |  |    New Security   |             |       New         |              |
|                        |   Catalog Components |  |     Components    |             |  App Components   |              |
|                        \----------------------/  \-------------------/             \-------------------/              |
|                      /-=------------------------------------------------\                                             |
|                      | /----------------------\  /-------------------\  |          /-------------------\              |
|   DDF Applications   | |cDEF  DDF Catalog     |  |cDEFDDF Security   |  |          |  New Application  |              |
|                      | |                      |  |                   |  |          \-------------------/              |
|                      | \----------------------/  \-------------------/  \-------------------------------------------\ |
| /--------------------/ /------------------------------------------------------------------------------------------\ | |
| |       DDF            |cDEF                              DDF Framework                                           | | |
| \--------------------\ |                                                                                          | | |
|                      | |                        includes Apache Karaf, Apache CXF,                                | | |
|                      | |                           Eclipse Equinox OSGi Container                                 | | |
|                      | \------------------------------------------------------------------------------------------/ | |
|                      \----------------------------------------------------------------------------------------------/ |
|                      /----------------------------------------------------------------------------------------------\ |
|         JVM          |cEEE                                Sun Java JDK                                              | |
|                      \----------------------------------------------------------------------------------------------/ |
|                      /---------------------\/---------------------\/------------------\/----------------------------\ |
|   Operating System   |cEEE     Windows     ||cEEE     Linux       ||cEEEMac OS X      ||cEEE       Solaris          | |
|                      \---------------------/\---------------------/\------------------/\----------------------------/ |
|                      /------------------------------------------------------------------------------\/--------------\ |
|       Hardware       |cEEE                       x86                                                ||cEEE SPARC    | |
|                      \------------------------------------------------------------------------------/\--------------/ |
+-----------------------------------------------------------------------------------------------------------------------+
----

As depicted in the architectural diagram above, ${branding} runs on top of an OSGi framework, a Java virtual machine (JVM), several choices of operating systems, and the physical hardware infrastructure.
The items within the dotted line represent the ${branding} out-of-the-box.

${branding} is a customized and branded distribution of http://karaf.apache.org/[Apache Karaf].
${branding} could also be considered to be a more lightweight OSGi distribution, as compared to Apache ServiceMix, FUSE ESB, or Talend ESB, all of which are also built upon Apache Karaf.
Similar to its peers, ${branding} incorporates additional upstream dependencies (https://tools.codice.org/#DDFArchitecture-AdditionalUpstreamDependencies).

${branding} as a framework hosts ${branding} applications, which are extensible by adding components via OSGi.
The best example of this is the ${branding} Catalog (API), which offers extensibility via several types of Catalog Components.
The ${branding} Catalog API serves as the foundation for several applications and resides in the applications tier.

The Catalog Components consist of Endpoints, Plugins, Catalog Frameworks, Sources, and Catalog Providers.
Customized components can be added to ${branding}.

==== Nomenclature

Capability:: A general term used to refer to an ability of the system
Application:: One or more features that together form a cohesive collection of capabilities
Component:: Represents a portion of an Application that can be extended
Bundle:: Java Archives (JARs) with special OSGi manifest entries.
Feature:: One or more bundles that form an installable unit;  Defined by Apache Karaf but portable to other OSGi containers.

==== OSGi Core

${branding} makes use of OSGi v4.2 to provide several capabilities:

* Has a Microkernel-based foundation, which is lightweight due to its origin in embedded systems.
* Enables integrators to easily customize components to run on their system.
* Software applications are deployed as OSGi components, or bundles.
Bundles are modules that can be deployed into the OSGi container (Eclipse Equinox OSGi Framework by default).
* Bundles provide flexibility allowing integrators to choose the bundles that meet their mission needs.
* Bundles provide reusable modules that can be dropped in any container.
* Provides modularity, module-based security, and low-level services, such as  Hypertext Transfer Protocol (HTTP), logging, events (basic publish/subscribe), and dependency injection.
* Implements a dynamic component model that allows application updates without downtime.
Components can be added or updated in a running system.
* Standardized Application Configuration (ConfigurationAdmin and MetaType)

OSGi is not an acronym, but if more context is desired the name Open Specifications Group Initiative has been suggested.

More information on OSGi is available at http://www.osgi.org/.

==== Built on Apache Karaf

Apache Karaf is a FOSS product that includes an OSGi framework and adds extra functionality, including:

${admin-console}:: Useful for configuring applications, installing/uninstalling features, and viewing services such as metrics.
${command-console}:: Provides command line administration of the OSGi container. All functionality in the ${command-console} can also be performed via this command line console.
Logging:: Provides centralized logging to `data/log/${branding-lowercase}.log`. Security logging is provided at `data/log/security.log`. Ingest error logging can be viewed in `data/log/ingest_error.log`.
Provisioning:: Of libraries or applications.
Security:: Provides a security framework based on Java Authentication and Authorization Service (JAAS).
Deployer:: Provides hot deployment of new bundles by dropping them into the `<INSTALL_DIR>/deploy` directory.
Blueprint:: Provides an implementation of the OSGi Blueprint Container specification that defines a dependency injection framework for dealing with dynamic configuration of OSGi services.
** ${branding} uses the Apache Aries implementation of Blueprint.
More information can be found at http://aries.apache.org/modules/blueprint.htm[Blueprint].
Spring DM:: An alternative dependency injection framework.
${branding} is not dependent on specific dependency injection framework, but Blueprint is recommended.

==== Additional Upstream Dependencies

${branding} is a customized distribution of Apache Karaf, and therefore includes all the capabilities of Apache Karaf.
${branding} also includes additional FOSS components to provide a richer set of capabilities.
Integrated components include their own dependencies, but at the platform level, ${branding} includes the following upstream dependencies:

Apache CXF:: Apache CXF is an open source services framework. CXF helps build and develop services using front end programming APIs, such as JAX-WS and JAX-RS. More information can be found at http://cxf.apache.org.
Apache Commons:: Provides a set of reusable Java components that extends functionality beyond that provided by the standard JDK  (More info available at http://commons.apache.org)
OSGeo GeoTools:: Provides spatial object model and fundamental geometric functions, which are used by ${branding} spatial criteria searches. More information can be found at http://geotools.org/.
Joda Time:: Provides an enhanced, easier to use version of Java date and time classes.
More information can be found at http://joda-time.sourceforge.net.

For a full list of dependencies, refer to the <<_dependency_list,Dependency List>>.

=== OSGi Services

Services consist of:

An API Bundle:: The API, written as Java interfaces, defines the contract of the service and should, to the extent possible, reference only those concrete classes that are loaded by the root classloader.
These classes being in the `java.\*` packages.
These exceptions to the `java.*` rule can be made:

* Extra interfaces can be declared by the API and used as input parameters and return values from API methods.

* Because of their complexity and relative permanence, generated JAXB classes can be exported from an API bundle for use by its consumers.

At least one implementation bundle:: As the intent of loosely coupled services is to allow a variety of implementations to be deployed into the container, it is common for there to be more than one concrete implementation of a service. However, that is not a requirement. A single implementation can suffice. It should include a `blueprint.xml` associating the implementation class(es) with interface(s), providing any other wiring of beans, services, and metadata necessary, and registering with the container.

==== Dependency Injection Frameworks

${branding} uses resource injection to retrieve and register services to the OSGi registry.
There are many resource injection frameworks that are used to complete these operations.
Blueprint and Spring DM are both used by ${branding}.

[NOTE]
====
It is recommended to use Blueprint over Spring DM wherever possible.
====

There are many tutorials and guides available on the Internet for both of these frameworks.

==== Blueprint - Retrieving a Service Instance

.Blueprint example of retrieving and injecting services
[source,xml,linenums]
----
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0">

 <reference id="${ddf-branding-lowercase}CatalogFramework" interface="${ddf-branding-lowercase}.catalog.CatalogFramework" />

 <bean class="my.sample.NiftyEndpoint" >
    <argument ref="${ddf-branding-lowercase}CatalogFramework" />
 </bean>

</blueprint>
----

[cols="1,9" options="header"]
|===

|Line #
|Action

|3
|Retrieves a Service from the Registry

|6
|Instantiates a new object, injecting the retrieved Service as a constructor argument

|===

==== Spring DM - Retrieving a Service Instance

.Spring DM example of retrieving and injecting services
[source,xml,linenums]
----
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:osgi="http://www.springframework.org/schema/osgi">

  <osgi:reference id="${ddf-branding-lowercase}CatalogFramework" interface="${ddf-branding-lowercase}.catalog.CatalogFramework" />

  <bean class="my.sample.NiftyEndpoint">
     <constructor-arg ref="${ddf-branding-lowercase}CatalogFramework" />
  </bean>
</beans>
----

[cols="1,9" options="header"]
|===

|Line #
|Action

|5
|Retrieves a Service from the Registry

|8
|Instantiates a new object, injecting the retrieved Service as a constructor argument

|===

==== Blueprint - Registering a Service into the Registry

.Creating a bean and registering it into the Service Registry
[source,xml,linenums]
----
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0">

  <bean id="transformer" class="my.sample.NiftyTransformer"/>

  <service ref="transformer" interface="${ddf-branding-lowercase}.catalog.transform.QueryResponseTransformer" />

</blueprint>
----

[cols="1,9" options="header"]
|===

|Line #
|Action

|3
|Instantiates a new object

|5
|Registers the object instance created in Line 3 as a service that implements the `${ddf-branding-lowercase}.catalog.transform.QueryResponseTransformer` interface

|===

==== Packaging Capabilities as Bundles

Services and code are physically deployed to ${branding} using bundles.
The bundles within ${branding} are created using the maven bundle plug-in. Bundles are Java JAR files that have additional metadata in the `MANIFEST.MF` that is relevant to an OSGi container.

The best resource for learning about the structure and headers in the manifest definition is in section 3.6 of the https://osgi.org/download/r5/osgi.core-5.0.0.pdf[OSGi Core Specification].
The bundles within ${branding} are created using the http://felix.apache.org/documentation/subprojects/apache-felix-maven-bundle-plugin-bnd.html[maven bundle plug-in], which uses the http://bnd.bndtools.org/[BND tool].
Bundles are Java JAR files that have additional metadata in the `MANIFEST.MF` file that is relevant to an OSGi container.

.Alternative Bundle Creation Methods
[TIP]
====
Using Maven is not necessary to create bundles.
Many alternative tools exist, and OSGi manifest files can also be created by hand, although hand-editing should be avoided by most developers.
====

===== Creating a Bundle

====== Bundle Development Recommendations

Avoid creating bundles by hand or editing a manifest file:: Many tools exist for creating bundles, notably the Maven Bundle plugin, which handle the details of OSGi configuration and automate the bundling process including generation of the manifest file.
Always make a distinction on which imported packages are `optional` or `required`:: Requiring every package when not necessary can cause an unnecessary dependency ripple effect among bundles.
Embedding is an implementation detail:: Using the `Embed-Dependency` instruction provided by the `maven-bundle-plugin` will insert the specified jar(s) into the target archive and add them to the `Bundle-ClassPath`. These jars and their contained packages/classes are not for public consumption; they are for the internal implementation of this service implementation only.
Bundles should never be embedded:: Bundles expose service implementations; they do not provide arbitrary classes to be used by other bundles.
Bundles should expose service implementations:: This is the corollary to the previous rule. Bundles should not be created when arbitrary concrete classes are being extracted to a library. In that case, a library/jar is the appropriate module packaging type.
Bundles should generally _only_ export service packages:: If there are packages internal to a bundle that comprise its implementation but not its public manifestation of the API, they should be excluded from export and kept as private packages.
Concrete objects that are not loaded by the root classloader should not be passed in or out of a bundle:: This is a general rule with some exceptions (JAXB generated classes being the most prominent example). Where complex objects need to be passed in or out of a service method, an interface should be defined in the API bundle.

Bundles separate contract from implementation and allow for modularized development and deployment of functionality.
For that to be effective, they must be defined and used correctly so inadvertent coupling does not occur.
Good bundle definition and usage leads to a more flexible environment.

====== Maven Bundle Plugin

Below is a code snippet from a Maven `pom.xml` for creating an OSGi Bundle using the Maven Bundle plugin.

.Maven `pom.xml`
[source,xml,linenums]
----
...
<packaging>bundle</packaging>
...
<build>
...
  <plugin>
    <groupId>org.apache.felix</groupId>
    <artifactId>maven-bundle-plugin</artifactId>
    <configuration>
      <instructions>
        <Bundle-Name>${project.name}</Bundle-Name>
        <Export-Package />
        <Bundle-SymbolicName>${project.groupId}.${project.artifactId}</Bundle-SymbolicName>
        <Import-Package>
          ${ddf-branding-lowercase}.catalog,
          ${ddf-branding-lowercase}.catalog.*
        </Import-Package>
      </instructions>
    </configuration>
  </plugin>
...
</build>
...
----

===== Third Party and Utility Bundles

It is recommended to avoid building directly on included third party and utility bundles.
These components do provide utility and reuse potential; however, they may be upgraded or even replaced at anytime as bug fixes and new capabilities dictate.
For example, Web services may be built using CXF.
However, the distributions frequently upgrade CXF between releases to take advantage of new features.
If building on these components, be aware of the version upgrades with each distribution release.

Instead, component developers should package and deliver their own dependencies to ensure future compatibility.
For example, if re-using a bundle, the specific bundle version that you are depending on should be included in your packaged release, and the proper versions should be referenced in your bundle(s).

===== Deploying a Bundle

A bundle is typically installed in one of two ways:

. Installed as a feature
. Hot deployed in the `/deploy` directory

The fastest way to deploy a created bundle during development is to copy it to the `/deploy` directory of a running ${branding}.
This directory checks for new bundles and deploys them immediately.
According to Karaf documentation, "Karaf supports hot deployment of OSGi bundles by monitoring JAR files inside the `[home]/deploy` directory.
Each time a JAR is copied in this folder, it will be installed inside the runtime.
It can be updated or deleted and changes will be handled automatically.
In addition, Karaf also supports exploded bundles and custom deployers (Blueprint and Spring DM are included by default)."
Once deployed, the bundle should come up in the Active state, if all of the dependencies were properly met.
When this occurs, the service is available to be used.

===== Verifying Bundle State

To verify if a bundle is deployed and running, go to the running command console and view the status.

* Execute the `list` command.
* If the name of the bundle is known, the `list` command can be piped to the `grep` command to quickly find the bundle.

The example below shows how to verify if a Client is deployed and running.

.Verifying with grep
----
${ddf-branding-lowercase}${at-symbol}local>list | grep -i example
[ 162] [Active    ] [       ] [  ] [ 80] ${ddf-branding} :: Registry :: example Client (2.0.0)
----

The state is `Active`, indicating that the bundle is ready for program execution.

==== Additional Bundling Resources

* Blueprint
** http://aries.apache.org/modules/blueprint.html
** http://www.ibm.com/developerworks/opensource/library/os-osgiblueprint/
** http://static.springsource.org/osgi/docs/2.0.0.M1/reference/html/blueprint.html
* Spring DM
** http://www.springsource.org/osgi
** Lessons Learned from it-agile (PDF)
** http://www.martinlippert.org/events/OOP2010-OSGiLessonsLearned.pdf
* Creating Bundles
** http://blog.springsource.com/2008/02/18/creating-osgi-bundles/
* Bundle States
** http://static.springsource.org/osgi/docs/1.2.1/reference/html/bnd-app-ctx.html

==== Working with Features

Features XML files group other features and/or bundle(s) for ease of installation/uninstallation.

[source,xml,linenums]
----
<feature name="catalog-app" install="auto" version="${ddf.version}"
    description="The ${ddf-catalog} provides a framework for storing, searching, processing, and transforming information.\nClients typically perform query, create, read, update, and delete (QCRUD) operations against the Catalog.\nAt the core of the Catalog functionality is the Catalog Framework, which routes all requests and responses through the system, invoking additional processing per the system configuration.::${ddf-catalog}">
    <feature>platform-app</feature>
    <feature>catalog-core</feature>
    <feature>catalog-core-metricsplugin</feature>
    <feature>catalog-core-sourcemetricsplugin</feature>
    <feature>catalog-transformer-thumbnail</feature>
    <feature>catalog-transformer-metadata</feature>
    <feature>catalog-transformer-xsltengine</feature>
    <feature>catalog-transformer-resource</feature>
    <feature>catalog-rest-endpoint</feature>
    <feature>catalog-opensearch-endpoint</feature>
    <feature>catalog-opensearch-source</feature>
    <feature>catalog-transformer-json</feature>
    <feature>catalog-transformer-atom</feature>
    <feature>catalog-transformer-geoformatter</feature>
    <feature>catalog-transformer-xml</feature>
    <feature>catalog-transformer-tika</feature>
    <feature>catalog-security-plugin</feature>
    <feature>catalog-admin-module-sources</feature>
    <feature>catalog-core-backupplugin</feature>
    <feature>catalog-plugin-jpeg2000</feature>
</feature>

<feature name="catalog-core" install="manual" version="${ddf.version}"
    description="Catalog Core feature containing the API, third party bundles necessary to run ${ddf-branding-lowercase}-core.">
    <feature>catalog-core-api</feature>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-commons/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-camelcomponent/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.measure/measure-api/${ddf.version}</bundle>
    <bundle>mvn:org.codice.thirdparty/picocontainer/1.2_1</bundle>
    <bundle>mvn:org.codice.thirdparty/vecmath/1.3.2_1</bundle> <!-- for GeoTools -->
    <bundle>mvn:org.codice.thirdparty/geotools-suite/${org.geotools.bundle.version}</bundle>
    <bundle>mvn:org.codice.thirdparty/jts/${jts.bundle.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-federationstrategy/${ddf.version}</bundle>
    <bundle>mvn:org.codice.thirdparty/lucene-core/3.0.2_1</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/${ddf-branding-lowercase}-pubsub/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-eventcommands/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/${ddf-branding-lowercase}-pubsub-tracker/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-urlresourcereader/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/filter-proxy/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-commands/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-metacardgroomerplugin/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/metacard-type-registry/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-standardframework/${ddf.version}</bundle>
    <bundle>mvn:${ddf-branding-lowercase}.catalog.core/catalog-core-resourcesizeplugin/${ddf.version}</bundle>

    <configfile finalname="/data/solr/metacard_cache/conf/solrconfig.xml">mvn:ddf.platform.solr/platform-solr-server-standalone/${ddf.version}/xml/solrconfig</configfile>
    <configfile finalname="/data/solr/metacard_cache/conf/schema.xml">mvn:ddf.platform.solr/platform-solr-server-standalone/${ddf.version}/xml/schema</configfile>
    <configfile finalname="/data/solr/metacard_cache/conf/protwords.txt">mvn:ddf.platform.solr/platform-solr-server-standalone/${ddf.version}/txt/protwords</configfile>
    <configfile finalname="/data/solr/metacard_cache/conf/stopwords_en.txt">mvn:ddf.platform.solr/platform-solr-server-standalone/${ddf.version}/txt/stopwords_en</configfile>
    <configfile finalname="/data/solr/metacard_cache/conf/stopwords.txt">mvn:ddf.platform.solr/platform-solr-server-standalone/${ddf.version}/txt/stopwords</configfile>
    <configfile finalname="/data/solr/metacard_cache/conf/synonyms.txt">mvn:ddf.platform.solr/platform-solr-server-standalone/${ddf.version}/txt/synonyms</configfile>
</feature>
----

==== Making Sure a Features File Will Display Properly in the Installer

In order to ensure that the installer can correctly interpret and display application details, there are several guidelines that should be followed when creating the features file for the application.

* Be sure that only one feature in the `features.xml` has the `auto-install` tag.
+
[source]
----
install='auto'
----
+
This is the feature that the installer displays to the user (name, description, version, etc.). It is typically named after the application itself and the description provides a complete application description.
* Be sure that the one feature specified to `auto-install` has a complete list of all of its dependencies in order to ensure the dependency tree can be constructed correctly.

===== Auto-starting an Application Feature

Within the `features.xml` file for an application, one feature will have the install attribute set to `auto`.
Within this feature, refer to any dependencies of the application as well as any features that should start automatically.
Other features should have install set to `manual`.

The following example demonstrates configuring features to be auto-started. The naming convention for this feature is typically "`application name`" + "`-app`," as shown.

.Auto-start features
[source,xml,linenums]
----
<feature name="catalog-app" install="auto">
    <feature>platform-app</feature>
    <feature>catalog-core</feature>
    <feature>catalog-core-metricsplugin</feature>
    <feature>catalog-core-sourcemetricsplugin</feature>
    <feature>catalog-transformer-thumbnail</feature>
</feature>
----

=== Developing ${branding} Applications

The ${branding} applications are comprised of components, packaged as Karaf features, which are collections of OSGi bundles.
These features can be installed/uninstalled using the ${admin-console} or ${command-console}.
${branding} applications also consist of one or more OSGi bundles and, possibly, supplemental external files.
These applications are packaged as Karaf KAR files for easy download and installation.
These applications can be stored on a file system or a Maven repository.

A KAR file is a Karaf-specific archive format (*K*araf *AR*chive).
It is a jar file that contains a feature descriptor file and one or more OSGi bundle jar files.
The feature descriptor file identifies the application's name, the set of bundles that need to be installed, and any dependencies on other features that may need to be installed.

==== Describing Application Services

Given the modular nature of OSGi, some applications perform operations on the services themselves.
In order to present, identify, and manipulate the services, they need descriptive identifying information.
Any service that implements the `Describable` interface in `org.codice.ddf.platform.services.common` will
have an obligation to provide this information. The relevant fields are as follows:

* ID: a unique identifier for the service
* Title: the informal name for the service
* Description: a short, human-consumable description of the service
* Organization: the name of the organization that wrote the service
* Version: the current version of the service (example: 1.0)

The only field with stringent requirements is the ID field. Format should be `[*product*].[*component*]`
such as `ddf.metacards` or `ddf.platform`; while the [*component*] within a [*product*] may simply be
a module or bundle name, the [*product*] itself should be the unique name of the plug-in or integration
that belongs to the organization provided. Note that `ddf` as a [*product*] is reserved for core features
only and is not meant to be used during extension or integration.

==== Creating a KAR File

The recommended method for creating a KAR file is to use the `features-maven-plugin`, which has a `create-kar` goal.
This goal reads all of the features specified in the feature's descriptor file.
For each feature in this file, it resolves the bundles defined in the feature.
All bundles are then packaged into the KAR archive.

.create-kar Goal Example
[source,xml,linenums]
----
<plugin>
<groupId>org.apache.karaf.tooling</groupId>
<artifactId>features-maven-plugin</artifactId>
<version>2.2.5</version>
	<executions>
	    <execution>
	        <id>create-kar</id>
	        <goals>
	            <goal>create-kar</goal>
	        </goals>
	        <configuration>
	            <descriptors>
	                <!-- Add any other <descriptor> that the features file may reference here -->
	            </descriptors>
	            <!--
	            Workaround to prevent the target/classes/features.xml file from being included in the
	            kar file since features.xml already included in kar's repository directory tree.
	            Otherwise, features.xml would appear twice in the kar file, hence installing the
	            same feature twice.
	            Refer to Karaf forum posting at http://karaf.922171.n3.nabble.com/Duplicate-feature-repository-entry-using-archive-kar-to-build-deployable-applications-td3650850.html
	            -->
	            <resourcesDir>${project.build.directory}/doesNotExist</resourcesDir>

	            <!--
	            Location of the features.xml file. If it references properties that need to be filtered, e.g., ${project.version}, it will need to be
	            filtered by the maven-resources-plugin.
	            -->
	            <featuresFile>${basedir}/target/classes/features.xml</featuresFile>

	            <!-- Name of the kar file (.kar extension added by default). If not specified, defaults to ${project.build.finalName} -->
	            <finalName>${ddf-branding-lowercase}-ifis-${project.version}</finalName>
	        </configuration>
	    </execution>
    </executions>
</plugin>
----

Examples of how KAR files are created for ${branding} components can be found in the ${branding} source code under the ${branding-lowercase}/distribution/${branding-lowercase}-kars directory.

The `.kar` file generated should be deployed to the application author's maven repository.
The URL to the application's KAR file in this Maven repository should be the installation URL that is used.

==== Including Data Files in a KAR File

The developer may need to include data or configuration file(s) in a KAR file.
An example of this is a properties file for the JDBC connection properties of a catalog provider.

It is recommended that:

* Any `data/configuration` files be placed under the `src/main/resources` directory of the maven project.
Sub-directories under `src/main/resources` can be used, e.g., `etc/security`.
* The Maven project's pom file should be updated to attach each `data/configuration` file as an artifact (using the `build-helper-maven-plugin`).
* Add each `data/configuration` file to the KAR file using the `<configfile>` tag in the KAR's `features.xml` file.

==== Installing a KAR File

When the user downloads an application by clicking on the *Installation* link, the application's KAR file is downloaded.
To install manually, the KAR file can be placed in the `<${branding}_INSTALL_DIR>/deploy` directory of the running ${branding} instance. ${branding} then detects that a file with a `.kar` file extension has been placed in this monitored directory, unzips the KAR file into the `<${branding}_INSTALL_DIR>/system` directory, and installs the bundle(s) listed in the KAR file's feature descriptor file.
To install via the ${admin-console}:
. Navigate to ${secure_url}/admin
. Click the *Manage* button in the upper right
. Click the *Add an Application* tile
. Upload the KAR file via the popup window
. Click *Save Changes* to activate
The new application can be viewed via the ${admin-console}'s Active Applications list.

===== Developing Application Configuration Modules

An application within ${branding} is a collection of bundles contained in a KAR file that may or may not have configurations associated with it.
Plugins are used to advertise applications.
These configuration module plugins are often used to add user interface elements to make the use of the ${branding} simpler and/or more intuitive.

====== Creating an Application Configuration Module

This example demonstrates a plugin that allows the ${branding} to use the Admin UI.

. Create an application plugin to advertise your configuration by extending `AbstractApplicationPlugin`.
+
[source,java,linenums]
----
import org.codice.${ddf-branding-lowercase}.admin.application.plugin.AbstractApplicationPlugin;

public class SourcesPlugin extends AbstractApplicationPlugin {
    /**
     * Constructor.
     */

    public SourcesPlugin() {
        this.displayName = "Sources";
        this.iframeLocation = URI.create("/admin/sources/index.html");
        List<String> apps = new ArrayList<String>();
        apps.add("catalog-app");
        this.setAssociations(apps);
    }
}
----
+
. Configure as shown with a name, URI, and any dependency applications.
. Register the application with Blueprint through a `blueprint.xml` file.
+
.`blueprint.xml`
[source,xml,linenums]
----
<blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="
  http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd">

    <bean id="appModule" class="org.codice.ui.admin.applications.ApplicationModule"></bean>

    <service interface="org.codice.ddf.ui.admin.api.module.AdminModule" ref="appModule" />

</blueprint>
----
+
. Create application to use this configuration.

===== Including KAR Files

Sometimes a developer may need to include data or configuration file(s) in a KAR file.
An example of this would be a properties file for the JDBC connection properties of a catalog provider.

It is recommended that:

* Any data/configuration files be placed under the `src/main/resources` directory of the maven project.
(Sub-directories under `src/main/resources` can also be used, e.g., `etc/security`)
* The maven project's pom file should be updated to attach each data/configuration file as an artifact (using the `build-helper-maven-plugin`)
* Add each data/configuration file to the KAR file by using the `<configfile>` tag in the KAR's `features.xml` file
